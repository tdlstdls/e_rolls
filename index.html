<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>イベントガチャロールズ</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.2;
            padding: 10px;
            max-width: 800px;
            margin: 0 auto;
            background-color: #f4f7f9;
            color: #333;
            font-size: 10px;
        }
        .container {
            background: #fff;
            padding: 10px;
            border-radius: 12px;
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.1);
        }
        h1 {
            color: #004085;
            font-size: 1rem;
            border-bottom: 1px solid #e9ecef;
            padding-bottom: 3px;
            margin-top: 0;
            text-align: center;
        }
        .controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 15px;
            padding: 6px;
            background-color: #f9fbfd;
            border-radius: 4px;
        }
        .row {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
            gap: 3px;
        }
        .input-item {
            flex: 1 1 150px;
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 3px;
        }
        .input-item-seed {
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 3px;
        }
        .seed-input-group {
            display: flex;
            align-items: center;
            gap: 5px;
            flex: 1 1 200px;
        }
        label {
            font-weight: 600;
            color: #555;
        }
        input[type="number"],
        select {
            padding: 3px;
            border: 1px solid #ccc;
            border-radius: 3px;
            font-size: 0.8rem;
            width: 100%;
            box-sizing: border-box;
            transition: border-color 0.3s;
        }
        input[type="number"]:focus,
        select:focus {
            outline: none;
            border-color: #007bff;
        }
        button {
            flex-shrink: 0;
            width: auto;
            padding: 5px 10px;
            background-color: #007bff;
            color: #fff;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.8rem;
            font-weight: bold;
            transition: background-color 0.3s ease, transform 0.2s ease;
        }
        button:hover {
            background-color: #0056b3;
            transform: translateY(-2px);
        }
        #result-container {
            margin-top: 25px;
        }
        #result-table-container {
            overflow-x: auto;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
        }
        table {
            width: 100%;
            border-collapse: collapse;
            table-layout: fixed;
        }
        th, td {
            padding: 5px;
            text-align: center;
            border: 1px solid #e0e0e0;
            word-break: break-word;
            font-size: 0.8rem;
        }
        th {
            background-color: #f0f4f7;
            color: #444;
            font-weight: 600;
            position: sticky;
            top: 0;
        }
        td {
            background-color: #fff;
        }
        .row-number-header {
            font-family: Arial, sans-serif;
            font-weight: bold;
            width: 25px;
            cursor: pointer;
        }
        .featuredItem-text {
            color: #d9534f;
            font-weight: bold;
        }
        .re-gacha-cell {
            line-height: 1.2;
        }
        .path-cell {
            background-color: #e6ffe6 !important;
        }
        .g-ten-pull-highlight {
            background-color: #fffacd;
        }
        a {
            color: inherit;
            text-decoration: none;
        }
        #gachaIdSelector { width: 150px; }
        #guaranteedRollsInput { width: 75px; }
        #featuredStockInput { width: 75px; }
    </style>
</head>
<body>

<div class="container">
    <h1>イベントガチャロールズ</h1>
    <div class="input-group">
        <div class="controls">
            <div class="row">
                <div class="input-item">
                    <label for="gachaIdSelector">Gacha</label>
                    <select id="gachaIdSelector">
                        <option value="34">ハロウィン</option>
                        <option value="42" selected>1.1億DL記念</option>
                    </select>
                </div>
                <div class="input-item">
                    <label for="guaranteedRollsInput">next guaranteed</label>
                    <select id="guaranteedRollsInput"></select>
                </div>
                <div class="input-item">
                    <label for="featuredStockInput">目玉残数</label>
                    <select id="featuredStockInput"></select>
                </div>
            </div>

            <div class="row">
                <div class="input-item-seed">
                    <label for="seedInput">SEED</label>
                    <div class="seed-input-group">
                        <input type="number" id="seedInput" value="123456789">
                        <button id="executeButton">更新</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div id="result-container">
        <div id="output"></div>
        <div id="result-table-container"></div>
    </div>
</div>

<script>
    // グローバル変数として宣言
    let path = []; // ガチャの進行経路（抽選に使われるセルのインデックス）を格納する配列
    let xorshiftArray = []; // Xorshift32で生成された乱数（シード値）を格納する配列
    let moduloArray = []; // 乱数を10000で割った余りを格納する配列
    
    // URLからSEED値とguaranteed値を取得して設定
    const params = new URLSearchParams(window.location.search); // URLのクエリパラメータを取得
    const urlSeed = params.get('seed'); // 'seed'パラメータの値を取得
    const urlGuaranteed = params.get('ng'); // 'ng' (next guaranteed) パラメータの値を取得
    const urlFeaturedStock = params.get('fs'); // 'fs' (featured stock) パラメータの値を取得
    
    if (urlSeed) { // URLにseedパラメータがあれば
        document.getElementById('seedInput').value = urlSeed; // シード値入力欄に値を設定
    }
    
    function xorshift32(seed) { // Xorshift32アルゴリズムによる疑似乱数生成
        let x = seed; // シード値をxに代入
        x ^= x << 13; // ビット演算
        x ^= x >>> 17; // ビット演算
        x ^= x << 15; // ビット演算
        return x >>> 0; // 32ビット符号なし整数として返す
    }
    
    const gachaMaster = {
        '34': {
            name: 'ハロウィン', // ガチャ名
            featuredItemRate: 600,
            featuredItemStock: 5,
            rarityRates: { '0': 2000, '1': 5000, '2': 3000, '3': 0, '4': 0 }
        },
        '42': {
            name: '1.1億DL記念',
            featuredItemRate: 500, // 目玉アイテムの排出率 (10000分率)
            featuredItemStock: 5,
            rarityRates: { '0': 1000, '1': 5000, '2': 3000, '3': 1000, '4': 0 }
        }
    };

    // 各ガチャで排出されるアイテムの全リスト
    const gachaPools = {
        '34': [0, 2, 3, 4, 5, 10, 11, 12, 14],
        '42': [0, 2, 3, 4, 5, 10, 11, 12, 14, 375, 381, 689],
    };

    const itemMaster = {
        0: { name: "スピダ", rarity: 1 },
        2: { name: "ネコボン", rarity: 2 },
        3: { name: "ニャンピュ", rarity: 1 },
        4: { name: "おかめ", rarity: 2 },
        5: { name: "スニャ", rarity: 2 },
        10: { name: "5千XP", rarity: 0 },
        11: { name: "1万XP", rarity: 1 },
        12: { name: "3万XP", rarity: 1 },
        14: { name: "10万XP", rarity: 2 },
        375: { name: "記念ネコ", rarity: 3 },
        381: { name: "ねこ農家", rarity: 3 },
        689: { name: "石の上にも10年ネコ", rarity: 3 }
    };
    
    // アイテム名からIDを逆引きするためのマップを事前に作成
    const itemNameMap = Object.fromEntries(
        Object.entries(itemMaster).map(([id, { name }]) => [name, parseInt(id, 10)])
    );
    
    // gachaMasterにrarityItemsを自動で設定する関数
    function setupGachaRarityItems() {
        for (const gachaId in gachaPools) {
            if (gachaMaster[gachaId]) {
                const pool = gachaPools[gachaId];
                const rarityItems = { '0': [], '1': [], '2': [], '3': [], '4': [] };

                for (const itemId of pool) {
                    const item = itemMaster[itemId];
                    if (item && rarityItems[item.rarity] !== undefined) {
                        rarityItems[item.rarity].push(itemId);
                    }
                }

                // 各レアリティのアイテムリストを昇順でソートし、定義順に依存しないようにする
                for (const rarity in rarityItems) {
                    rarityItems[rarity].sort((a, b) => a - b);
                }

                gachaMaster[gachaId].rarityItems = rarityItems;
            }
        }
    }

    // HTML要素の取得
    const seedInput = document.getElementById('seedInput'); // シード値入力欄
    const gachaIdSelector = document.getElementById('gachaIdSelector'); // ガチャ選択ドロップダウン
    const guaranteedRollsInput = document.getElementById('guaranteedRollsInput'); // 次回確定枠入力ドロップダウン
    const featuredStockInput = document.getElementById('featuredStockInput'); // 目玉残数入力ドロップダウン
    const executeButton = document.getElementById('executeButton'); // 更新ボタン
    const output = document.getElementById('output'); // 結果表示用のdiv
    const resultTableContainer = document.getElementById('result-table-container'); // 結果テーブルのコンテナ
    let forceReGachaMode = false; // 強制再抽選モードのフラグ

    // スクリプトの初期化段階でgachaMasterのrarityItemsを構築
    setupGachaRarityItems();

    // 目玉残数ドロップダウンを生成する関数
    function populateFeaturedStockInput(preferredValue = 'none') {
        const selectedGachaId = gachaIdSelector.value;
        const gacha = gachaMaster[selectedGachaId];
        const stock = gacha.featuredItemStock;

        // 既存のオプションをクリア
        featuredStockInput.innerHTML = '';

        // 「-」オプションを追加
        const unsetOption = document.createElement('option');
        unsetOption.value = 'none';
        unsetOption.textContent = '-';
        featuredStockInput.appendChild(unsetOption);

        // 1からストック数までのオプションを追加
        for (let i = 1; i <= stock; i++) {
            const option = document.createElement('option');
            option.value = i;
            option.textContent = i;
            featuredStockInput.appendChild(option);
        }

        // 渡された値を優先して設定し、それが無効なら「-」にする
        if (preferredValue && preferredValue !== 'none' && featuredStockInput.querySelector(`option[value="${preferredValue}"]`)) {
            featuredStockInput.value = preferredValue;
        } else {
            featuredStockInput.value = 'none';
        }
    }

    // ガチャ選択が変更されたときのイベントリスナー
    gachaIdSelector.addEventListener('change', () => {
        const currentValue = featuredStockInput.value; // 現在の選択値を保持
        populateFeaturedStockInput(currentValue); // 目玉残数ドロップダウンを更新し、現在の値を復元しようと試みる
        runSimulationAndDisplay(); // シミュレーションを再実行
    });

    // 更新ボタンがクリックされたときのイベントリスナー
    executeButton.addEventListener('click', () => {
        runSimulationAndDisplay(); // シミュレーションを再実行
    });

    // 「次回確定枠」ドロップダウンの初期化
    const rollSelect = document.getElementById('guaranteedRollsInput'); // ドロップダウン要素を取得

    const unsetValue = 'none'; // 「未設定」の選択肢の値
    const unsetOption = document.createElement('option'); // option要素を新規作成
    unsetOption.value = unsetValue; // value属性を設定
    unsetOption.textContent = '未設定'; // 表示テキストを設定
    rollSelect.appendChild(unsetOption); // ドロップダウンに「未設定」を追加

    for (let i = 1; i <= 30; i++) { // 1から30までの選択肢を生成
        const option = document.createElement('option'); // option要素を新規作成
        option.value = i; // value属性に数値を設定
        option.textContent = i; // 表示テキストに数値を設定
        rollSelect.appendChild(option); // ドロップダウンに追加
    }
    
    if (urlGuaranteed) { // URLに 'ng' パラメータが存在する場合
        guaranteedRollsInput.value = urlGuaranteed; // ドロップダウンの値をURLの値に設定
    } else { // 存在しない場合
        guaranteedRollsInput.value = unsetValue; // 「未設定」を選択状態にする
    }
    
    // 「次回確定枠」ドロップダウンが変更されたときのイベントリスナー
    guaranteedRollsInput.addEventListener('change', () => {
        runSimulationAndDisplay(); // シミュレーションを再実行
    });

    // 目玉残数ドロップダウンの初期化とイベントリスナー設定
    populateFeaturedStockInput(urlFeaturedStock);
    featuredStockInput.addEventListener('change', () => {
        runSimulationAndDisplay();
    });

    // シミュレーションを実行し、結果を表示するメインの関数
    function runSimulationAndDisplay() {
        const seedValue = parseInt(seedInput.value, 10); // 入力されたシード値を取得し、整数に変換
        const selectedGachaId = gachaIdSelector.value; // 選択されたガチャのIDを取得
        const firstGuaranteedRolls = parseInt(guaranteedRollsInput.value, 10) || 30; // 選択された次回確定枠の回数を取得（未設定の場合は30）

        const featuredStockLimitStr = featuredStockInput.value;
        const featuredStockLimit = featuredStockLimitStr === 'none' ? Infinity : parseInt(featuredStockLimitStr, 10);

        if (isNaN(seedValue)) { // シード値が数値でない場合
            output.textContent = '有効な数値を入力してください。'; // エラーメッセージを表示
            return; // 処理を中断
        }

        const gacha = gachaMaster[selectedGachaId]; // 選択されたガチャのデータを取得
        if (!gacha) { // ガチャデータが存在しない場合
            output.textContent = '無効なガチャIDです。'; // エラーメッセージを表示
            return; // 処理を中断
        }
        
        xorshiftArray = []; // シード値の配列を初期化
        moduloArray = []; // 剰余の配列を初期化
        let currentSeed = seedValue; // 現在のシード値を初期化
        for (let i = 0; i < 1000; i++) { // 1000個のシード値を生成
            currentSeed = xorshift32(currentSeed); // 次のシード値を生成
            xorshiftArray.push(currentSeed); // シード値配列に追加
            moduloArray.push(currentSeed % 10000); // 10000で割った余りを配列に追加
        }
        
        const rates = gacha.rarityRates;
        const thresholds = {
            '0': rates['0'],
            '1': rates['0'] + rates['1'],
            '2': rates['0'] + rates['1'] + rates['2'],
            '3': rates['0'] + rates['1'] + rates['2'] + rates['3'],
            '4': 10000
        };

        // シミュレーション結果を格納する配列を初期化
        let items = new Array(300).fill(-1); // 各セルのアイテムID
        let rarities = new Array(300).fill(-1); // 各セルのレアリティID
        let isfeaturedItemCell = new Array(300).fill(false); // 各セルが目玉アイテムかどうか
        let reGachaItems = new Array(300).fill("---"); // 各セルの再抽選アイテム名
        let eligibleForReGacha = new Array(300).fill(false); // 各セルが再抽選の対象となるか
        
        // 300セル分のガチャ結果を事前に計算
        for (let i = 0; i < 300; i++) {
            const hitSeedIndex = i; // 目玉判定に使用するシードのインデックス
            const raritySeedIndex = i + 1; // レアリティ判定に使用するシードのインデックス
            const itemSeedIndex = i + 2; // アイテム決定に使用するシードのインデックス

            if (itemSeedIndex >= xorshiftArray.length) continue; // シードが足りなくなったらループを抜ける

            const isHit = (moduloArray[hitSeedIndex] < gacha.featuredItemRate); // 目玉アイテムに当選したか判定
            isfeaturedItemCell[i] = isHit; // 結果を保存

            if (isHit) continue; // 目玉アイテムなら、それ以降の判定は不要
            
            // レアリティを決定
            let rarityId;
            if (moduloArray[raritySeedIndex] < thresholds['0']) { rarityId = 0; }
            else if (moduloArray[raritySeedIndex] < thresholds['1']) { rarityId = 1; }
            else if (moduloArray[raritySeedIndex] < thresholds['2']) { rarityId = 2; }
            else if (moduloArray[raritySeedIndex] < thresholds['3']) { rarityId = 3; }
            else { rarityId = 4; }
            rarities[i] = rarityId; // 結果を保存

            // アイテムを決定
            const itemInfo = gacha.rarityItems[rarityId]; // 該当レアリティのアイテムリストを取得
            const itemCounts = itemInfo.length; // アイテムリストの長さを取得
            if (itemCounts > 0) { // アイテムリストにアイテムが存在する場合
                const itemOffset = xorshiftArray[itemSeedIndex] % itemCounts; // シード値からアイテムを決定
                items[i] = itemInfo[itemOffset]; // 結果を保存
            }

            // 再抽選（レア被り救済）のロジック
            if (rarityId === 1 && itemCounts >= 2) { // レアリティが「レア」で、アイテムが2種類以上ある場合
                const reGachaSeedIndex = itemSeedIndex + 1; // 再抽選用のシードインデックス
                if (reGachaSeedIndex < xorshiftArray.length) { // シードが足りる場合
                    const originalItemNoList = [...itemInfo]; // 元のアイテムリストをコピー
                    const itemIndex = originalItemNoList.indexOf(items[i]); // 今回抽選されたアイテムのインデックスを探す
                    if (itemIndex > -1) { // 見つかった場合
                        originalItemNoList.splice(itemIndex, 1); // リストからそのアイテムを削除（再抽選では同じものは出ない）
                    }
                    const newDivisor = originalItemNoList.length; // 再抽選対象のアイテム数
                    const seedForReGacha = xorshiftArray[reGachaSeedIndex]; // 再抽選用のシード値
                    const reGachaOffset = seedForReGacha % newDivisor; // 再抽選結果のインデックスを計算
                    const reGachaItemId = originalItemNoList[reGachaOffset]; // 再抽選されたアイテムID
                    reGachaItems[i] = itemMaster[reGachaItemId].name; // 再抽選アイテム名を保存

                    // 実際のゲーム内での再抽選が発生するかどうかの条件判定
                    let backOffset = 3; // 通常、3つ前のアイテムと比較する
                    let tempIndex = i - 1; // 1つ前のセルから遡る
                    while (tempIndex >= 0 && isfeaturedItemCell[tempIndex]) { // 目玉アイテムが連続している場合はその分オフセットを増やす
                        backOffset += 1;
                        tempIndex -= 1;
                    }

                    if (i >= backOffset) { // 比較対象の過去のセルが存在する場合
                        if(rarities[i] === 1){ // レアリティが「レア」の場合のみ
                            if(items[i] === items[i - 3]){ // 3つ前のアイテムと被った場合
                                eligibleForReGacha[i] = true; // 再抽選対象
                            }
                            if(items[i] === items[i - backOffset]){ // 目玉を考慮したオフセット前のアイテムと被った場合
                                eligibleForReGacha[i] = true; // 再抽選対象
                            }
                            else if(reGachaItems[i - 1] !== "---" && items[i] === itemNameMap[reGachaItems[i - 1]]){ // 1つ前の再抽選後アイテムと被った場合
                                if(eligibleForReGacha[i - backOffset - 1]){ // さらにその前のアイテムが再抽選対象だった場合
                                    eligibleForReGacha[i] = true; // 再抽選対象
                                }
                            }
                            else if(reGachaItems[i - backOffset - 1] !== "---" && items[i] === itemNameMap[reGachaItems[i - backOffset - 1]]){ // 目玉考慮オフセット前の再抽選後アイテムと被った場合
                                if(eligibleForReGacha[i - backOffset - 1]){ // さらにその前のアイテムが再抽選対象だった場合
                                    eligibleForReGacha[i] = true; // 再抽選対象
                                }
                            }
                        }
                    }
                    
                    reGachaItems[i] = "---"; // デフォルトでは再抽選アイテムは表示しない
                    if (forceReGachaMode || eligibleForReGacha[i]) { // 強制表示モードか、再抽選対象の場合
                        reGachaItems[i] = itemMaster[reGachaItemId].name; // 再抽選アイテムを表示する
                    }
                }
            }
        }

        // ユーザーが実際に辿るガチャの進行経路（path）を計算
        path = []; // 経路を初期化
        let currentCellIndex = 0; // 現在のセルのインデックス
        let lastActualItemId = -1; // 実際に最後に出現したアイテムのID
        while (currentCellIndex < 300) { // 300セルまで計算
            if (currentCellIndex >= isfeaturedItemCell.length) break; // 配列の範囲外なら終了
            path.push(currentCellIndex); // 現在のセルを経路に追加

            if (isfeaturedItemCell[currentCellIndex]) { // 目玉アイテムの場合
                currentCellIndex += 1; // シードを1消費し、次のセルへ
            } else if (eligibleForReGacha[currentCellIndex] && lastActualItemId === items[currentCellIndex]) { // 再抽選対象で、かつ前のアイテムと被った場合
                lastActualItemId = itemNameMap[reGachaItems[currentCellIndex]]; // 実際に出現するのは再抽選後のアイテム
                currentCellIndex += 4; // シードを4消費し、4つ先のセルへ
            } else { // 通常のアイテムの場合
                lastActualItemId = items[currentCellIndex]; // 実際に出現するのはこのセルのアイテム
                currentCellIndex += 3; // シードを3消費し、3つ先のセルへ
            }
        }
        
        // G列に表示する10連ガチャの結果をシミュレーション
        const tenPullResults = new Array(10).fill(null);
        const tenPullRarities = new Array(10).fill(-1); // For G9 link logic
        const isFeaturedSlot = new Array(10).fill(false);

        // --- フェーズ1: 目玉判定 ---

        // (1) 確定枠の位置と、目玉抽選に使うシード数を決める
        const isGuaranteedInTenPull = firstGuaranteedRolls > 0 && firstGuaranteedRolls <= 10;
        const seedsForHitCheck = isGuaranteedInTenPull ? 9 : 10;
        const guaranteedSlotIndex = isGuaranteedInTenPull ? firstGuaranteedRolls - 1 : -1;

        // (2) 抽選による目玉を決定する
        let lotteryFeaturedCount = 0;
        let hitCheckSeedOffset = 0;
        const lotteryHitSlots = []; // 抽選で当たったスロットのインデックスを記録

        for (let i = 0; i < 10; i++) {
            // 確定枠は抽選対象外
            if (i === guaranteedSlotIndex) {
                continue;
            }

            // 抽選を行う
            if (hitCheckSeedOffset < seedsForHitCheck) {
                const isHit = (moduloArray[hitCheckSeedOffset] < gacha.featuredItemRate);
                if (isHit) {
                    lotteryHitSlots.push(i);
                }
                hitCheckSeedOffset++;
            }
        }

        // (2) 抽選目玉と確定枠を、目玉残数を考慮して最終的な目玉スロットに反映する
        let featuredItemsDrawnCount = 0;

        // まず抽選目玉を反映
        for (const slotIndex of lotteryHitSlots) {
            if (featuredItemsDrawnCount < featuredStockLimit) {
                isFeaturedSlot[slotIndex] = true;
                featuredItemsDrawnCount++;
            }
        }

        // 次に確定枠を反映
        if (guaranteedSlotIndex !== -1) {
            // 確定枠の時点で残数があるか？
            if (featuredItemsDrawnCount < featuredStockLimit) {
                isFeaturedSlot[guaranteedSlotIndex] = true;
            }
        }

        // --- フェーズ2: レアリティ・アイテム抽選 ---
        let seedOffset = seedsForHitCheck; // (3) 目玉抽選で使用したSEEDに続くSEEDから
        let prevItemId = -1;

        for (let i = 0; i < 10; i++) {
            if (isFeaturedSlot[i]) {
                tenPullResults[i] = (i === guaranteedSlotIndex) ? '目玉(確定)' : '目玉';
                prevItemId = -1; // 目玉は再抽選チェーンをリセット
                continue;
            }

            // --- 目玉ではなかったスロットの処理 ---
            const raritySeedIndex = seedOffset;
            const itemSeedIndex = seedOffset + 1;
            const reGachaSeedIndex = seedOffset + 2;

            // レアリティ決定
            let rarityId;
            if (moduloArray[raritySeedIndex] < thresholds['0']) { rarityId = 0; }
            else if (moduloArray[raritySeedIndex] < thresholds['1']) { rarityId = 1; }
            else if (moduloArray[raritySeedIndex] < thresholds['2']) { rarityId = 2; }
            else if (moduloArray[raritySeedIndex] < thresholds['3']) { rarityId = 3; }
            else { rarityId = 4; }
            if (i === 9) tenPullRarities[i] = rarityId;

            // アイテム決定
            const itemInfo = gacha.rarityItems[rarityId];
            const itemCounts = itemInfo.length;
            let itemName = "---";
            let currentItemId = -1;
            if (itemCounts > 0) {
                const itemOffset = xorshiftArray[itemSeedIndex] % itemCounts;
                currentItemId = itemInfo[itemOffset];
                itemName = itemMaster[currentItemId] ? itemMaster[currentItemId].name : "不明";
            }
            
            let displayItemName = itemName;
            let seedsForThisRoll = 2; // rarity + item

            // 再抽選判定
            if (rarityId === 1 && itemCounts >= 2 && i > 0 && prevItemId !== -1 && prevItemId === currentItemId) {
                if (reGachaSeedIndex < xorshiftArray.length) {
                    const originalItemNoList = [...itemInfo];
                    const itemIndex = originalItemNoList.indexOf(currentItemId);
                    if (itemIndex > -1) originalItemNoList.splice(itemIndex, 1);
                    
                    const newDivisor = originalItemNoList.length;
                    if (newDivisor > 0) {
                        const seedForReGacha = xorshiftArray[reGachaSeedIndex];
                        const reGachaOffset = seedForReGacha % newDivisor;
                        const reGachaItemId = originalItemNoList[reGachaOffset];
                        
                        displayItemName = `${itemName}<br>${itemMaster[reGachaItemId].name}`;
                        prevItemId = reGachaItemId;
                        seedsForThisRoll++; // re-gacha seed
                    } else {
                        prevItemId = currentItemId;
                    }
                } else {
                    prevItemId = currentItemId;
                }
            } else {
                prevItemId = currentItemId;
            }
            
            tenPullResults[i] = displayItemName;
            seedOffset += seedsForThisRoll;
        }

        const initialStockForUrl = featuredStockLimitStr === 'none' ? gacha.featuredItemStock : parseInt(featuredStockLimitStr, 10);
        const featuredItemsDrawnInTenPull = isFeaturedSlot.filter(Boolean).length;
        const stockAfterTenPull = Math.max(0, initialStockForUrl - featuredItemsDrawnInTenPull);

        const nextRollIndex = seedOffset; // 10連ガチャ後の次のシードインデックス
        const nextRollRow = Math.floor(nextRollIndex / 3) + 1; // 次のロールの行番号
        const nextRollCol = String.fromCharCode('A'.charCodeAt(0) + ((nextRollIndex) % 3)); // 次のロールの列文字
        const nextRollAddress = `${nextRollCol}${nextRollRow}`; // 次のロールのアドレス (例: B34)
        const originalG9Content = tenPullResults[9] || '---';

        let newG9Display;
        const currentGuaranteedRolls = parseInt(guaranteedRollsInput.value, 10) || 30;
        const pathPositionForTenPull = 10;
        let nextGuaranteedForTenPull = currentGuaranteedRolls - pathPositionForTenPull;
        if (nextGuaranteedForTenPull <= 0) {
            nextGuaranteedForTenPull += 30;
        }

        const tenPullLinkHref = `href="?seed=${xorshiftArray[nextRollIndex - 1]}&ng=${nextGuaranteedForTenPull}&fs=${stockAfterTenPull}"`;

        if (originalG9Content.includes('<br>')) { // 10連の最後が再抽選だった場合
            const originalItem = originalG9Content.split('<br>')[0].trim(); // 元のアイテム
            const reGachaItem = originalG9Content.split('<br>')[1].trim(); // 再抽選後のアイテム
            newG9Display = `${originalItem}<br><a ${tenPullLinkHref} class="re-gacha-cell">${nextRollAddress}) ${reGachaItem}</a>`;
        } else {
            if (tenPullRarities[9] === 3) {
                newG9Display = `<a ${tenPullLinkHref} class="re-gacha-cell"><span class="featuredItem-text">${nextRollAddress}) ${originalG9Content.trim()}</span></a>`;
            } else {
                newG9Display = `<a ${tenPullLinkHref} class="re-gacha-cell">${nextRollAddress}) ${originalG9Content.trim()}</a>`;
            }
        }
        tenPullResults[9] = newG9Display;

        const expectedEyebollsArray = []; // G列の11行目以降に表示する、単発N回後の10連での目玉期待数
        const numberArray = []; // (未使用) デバッグ用の情報配列
        for (let start = 1; start <= 10; start++) { // 単発1回後〜10回後までループ
            expectedEyebollsArray[start] = 0; // 期待値を初期化
            numberArray.push("<br>単発" + (start) + "ロール後(seed" + (path[start]) + "～)の(目玉出現枠)及び個数:<br>");
            for(let i = 0; i < 10; i++){
                if(path[start] + i >= path.length) break;
                if(moduloArray[path[start] + i] < gacha.featuredItemRate){
                    expectedEyebollsArray[start]++;
                    numberArray.push(" " + moduloArray[path[start] + i] + "■");
                } else {
                    numberArray.push(" " + moduloArray[path[start] + i]);
                }
            }

            if(start <= firstGuaranteedRolls && firstGuaranteedRolls < start + 10){ // その10連に確定枠が含まれる場合
                expectedEyebollsArray[start] = expectedEyebollsArray[start] + 1; // 期待値を+1
                numberArray.push((firstGuaranteedRolls - start) + "ロール目(確定枠)■");
                if(moduloArray[path[10]] < gacha.featuredItemRate){ // もし確定枠がなくても目玉だった場合、二重カウントを防ぐために-1
                    expectedEyebollsArray[start] = expectedEyebollsArray[start]  - 1;
                }
            }
            
            numberArray.push(" / " + expectedEyebollsArray[start] + "個<br>");
        }
        
        //const confirmationString = `Seed: ${seedValue} | ガチャID: ${selectedGachaId} | 確定枠: ${firstGuaranteedRolls}回目${numberArray}`;
        //output.innerHTML = confirmationString;

        createAndDisplayTable(items, rarities, isfeaturedItemCell, path, tenPullResults, reGachaItems, selectedGachaId, expectedEyebollsArray, firstGuaranteedRolls); // テーブルを生成して表示
    
        // URLのクエリパラメータを更新
        const newUrl = `${window.location.protocol}//${window.location.host}${window.location.pathname}?seed=${seedValue}&ng=${guaranteedRollsInput.value}&fs=${featuredStockInput.value}`; // 新しいURLを生成
        window.history.replaceState({ path: newUrl }, '', newUrl); // ブラウザの履歴を追加せずにURLを更新
    }

    function toggleReGachaMode() {
        forceReGachaMode = !forceReGachaMode;
        runSimulationAndDisplay();
    }

    function createAndDisplayTable(items, rarities, isfeaturedItemCell, path, tenPullRows, reGachaItems, gachaId, expectedEyebollsArray, currentGuaranteedRolls) { // 結果をテーブルとして描画する関数
        let table = '<table><thead><tr><th class="row-number-header">❐</th><th>A</th><th>B</th><th>C</th><th>G</th></tr></thead><tbody>'; // テーブルのヘッダー部分
        const pathSet = new Set(path); // 経路の検索を高速化するためにSetに変換

        // テーブルの各行を生成
        for (let r = 0; r < 100; r++) {
            table += `<tr><td>${r + 1}</td>`;
            for (let c = 0; c < 3; c++) {
                const index = r * 3 + c;
                if (index >= items.length) break;
                let classList = ['re-gacha-cell'];
                let cellContent = "---";
                
                if (pathSet.has(index)) {
                    classList.push('path-cell'); // 経路上のセルは背景色を変更
                    const pathPosition = path.indexOf(index) + 1; // 経路上の何番目かを取得
                    let nextGuaranteed = currentGuaranteedRolls - pathPosition; // 次の確定枠までの残り回数を計算
                    if (nextGuaranteed <= 0) { // 0以下になったら30を足す
                        nextGuaranteed += 30;
                    }

                    if (isfeaturedItemCell[index]) {
                        const nextRollRow = Math.floor((index + 1) / 3) + 1;
                        const nextRollCol = String.fromCharCode('A'.charCodeAt(0) + ((index + 1) % 3));
                        const nextRollAddress = `${nextRollCol}${nextRollRow}`;
                        cellContent = `<a href="?seed=${xorshiftArray[index]}&ng=${nextGuaranteed}" class="featuredItem-text">${nextRollAddress})目玉</a>`; // 目玉アイテムの表示と次のシードへのリンク
                    } else if (reGachaItems[index] !== "---") {
                        const nextIndex = index + 4;
                        const nextRollRow = Math.floor((nextIndex) / 3) + 1;
                        const nextRollCol = String.fromCharCode('A'.charCodeAt(0) + (nextIndex % 3));
                        const nextRollAddress = `${nextRollCol}${nextRollRow}`;

                        let reGachaItemName = reGachaItems[index];
                        // const reGachaItemId = itemNameMap[reGachaItemName]; // この行は直接使われていないため不要
                        cellContent = `${itemMaster[items[index]].name} <!-- 元のアイテム -->
                        <br><a href="?seed=${xorshiftArray[index + 3]}&ng=${nextGuaranteed}">${nextRollAddress})${reGachaItemName}</a>`; // 再抽選アイテム
                    } else {
                        const nextIndex = index + 3;
                        const nextGuaranteed = currentGuaranteedRolls - pathPosition;
                        const correctedGuaranteed = nextGuaranteed <= 0 ? nextGuaranteed + 30 : nextGuaranteed;
                        cellContent = itemMaster[items[index]] ? `<a href="?seed=${xorshiftArray[index + 2]}&ng=${correctedGuaranteed}">${itemMaster[items[index]].name}</a>` : '---';
                        const rarityId = items[index] in itemMaster ? itemMaster[items[index]].rarity : -1;
                        if (rarityId === 3) {
                            cellContent = `<span class="featuredItem-text">${cellContent}</span>`;
                        }
                    }
                } else {
                    // Pathに該当しない場合、ngクエリパラメータを付けずにリンクを生成
                    if (isfeaturedItemCell[index]) {
                        const nextRollRow = Math.floor((index + 1) / 3) + 1;
                        const nextRollCol = String.fromCharCode('A'.charCodeAt(0) + ((index + 1) % 3));
                        const nextRollAddress = `${nextRollCol}${nextRollRow}`;
                        cellContent = `<a href="?seed=${xorshiftArray[index]}" class="featuredItem-text">${nextRollAddress})目玉</a>`;
                    } else if (reGachaItems[index] !== "---") {
                        const nextIndex = index + 4;
                        const nextRollRow = Math.floor((nextIndex) / 3) + 1;
                        const nextRollCol = String.fromCharCode('A'.charCodeAt(0) + (nextIndex % 3));
                        const nextRollAddress = `${nextRollCol}${nextRollRow}`;

                        let reGachaItemName = reGachaItems[index];
                        // const reGachaItemId = itemNameMap[reGachaItemName]; // この行は直接使われていないため不要
                        cellContent = `${itemMaster[items[index]].name}
                        <br><a href="?seed=${xorshiftArray[index + 3]}">${nextRollAddress})${reGachaItemName}</a>`;
                    } else {
                        const nextIndex = index + 3;
                        cellContent = itemMaster[items[index]] ? `<a href="?seed=${xorshiftArray[index + 2]}">${itemMaster[items[index]].name}</a>` : '---';
                        const rarityId = items[index] in itemMaster ? itemMaster[items[index]].rarity : -1;
                        if (rarityId === 3) {
                            cellContent = `<span class="featuredItem-text">${cellContent}</span>`;
                        }
                    }
                }


                table += `<td class="${classList.join(' ')}">${cellContent}</td>`;
            }
            
            // G列の処理
            let gCellClass = 're-gacha-cell'; // G列の基本クラス
            let gCellContent = ''; // G列の表示内容
            if (r < 10) { // 1〜10行目：10連ガチャの結果
                gCellClass += ' g-ten-pull-highlight'; // ハイライト用のクラスを追加
                gCellContent = tenPullRows[r] || '';
                
                if (gCellContent && gCellContent.includes('目玉')) {
                    gCellContent = `<span class="featuredItem-text">${gCellContent}</span>`;
                } else if (gCellContent) {
                    const extractedItemName = gCellContent;
                    const extractedItemId = itemNameMap[extractedItemName];
                    if (extractedItemId !== undefined) {
                        const rarityId = extractedItemId in itemMaster ? itemMaster[extractedItemId].rarity : -1;
                        if (rarityId === 3) {
                            gCellContent = `<span class="featuredItem-text">${gCellContent}</span>`;
                        }
                    }
                }
            } else if (r >= 10 && r < 20) { // 11〜20行目：単発N回後の目玉期待数
                gCellContent = expectedEyebollsArray[r - 9] // 計算した期待値を表示
            } else {
                gCellContent = '';
            }

            table += `<td class="${gCellClass}">${gCellContent}</td>`;
            table += '</tr>';
        }
        
        table += '</tbody></table>';
        resultTableContainer.innerHTML = table; // 生成したテーブルをHTMLに挿入

        // 再抽選モード切り替えボタンの表示とイベント設定
        const rowHeaderCell = document.querySelector('th.row-number-header'); // ヘッダーのセルを取得
        rowHeaderCell.textContent = forceReGachaMode ? '☑' : '❐'; // モードに応じてアイコンを変更
        rowHeaderCell.addEventListener('click', toggleReGachaMode); // クリックでモードを切り替えるイベントを追加
    }

    runSimulationAndDisplay(); // ページ読み込み時に初回実行
</script>
</body>
</html>
