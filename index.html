<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>イベントガチャロールズ</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.2;
            padding: 5px;
            max-width: 1200px;
            margin: 0 auto;
            background-color: #f4f7f9;
            color: #333;
            font-size: 9px;
        }
        .container {
            background: #fff;
            padding: 5px;
            border-radius: 12px;
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.1);
        }
        h1 {
            color: #004085;
            font-size: 0.9rem;
            border-bottom: 1px solid #e9ecef;
            padding-bottom: 3px;
            margin-top: 0;
            text-align: center;
        }
        .controls {
            display: flex;
            flex-direction: column;
            gap: 5px;
            margin-bottom: 10px;
            padding: 4px;
            background-color: #f9fbfd;
            border-radius: 4px;
        }
        .row {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
            gap: 5px;
            align-items: center;
        }
        .control-group-left, .control-group-right {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        .input-item {
            flex: 0 1 auto;
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 3px;
        }
        .input-item-display-only {
            flex: 0 1 auto;
            display: flex;
            align-items: center;
            font-size: 0.7rem;
            color: #555;
            padding: 0 5px;
        }
        .input-item-seed {
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 3px;
        }
        .seed-input-group {
            display: flex;
            align-items: center;
            gap: 5px;
            flex: 1 1 200px;
        }
        label {
            font-weight: 600;
            color: #555;
        }
        input[type="number"],
        select {
            padding: 3px;
            border: 1px solid #ccc;
            border-radius: 3px;
            font-size: 0.8rem;
            width: 100%;
            box-sizing: border-box;
            transition: border-color 0.3s;
        }
        input[type="number"]:focus,
        select:focus {
            outline: none;
            border-color: #007bff;
        }
        button {
            flex-shrink: 0;
            width: auto;
            padding: 5px 10px;
            background-color: #007bff;
            color: #fff;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.8rem;
            font-weight: bold;
            transition: background-color 0.3s ease, transform 0.2s ease;
        }
        .hidden-control {
            display: none !important;
        }
        #showSeedInputLink {
            color: #007bff;
            text-decoration: underline;
            cursor: pointer;
            padding: 0 5px;
            font-weight: bold;
        }
        #copySeedLink {
            color: #007bff;
            text-decoration: underline;
            cursor: pointer;
            white-space: nowrap;
        }

        button:hover {
            background-color: #0056b3;
            transform: translateY(-2px);
        }
        #result-container {
            margin-top: 15px;
        }
        #result-table-container {
            overflow-x: auto;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
        }
        table {
            width: 100%;
            border-collapse: collapse;
        }
        th, td {
            padding: 3px;
            text-align: center;
            border: 1px solid #e0e0e0;
            word-break: break-word;
            font-size: 0.8rem;
            min-width: 25px;
        }
        th {
            background-color: #f0f4f7;
            color: #444;
            font-weight: 600;
            position: sticky;
            top: 0;
            z-index: 1;
        }
        thead th:first-child {
            z-index: 2;
        }
        td {
            background-color: #fff;
        }
        .row-number-header {
            font-family: Arial, sans-serif;
            font-weight: bold;
            width: 25px;
            cursor: pointer;
        }
        .col-no {
            width: 25px;
        }
        
        /* アイテム装飾 */
        .featuredItem-text {
            color: #d9534f; /* 赤 */
            font-weight: bold;
        }
        .legendItem-text {
            color: #0000ff; /* 青 */
            font-weight: bold;
        }

        #result-table-container td a {
            color: inherit;
            text-decoration: none;
        }

        /* 凡例 */
        .legend-box {
            padding: 2px 5px;
            border-radius: 3px;
            margin-left: 5px;
            cursor: pointer;
            border: 1px solid transparent;
        }
        .legend-box:hover {
            border: 1px solid #999;
        }
        .legend-single { background-color: #e0f7ff; }
        .legend-multi { background-color: #ffffe0; }
        .legend-common { background-color: #dfffb0; }

        /* ハイライト用CSS (通常) */
        .highlight-roll { background-color: #e0f7ff !important; } /* 単発 (青) */
        .highlight-roll-10pull { background-color: #ffffe0 !important; } /* 10連 (黄) */
        .highlight-roll-overlap { background-color: #dfffb0 !important; } /* 重複 (緑) */

        /* ハイライト用CSS (10ロールごとの鮮やかな色) */
        .highlight-roll-dark { background-color: #80d8ff !important; } /* 鮮やかな青 (Light Blue A100) */
        .highlight-roll-10pull-dark { background-color: #ffff8d !important; } /* 鮮やかな黄 (Yellow A100) */
        .highlight-roll-overlap-dark { background-color: #b9f6ca !important; } /* 鮮やかな緑 (Green A100) */

        /* モード別表示用 */
        /* Single Mode */
        .mode-single .highlight-roll { background-color: #e0f7ff !important; }
        .mode-single .highlight-roll-dark { background-color: #80d8ff !important; }
        .mode-single .highlight-roll-overlap { background-color: #e0f7ff !important; } 
        .mode-single .highlight-roll-overlap-dark { background-color: #80d8ff !important; }
        
        .mode-single .highlight-roll-10pull,
        .mode-single .highlight-roll-10pull-dark { background-color: #fff !important; }

        /* Multi Mode */
        .mode-multi .highlight-roll-10pull { background-color: #ffffe0 !important; }
        .mode-multi .highlight-roll-10pull-dark { background-color: #ffff8d !important; }
        .mode-multi .highlight-roll-overlap { background-color: #ffffe0 !important; }
        .mode-multi .highlight-roll-overlap-dark { background-color: #ffff8d !important; }

        .mode-multi .highlight-roll,
        .mode-multi .highlight-roll-dark { background-color: #fff !important; }
        
        #calculation-details {
            font-family: monospace;
            font-size: 11px;
            line-height: 1.4;
            margin-top: 15px;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
            background: #f9f9f9;
        }
        #calculation-details h2 {
            font-size: 1.1rem;
            margin-top: 20px;
            margin-bottom: 5px;
            border-bottom: 1px solid #ccc;
            padding-bottom: 3px;
        }
        #toggleDetailsBtn {
            background-color: #6c757d;
        }
        #toggleDetailsBtn:hover {
            background-color: #5a6268;
        }
        #details-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
        }
        .scroll-buttons {
            display: flex;
            gap: 10px;
        }
        .scroll-buttons button {
            font-size: 0.75rem;
            background-color: #28a745;
        }
        .scroll-buttons button:hover {
            background-color: #218838;
        }
    </style>
</head>
<body>

<div class="container">
    <h1>イベントガチャロールズ</h1>
    <div class="input-group">
        <div class="controls">
            <div class="row">
                <div class="control-group-left">
                    <div class="input-item">
                         <a id="showSeedInputLink" href="#">SEED入力</a>
                    </div>
                    <div class="input-item" id="guaranteedControl">
                        <label for="guaranteedRollsInput">next guaranteed</label>
                        <select id="guaranteedRollsInput"></select>
                    </div>
                    <div class="input-item" id="legendDisplay" style="font-size: 0.7rem;">
                        <span id="legendSingle" class="legend-box legend-single">単発ルート</span>
                        <span id="legendMulti" class="legend-box legend-multi">10連ルート</span>
                        <span id="legendCommon" class="legend-box legend-common">共通ルート</span>
                    </div>
                    <div id="lastRollDisplay" class="input-item-display-only">
                        </div>
                </div>
                <div class="control-group-right">
                    <div class="input-item">
                        <label for="featuredCompleteCheckbox">コンプ済み</label>
                        <input type="checkbox" id="featuredCompleteCheckbox">
                    </div>
                    <div class="input-item" id="stockControl">
                        <label for="featuredStockInput">目玉残数</label>
                        <select id="featuredStockInput"></select>
                    </div>
                    <a id="copySeedLink" href="#">Copy SEED</a>
                </div>
            </div>
            <div class="row hidden-control" id="seedRow">
                <div class="input-item-seed">
                    <label for="seedInput">SEED</label>
                    <div class="seed-input-group">
                        <input type="number" id="seedInput" value="123456789">
                        <button id="executeButton">更新</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div id="result-container">
        <div id="output"></div>
        <div id="result-table-container"></div>
        <div id="details-controls" style="display: none; margin-top: 10px; align-items: center; gap: 10px;">
            <button id="toggleDetailsBtn">計算過程を表示</button>
            <div class="scroll-buttons" style="display: none;">
                <button id="scrollToSingle">単発ルートへ</button>
                <button id="scrollToMulti">10連ルートへ</button>
            </div>
        </div>
        <div id="calculation-details" style="display:none;"></div>
    </div>
</div>

<script>
    // --- マスターデータ ---
    const gachaMaster = {
        '34': { name: '(旧)ハロウィン', featuredItemRate: 600, featuredItemStock: 5, guaranteedCycle: 30, uberGuaranteedFlag: false, legendGuaranteedFlag: false, rarityRates: { '0': 2000, '1': 5000, '2': 3000, '3': 0, '4': 0 }, pool: [0, 2, 3, 4, 5, 10, 11, 12, 14] },
        '42': { name: '1.1億DL記念', featuredItemRate: 500, featuredItemStock: 5, guaranteedCycle: 30, uberGuaranteedFlag: false, legendGuaranteedFlag: false, rarityRates: { '0': 1000, '1': 5000, '2': 3000, '3': 1000, '4': 0 }, pool: [0, 2, 3, 4, 5, 10, 11, 12, 14, 375, 381, 689] },
        '44': { name: 'ハロウィン', featuredItemRate: 500, featuredItemStock: 8, guaranteedCycle: 30, uberGuaranteedFlag: false, legendGuaranteedFlag: false, rarityRates: { '0': 2000, '1': 4900, '2': 3000, '3': 0, '4': 100 }, pool: [0, 2, 3, 4, 5, 10, 11, 12, 14, 18] },
        '45': { name: 'にゃんこレンジャー', featuredItemRate: 0, featuredItemStock: 0, guaranteedCycle: 10, uberGuaranteedFlag: true, legendGuaranteedFlag: false, rarityRates: { '0': 0, '1': 7000, '2': 2300, '3': 500, '4': 200 }, pool: [0,2,3,4,5,11,12,14,197,184,375,726,831] }
    };
    const itemMaster = {
        0: { name: "スピダ", rarity: 1 }, 2: { name: "ネコボン", rarity: 2 }, 3: { name: "ニャンピュ", rarity: 1 }, 4: { name: "おかめ", rarity: 2 }, 5: { name: "スニャ", rarity: 2 },
        10: { name: "5千XP", rarity: 0 }, 11: { name: "1万XP", rarity: 1 }, 12: { name: "3万XP", rarity: 1 }, 14: { name: "10万XP", rarity: 2 }, 18: { name: "200万XP", rarity: 4 },
        197: { name: "100万XP", rarity: 4 }, 184: { name: "ミスターニンジャ", rarity: 3 }, 375: { name: "記念ネコ", rarity: 3 }, 381: { name: "ねこ農家", rarity: 3 },
        689: { name: "石の上にも10年ネコ", rarity: 3 }, 726: { name: "ネコメダル王", rarity: 3 }, 831: { name: "スカーフにゃんこ", rarity: 3 }
    };

    const DEFAULT_PARAMS = {
        gacha: '45',
        seed: '123456789',
        ng: 'none',
        fs: 'none',
        lr: null,
        comp: false,
        tx: false,
        roll: 100,
        displaySeed: '0'
    };

    // ハイライト状態管理
    let currentHighlightMode = 'all'; // 'all', 'single', 'multi'

    function generateUrlQuery(p) {
        const query = new URLSearchParams();
        for (const key in p) {
            if (key === 'displaySeed' && p[key] === DEFAULT_PARAMS.displaySeed) continue;
            if (p[key] !== null && p[key] !== undefined) query.set(key, p[key]);
        }
        return '?' + query.toString();
    }
    
    function xorshift32(seed) {
        let x = seed;
        x ^= x << 13; x ^= x >>> 17; x ^= x << 15;
        return x >>> 0;
    }
    function setupGachaRarityItems() {
        for (const gachaId in gachaMaster) {
            const gacha = gachaMaster[gachaId];
            if (gacha && gacha.pool) {
                gacha.rarityItems = { '0': [], '1': [], '2': [], '3': [], '4': [] };
                for (const itemId of gacha.pool) {
                    const item = itemMaster[itemId];
                    if (item && gacha.rarityItems[item.rarity] !== undefined) {
                        gacha.rarityItems[item.rarity].push(itemId);
                    }
                }
                for (const rarity in gacha.rarityItems) gacha.rarityItems[rarity].sort((a, b) => a - b);
            }
        }
    }

    function generateMasterInfoHtml(gacha) {
        let html = `<h2>＜マスター情報＞</h2>`;
        html += `(ガチャ) ${gacha.name}(ID:${activeGachaId})<br>`;
        html += `(目玉) ${gacha.featuredItemRate > 0}(レート:${gacha.featuredItemRate}, 初期残数:${gacha.featuredItemStock})<br>`;
        html += `(確定) 超激:${gacha.uberGuaranteedFlag}, 伝説:${gacha.legendGuaranteedFlag}<br>`;
        
        const r = gacha.rarityRates;
        const r0 = r['0'];
        const t1 = r0;
        const t2 = r0 + r['1'];
        const t3 = t2 + r['2'];
        const t4 = t3 + r['3'];
        
        let rateStr = `(レート) `;
        if (r0 === 0) rateStr += `0(ノーマル)-, `;
        else rateStr += `0(ノーマル)～${t1-1}, `;
        
        rateStr += `1(レア)～${t2-1}, `;
        rateStr += `2(激レア)～${t3-1}, `;
        rateStr += `3(超激レア)～${t4-1}, `;
        rateStr += `4(伝説レア)～9999`;
        html += rateStr + `<br>`;
        
        html += `(各レアリティ別アイテム)<br>`;
        const rarities = ['ノーマル', 'レア', '激レア', '超激レア', '伝説レア'];
        for (let i = 0; i <= 4; i++) {
            const pool = gacha.rarityItems[i.toString()];
            if (pool && pool.length > 0) {
                const itemsStr = pool.map(id => `${itemMaster[id].name}(ID:${id})`).join(', ');
                html += `${rarities[i]}(${pool.length} item) ${itemsStr}<br>`;
            }
        }
        return html + '<br>';
    }
    
    function getFormattedItemComparison(nodeItemName, nodeItemId, nodeRarityId, prevItemId, comparisonTargetName) {
        const rComp = (nodeRarityId === 1) ? '1=1' : `${nodeRarityId}≠1`;
        let idComp = '';
        let targetDisplay = '';

        if (comparisonTargetName) {
             targetDisplay = comparisonTargetName;
        } else {
             targetDisplay = (prevItemId === -1) ? 'Null' : `${prevItemId}`;
        }

        if (prevItemId === -1) {
             idComp = (nodeItemId === -1) ? '=Null' : '≠Null'; 
        } else {
             idComp = (nodeItemId === prevItemId) ? `=${targetDisplay}` : `≠${targetDisplay}`;
        }
        
        const isDupe = (nodeRarityId === 1 && nodeItemId !== -1 && nodeItemId === prevItemId);
        
        const text = `${nodeItemName}(${nodeItemId}(${rComp})${idComp})`;
        return { text, isDupe };
    }

    function createAndDisplayCompletedSeedView(initialSeed, gacha, tableRows, thresholds, initialLastRollId, displaySeed, params, initialNg) {
        const SEED = [initialSeed];
        const maxSeedsNeeded = tableRows * 4 * 2 + 1000; 
        for (let i = 1; i < maxSeedsNeeded; i++) {
            SEED[i] = xorshift32(SEED[i - 1]);
        }

        const getRarityFromRoll = (roll) => {
            if (roll < thresholds['0']) return { id: 0, name: 'ノーマル' };
            if (roll < thresholds['1']) return { id: 1, name: 'レア' };
            if (roll < thresholds['2']) return { id: 2, name: '激レア' };
            if (roll < thresholds['3']) return { id: 3, name: '超激レア' };
            return { id: 4, name: '伝説レア' };
        };
        
        const thArr = [
            thresholds['0'] === 0 ? '-' : thresholds['0']-1,
            thresholds['1']-1,
            thresholds['2']-1,
            thresholds['3']-1,
            9999
        ];
        const thresholdStr = `{${thArr.join(',')}}`;

        const getAddressString = (n) => {
            if (n <= 0) return '';
            const zeroBasedIndex = n - 1;
            const col_char = String.fromCharCode('A'.charCodeAt(0) + (zeroBasedIndex % 2));
            const row_num = Math.floor(zeroBasedIndex / 2) + 1;
            return `${row_num}${col_char}`;
        };
        
        const formatItem = (id) => {
            if (id === -1) return '---';
            const item = itemMaster[id];
            return `${item.name}(${id}(${item.rarity}))`;
        };

        const Nodes = [];
        const maxNodeIndex = tableRows * 2 + 100;
        
        let detailsHtml = generateMasterInfoHtml(gacha);
        detailsHtml += '<h2>＜ノード計算詳細 (No.1～)＞</h2>';
        detailsHtml += '<p style="margin-top: -10px; font-size: 10px;">（このデータは、特定のSEED INDEXからの計算結果を示します。実際のルートではレア被りにより消費SEED数が異なります）</p>';
        
        let lastRollText = 'Null';
        if (initialLastRollId && itemMaster[initialLastRollId]) {
            lastRollText = `${itemMaster[initialLastRollId].name}(${initialLastRollId}(${itemMaster[initialLastRollId].rarity}))`;
        }
        detailsHtml += `ＬａｓｔＲｏｌｌ：${lastRollText}<br><br>`;

        for (let i = 1; i <= maxNodeIndex; i++) {
            const node = {
                index: i,
                address: getAddressString(i),
                seed1: SEED[i],
                seed2: SEED[i+1],
                seed3: SEED[i+2]
            };

            const roll1 = node.seed1 % 10000;
            node.rarity = getRarityFromRoll(roll1);
            node.rarityId = node.rarity.id;

            const uberRate = gacha.uberGuaranteedFlag ? (gacha.rarityRates['3'] || 0) : 0;
            const legendRate = gacha.legendGuaranteedFlag ? (gacha.rarityRates['4'] || 0) : 0;
            const gDivisor = uberRate + legendRate;
            if (gDivisor > 0) {
                const gRoll = node.seed1 % gDivisor;
                node.rarityGId = (gRoll < uberRate) ? '3' : '4';
                node.rarityGName = (node.rarityGId === '3') ? '超激レア' : '伝説レア';
                node.gRoll = gRoll; node.gDivisor = gDivisor;
            } else {
                node.rarityGId = null; node.rarityGName = '-'; node.gRoll = 0; node.gDivisor = 0;
            }

            const pool = gacha.rarityItems[node.rarityId] || [];
            node.poolSize = pool.length;
            if (pool.length > 0) {
                node.slot = node.seed2 % pool.length;
                node.itemId = pool[node.slot];
                node.itemName = itemMaster[node.itemId]?.name || '---';
            } else {
                node.slot = 0; node.itemId = -1; node.itemName = '---';
            }

            const poolG = node.rarityGId ? (gacha.rarityItems[node.rarityGId] || []) : [];
            node.poolGSize = poolG.length;
            if (poolG.length > 0) {
                node.slotG = node.seed2 % poolG.length;
                node.itemGId = poolG[node.slotG];
                node.itemGName = itemMaster[node.itemGId]?.name || '---';
            } else {
                node.slotG = 0; node.itemGId = -1; node.itemGName = '---';
            }

            const prevNode = (i > 2) ? Nodes[i - 3] : null;
            const isRare = (node.rarityId === 1);
            const prevItemId = prevNode ? prevNode.itemId : -1;
            node.reRollFlag = isRare && (pool.length > 1) && (node.itemId !== -1) && (node.itemId === prevItemId);
            node.useSeeds = node.reRollFlag ? 3 : 2;

            if (isRare && pool.length > 1) {
                 const reRollPool = pool.filter(id => id !== node.itemId);
                 if (reRollPool.length > 0) {
                     node.reRollSlot = node.seed3 % reRollPool.length;
                     node.reRollItemId = reRollPool[node.reRollSlot];
                     node.reRollItemName = itemMaster[node.reRollItemId]?.name || '---';
                 } else {
                     node.reRollItemId = -1; node.reRollItemName = '---';
                 }
                 const nextIdxRe = i + 3;
                 node.reRollNextAddress = getAddressString(nextIdxRe);
            } else {
                 node.reRollItemId = -1; node.reRollItemName = '---';
                 node.reRollNextAddress = '-';
            }
            
            Nodes.push(node);

            let lines = [];
            lines.push(`(番地) ${node.index}(${node.address})`);
            lines.push(`(レアリティ) (S1(${node.seed1})%10000(=${node.seed1%10000})<=${thresholdStr})=${node.rarityId}(${node.rarity.name})`);
            
            if (gacha.uberGuaranteedFlag && gacha.legendGuaranteedFlag) {
                let gThStr = `{${uberRate},-}`;
                lines.push(`(レアリティ(確定)) (S1(${node.seed1})%${node.gDivisor}(=${node.gRoll})<=${gThStr})=${node.rarityGId}(${node.rarityGName})`);
            }
            
            let prevIdForDetail = -1;
            let compTargetName = "Null";
            if (i <= 2) {
                if (initialLastRollId) {
                    prevIdForDetail = initialLastRollId;
                    compTargetName = `LastRoll(${initialLastRollId})`;
                }
            } else {
                const pNode = Nodes[i-3];
                prevIdForDetail = pNode.itemId;
                compTargetName = `Item[${pNode.index}]${pNode.itemId}`;
            }

            const fmt = getFormattedItemComparison(node.itemName, node.itemId, node.rarityId, prevIdForDetail, compTargetName);

            // --- 連続レア被り(ReRollItemとの比較)チェック ---
            let additionalInfo = '';
            let isConsecutiveDupe = false;

            // 3SEED前のノード（ReRollルート元）が存在するか確認
            if (i > 3) {
                const pNodeRe = Nodes[i-4]; // i-4 index matches No.(i-3)
                // 条件: 
                // 1. 現在がレア (暗黙的だが、重複チェックは通常レアのみ)
                // 2. 元ノードが実際にレア被り(ReRoll)を起こしていた (pNodeRe.reRollFlag === true)
                // 3. 現在のアイテムIDが、元ノードの再抽選アイテムと一致
                if (node.rarityId === 1 && pNodeRe.reRollFlag && node.itemId === pNodeRe.reRollItemId) {
                     additionalInfo = `,= ReRollItem[${pNodeRe.index}]${pNodeRe.reRollItemId}`;
                     isConsecutiveDupe = true;
                }
            }
            
            let displayedText = fmt.text;
            if (additionalInfo) {
                // fmt.textは末尾が ')' で終わる形式なので、その内側に追記
                if (displayedText.endsWith(')')) {
                    displayedText = displayedText.slice(0, -1) + additionalInfo + ')';
                } else {
                    displayedText += additionalInfo;
                }
            }

            let suffix = '';
            if (fmt.isDupe) {
                suffix = 'レア被り';
            } else if (isConsecutiveDupe) {
                suffix = ' 連続レア被り';
            }

            lines.push(`(スロット,アイテム) S2(${node.seed2})%${node.poolSize}=${node.slot}, Item[${node.index}]=${displayedText}${suffix}`);
            
            if (node.rarityGId) {
                lines.push(`(スロット,アイテム(確定)) S2(${node.seed2})%${node.poolGSize}=${node.slotG}, ItemG[${node.index}]=${formatItem(node.itemGId)}`);
            }
            
            if (node.reRollItemId !== -1) {
                 const poolSizeRe = pool.length - 1;
                 const nextIdx = node.index + 3;
                 lines.push(`(スロット,アイテム,遷移先(再抽選)) S3(${node.seed3})%${poolSizeRe}=${node.reRollSlot}, ReRollItem[${node.index}]=${formatItem(node.reRollItemId)}, ${node.index}+3=${nextIdx}(${node.reRollNextAddress})`);
            }
            detailsHtml += `<strong>No.${node.index}</strong><br>` + lines.join('<br>') + '<br><br>';
        }

        const highlightInfo = new Map(); 

        let singleRouteLog = '<h2>＜単発ルート＞</h2>';
        singleRouteLog += `(LastRoll=${lastRollText})<br>`;

        let sIdx = 1;
        let sLastItemId = initialLastRollId || -1;
        const ngVal = parseInt(initialNg, 10);
        const hasGuaranteed = !isNaN(ngVal);
        let prevSingleIdx = -1;
        let prevSingleCons = 0;

        for (let roll = 1; roll <= tableRows; roll++) {
            if (sIdx > maxNodeIndex) break;
            const node = Nodes[sIdx - 1];
            const isGuaranteedRoll = hasGuaranteed && (gacha.uberGuaranteedFlag || gacha.legendGuaranteedFlag) && (roll >= ngVal) && ((roll - ngVal) % 10 === 0);
            
            let addrStr = `${sIdx}(${node.address})`;
            if (roll > 1 && prevSingleIdx !== -1) {
                 addrStr = `${prevSingleIdx}+${prevSingleCons}=${sIdx}(${node.address})`;
            }

            if (isGuaranteedRoll) {
                const addressKey = node.address + 'G';
                let gAddrStr = `${sIdx}(${addressKey})`; 
                 if (roll > 1 && prevSingleIdx !== -1) {
                     gAddrStr = `${prevSingleIdx}+${prevSingleCons}=${sIdx}(${addressKey})`;
                }
                
                const itemGRarity = itemMaster[node.itemGId]?.rarity;
                const itemGName = itemMaster[node.itemGId]?.name;
                let targetStr = (sLastItemId === -1) ? "Null" : `${sLastItemId}`;
                if (roll === 1 && initialLastRollId) targetStr = `LastRoll(${initialLastRollId})`;

                const fmtG = getFormattedItemComparison(itemGName, node.itemGId, itemGRarity, sLastItemId, targetStr);
                
                singleRouteLog += `Roll${roll} guaranteed (番地) ${gAddrStr}／ItemG[${sIdx}]=${fmtG.text}${fmtG.isDupe ? 'レア被り' : ''}(2seed消費)<br>`;

                const info = highlightInfo.get(addressKey) || {};
                info.single = true;
                info.singleRoll = roll; // Roll count storage
                highlightInfo.set(addressKey, info);
                
                prevSingleIdx = sIdx;
                prevSingleCons = 2;
                sLastItemId = node.itemGId;
                sIdx += 2; 
            } else {
                const isRare = (node.rarityId === 1);
                const poolSize = gacha.rarityItems[1] ? gacha.rarityItems[1].length : 0;
                const isMatch = (node.itemId !== -1 && node.itemId === sLastItemId);
                const reRollFlag = isRare && isMatch && poolSize > 1;
                
                let targetStr = (sLastItemId === -1) ? "Null" : `${sLastItemId}`;
                if (roll === 1 && initialLastRollId) targetStr = `LastRoll(${initialLastRollId})`;

                const fmt = getFormattedItemComparison(node.itemName, node.itemId, node.rarityId, sLastItemId, targetStr);
                let line = `Roll${roll} (番地) ${addrStr}／Item[${sIdx}]=${fmt.text}${fmt.isDupe ? 'レア被り' : ''}`;
                
                const useSeeds = reRollFlag ? 3 : 2;
                
                let finalId = node.itemId;
                
                if (reRollFlag) {
                    const nextIdxRe = sIdx + useSeeds;
                    const nextAddrRe = getAddressString(nextIdxRe);
                    line += `／(再抽選)${sIdx}+3=${nextIdxRe}(${nextAddrRe}),ReRollItem[${sIdx}]=${node.reRollItemName}(${node.reRollItemId}(1))`;
                    finalId = node.reRollItemId;
                }
                line += `(${useSeeds}seed消費)`;

                singleRouteLog += line + '<br>';

                const info = highlightInfo.get(node.address) || {};
                info.single = true;
                info.singleRoll = roll; // Roll count storage
                info.s_reRoll = reRollFlag;
                if (reRollFlag) {
                    info.s_normalName = node.itemName;
                    info.s_reRollName = node.reRollItemName;
                    info.s_nextAddr = getAddressString(sIdx + useSeeds);
                }
                highlightInfo.set(node.address, info);

                prevSingleIdx = sIdx;
                prevSingleCons = useSeeds;
                sLastItemId = finalId;
                sIdx += useSeeds;
            }
        }

        let tenPullRouteLog = '';
        if (hasGuaranteed) {
            tenPullRouteLog += '<h2>＜10連ルート＞</h2>';
            tenPullRouteLog += '確定があるガチャでは、各サイクルの最初の1seedを消費し確定枠のレアリティ判定を先に行い、確定枠では残りのスロット判定のみを1seed消費して行います<br>確定枠の番地については、直前までは確定枠のレアリティ判定1seed分既に進んでいるので-1調整し、次のRollは調整後の番地から2seed先で計算しています<br><br>';

            let tIdx = 1;
            let tLastItemId = initialLastRollId || -1;
            let prevTenIdx = -1;
            let prevTenCons = 0;

            for (let roll = 1; roll <= tableRows; roll++) {
                if (tIdx > maxNodeIndex) break;
                
                const isCycleStart = (roll - 1) % 10 === 0;
                if (isCycleStart) {
                    const nodeG = Nodes[tIdx - 1];
                    const cycleNum = Math.floor((roll - 1) / 10) + 1;
                    
                    let cycleHeader = `<strong>${cycleNum}サイクル目</strong><br>`;
                    if (roll > 1) {
                         if (prevTenIdx !== -1) {
                             const currentDisplayIdx = prevTenIdx + prevTenCons;
                             cycleHeader = `<strong>${cycleNum}サイクル目</strong><br>${prevTenIdx}+${prevTenCons}＝${currentDisplayIdx}／`;
                         }
                    }
                    cycleHeader += `rarityG[${tIdx}]=${nodeG.rarityGId}(${nodeG.rarityGName})(1seed消費)<br>`;
                    if (roll === 1) cycleHeader += `(LastRoll=${lastRollText})<br>`;
                    
                    tenPullRouteLog += cycleHeader;
                    
                    tIdx++; 
                    if (roll === 1) {
                        prevTenIdx = 1; 
                        prevTenCons = 1;
                    } else {
                        prevTenIdx = -1;
                    }
                }
                
                const node = Nodes[tIdx - 1];
                const isGuaranteedRoll = (gacha.uberGuaranteedFlag || gacha.legendGuaranteedFlag) && (roll >= ngVal) && ((roll - ngVal) % 10 === 0);
                
                let addrStr = `${tIdx}(${node.address})`;
                if (!isCycleStart && prevTenIdx !== -1) {
                    addrStr = `${prevTenIdx}+${prevTenCons}=${tIdx}(${node.address})`;
                } else if (roll === 1) {
                    addrStr = `1+1=${tIdx}(${node.address})`;
                }

                if (isGuaranteedRoll) {
                    const gNode = Nodes[tIdx - 2]; 
                    const addressKey = gNode.address + 'G';
                    
                    let gAddrStr = `${tIdx-1}(${addressKey})`;
                    if (prevTenIdx !== -1) {
                         gAddrStr = `${prevTenIdx}+${prevTenCons}-1=${tIdx-1}(${addressKey})`;
                    }
                    
                    const itemGRarity = itemMaster[gNode.itemGId]?.rarity;
                    const itemGName = itemMaster[gNode.itemGId]?.name;
                    
                    let targetStr = (tLastItemId === -1) ? "Null" : `${tLastItemId}`;
                    if (roll === 1 && initialLastRollId) targetStr = `LastRoll(${initialLastRollId})`;

                    const fmtG = getFormattedItemComparison(itemGName, gNode.itemGId, itemGRarity, tLastItemId, targetStr);

                    tenPullRouteLog += `Roll${roll} guaranteed (番地) ${gAddrStr}／ItemG[${tIdx-1}]=${fmtG.text}${fmtG.isDupe ? 'レア被り' : ''}(2seed消費)<br>`; 
                    
                    const info = highlightInfo.get(addressKey) || {};
                    info.ten = true;
                    info.tenRoll = roll; // Roll count storage
                    highlightInfo.set(addressKey, info);
                    tLastItemId = gNode.itemGId;
                    
                    prevTenIdx = tIdx - 1;
                    prevTenCons = 2; 
                    tIdx += 1;
                } else {
                    const isRare = (node.rarityId === 1);
                    const poolSize = gacha.rarityItems[1] ? gacha.rarityItems[1].length : 0;
                    const isMatch = (node.itemId !== -1 && node.itemId === tLastItemId);
                    const reRollFlag = isRare && isMatch && poolSize > 1;
                    
                    let targetStr = (tLastItemId === -1) ? "Null" : `${tLastItemId}`;
                    if (roll === 1 && initialLastRollId) targetStr = `LastRoll(${initialLastRollId})`;

                    const fmt = getFormattedItemComparison(node.itemName, node.itemId, node.rarityId, tLastItemId, targetStr);
                    let line = `Roll${roll} (番地) ${addrStr}／Item[${tIdx}]=${fmt.text}${fmt.isDupe ? 'レア被り' : ''}`;
                    
                    const useSeeds = reRollFlag ? 3 : 2;
                    let finalId = node.itemId;
                     if (reRollFlag) {
                        const nextIdxRe = tIdx + useSeeds;
                        const nextAddrRe = getAddressString(nextIdxRe);
                        line += `／(再抽選)${tIdx}+3=${nextIdxRe}(${nextAddrRe}),ReRollItem[${tIdx}]=${node.reRollItemName}(${node.reRollItemId}(1))`;
                        finalId = node.reRollItemId;
                    }
                    line += `(${useSeeds}seed消費)`;
                    tenPullRouteLog += line + '<br>';

                    const info = highlightInfo.get(node.address) || {};
                    info.ten = true;
                    info.tenRoll = roll; // Roll count storage
                    info.t_reRoll = reRollFlag;
                    if (reRollFlag) {
                        info.t_normalName = node.itemName;
                        info.t_reRollName = node.reRollItemName;
                        info.t_nextAddr = getAddressString(tIdx + useSeeds);
                    }
                    highlightInfo.set(node.address, info);

                    prevTenIdx = tIdx;
                    prevTenCons = useSeeds;
                    tLastItemId = finalId;
                    tIdx += useSeeds;
                }
            }
        }

        detailsHtml += singleRouteLog;
        detailsHtml += tenPullRouteLog;

        let table = `<table style="table-layout: fixed;" class="${currentHighlightMode === 'single' ? 'mode-single' : (currentHighlightMode === 'multi' ? 'mode-multi' : '')}"><thead>`;
        table += `<tr><th id="forceRerollToggle" class="col-no" style="cursor: pointer;">${forceRerollMode ? '☑' : '□'}</th><th>A</th><th>AG</th><th>B</th><th>BG</th></tr>`;
        table += '</thead><tbody>';

        for (let r = 1; r <= tableRows; r++) {
            const nodeIdxA = (r - 1) * 2 + 1;
            const nodeIdxB = (r - 1) * 2 + 2;
            const nodeA = Nodes[nodeIdxA - 1];
            const nodeB = Nodes[nodeIdxB - 1];

            if (!nodeA || !nodeB) break;

            table += `<tr><td class="col-no">${r}</td>`;

            const renderCell = (node, suffix) => {
                const address = node.address + suffix;
                const info = highlightInfo.get(address);
                const isGuaranteed = (suffix === 'G');
                const itemId = isGuaranteed ? node.itemGId : node.itemId;
                const itemName = isGuaranteed ? node.itemGName : node.itemName;
                const itemRarity = itemMaster[itemId]?.rarity;
                
                let cellContent = '---';
                if (itemId !== -1) {
                    const href = generateItemLink(node.seed2, itemId, initialNg, r, true);
                    let nameHtml = `<a href="${href}">${itemName}</a>`;
                    
                    let cssClass = '';
                    if (!isGuaranteed) {
                        if (itemRarity === 4) cssClass = 'legendItem-text';
                        else if (itemRarity >= 3) cssClass = 'featuredItem-text';
                    }
                    if (cssClass) nameHtml = `<span class="${cssClass}">${nameHtml}</span>`;
                    
                    let showReRoll = false;
                    let rrNextAddr = '';
                    let rrName = '';
                    let normName = itemName;

                    if (info && !isGuaranteed) {
                        if (info.single && info.s_reRoll) {
                            showReRoll = true;
                            rrNextAddr = info.s_nextAddr;
                            rrName = info.s_reRollName;
                            normName = info.s_normalName;
                        } else if (info.ten && info.t_reRoll) {
                            showReRoll = true;
                            rrNextAddr = info.t_nextAddr;
                            rrName = info.t_reRollName;
                            normName = info.t_normalName;
                        }
                    } 
                    else if (!isGuaranteed && (node.reRollFlag || (forceRerollMode && node.rarityId === 1 && node.poolSize > 1))) {
                        showReRoll = true;
                        rrNextAddr = node.reRollNextAddress;
                        rrName = node.reRollItemName;
                        normName = node.itemName;
                    }

                    if (showReRoll) {
                         const hrefRe = generateItemLink(node.seed3, node.reRollItemId, initialNg, r, true);
                         let rrNameHtml = `<a href="${hrefRe}">${rrName}</a>`;
                         let rrCssClass = '';
                         const rrRarity = itemMaster[node.reRollItemId]?.rarity;
                         if (rrRarity === 4) rrCssClass = 'legendItem-text';
                         else if (rrRarity >= 3) rrCssClass = 'featuredItem-text';
                         if (rrCssClass) rrNameHtml = `<span class="${rrCssClass}">${rrNameHtml}</span>`;
                         const hrefNorm = generateItemLink(node.seed2, node.itemId, initialNg, r, true);
                         let normNameHtml = `<a href="${hrefNorm}">${normName}</a>`;
                         if (cssClass) normNameHtml = `<span class="${cssClass}">${normNameHtml}</span>`;
                         cellContent = `${normNameHtml}<br>${rrNextAddr})${rrNameHtml}`;
                    } else {
                         cellContent = nameHtml;
                    }
                }
                
                let cls = '';
                if (info) {
                    const isSingle10 = info.single && (info.singleRoll % 10 === 0);
                    const isTen10 = info.ten && (info.tenRoll % 10 === 0);

                    if (info.single && info.ten) {
                        if (isSingle10 || isTen10) cls = 'highlight-roll-overlap-dark';
                        else cls = 'highlight-roll-overlap';
                    } else if (info.single) {
                        cls = isSingle10 ? 'highlight-roll-dark' : 'highlight-roll';
                    } else if (info.ten) {
                        cls = isTen10 ? 'highlight-roll-10pull-dark' : 'highlight-roll-10pull';
                    }
                }
                
                return { html: `<td${cls ? ' class="'+cls+'"' : ''}>${cellContent}</td>` };
            };

            table += renderCell(nodeA, '').html;
            table += renderCell(nodeA, 'G').html;
            table += renderCell(nodeB, '').html;
            table += renderCell(nodeB, 'G').html;
            table += '</tr>';
        }
        table += '</tbody></table>';

        document.getElementById('result-table-container').innerHTML = table;
        const detailsDiv = document.getElementById('calculation-details');
        detailsDiv.innerHTML = detailsHtml;
        const detailsControls = document.getElementById('details-controls');
        const toggleBtn = document.getElementById('toggleDetailsBtn');
        const scrollButtons = detailsControls.querySelector('.scroll-buttons');
        detailsControls.style.display = 'flex';
        toggleBtn.onclick = () => {
            if (detailsDiv.style.display === 'none') {
                detailsDiv.style.display = 'block';
                scrollButtons.style.display = 'flex';
                toggleBtn.textContent = '計算過程を非表示';
            } else {
                detailsDiv.style.display = 'none';
                scrollButtons.style.display = 'none';
                toggleBtn.textContent = '計算過程を表示';
            }
        };
    }

    function createAndDisplayUncompletedSeedView(initialSeed, gacha, tableRows, thresholds, initialLastRollId, displaySeed, params) {
        const SEED = [initialSeed];
        const maxSeedsNeeded = tableRows * 10 + 1000; 
        for (let i = 1; i < maxSeedsNeeded; i++) {
            SEED[i] = xorshift32(SEED[i - 1]);
        }

        const getRarityFromRoll = (roll) => {
            if (roll < thresholds['0']) return { id: 0, name: 'ノーマル' };
            if (roll < thresholds['1']) return { id: 1, name: 'レア' };
            if (roll < thresholds['2']) return { id: 2, name: '激レア' };
            if (roll < thresholds['3']) return { id: 3, name: '超激レア' };
            return { id: 4, name: '伝説レア' };
        };
        
        const thArr = [
            thresholds['0'] === 0 ? '-' : thresholds['0']-1,
            thresholds['1']-1,
            thresholds['2']-1,
            thresholds['3']-1,
            9999
        ];
        const thresholdStr = `{${thArr.join(',')}}`;
        
        const getAddressString = (n) => {
            if (n <= 0) return '';
            const zeroBasedIndex = n - 1;
            const col_char = String.fromCharCode('A'.charCodeAt(0) + (zeroBasedIndex % 3));
            const row_num = Math.floor(zeroBasedIndex / 3) + 1;
            return `${row_num}${col_char}`;
        };
        
        // --- 1. 全ノード事前計算 ---
        const Nodes = [];
        const maxNodes = tableRows * 3 + 20;
        let detailsHtml = generateMasterInfoHtml(gacha);
        detailsHtml += '<h2>＜ノード計算詳細 (No.1～)＞</h2>';
        detailsHtml += '<p style="margin-top: -10px; font-size: 10px;">（このデータは、特定のSEED INDEXからの計算結果を示します。実際のルートではレア被りにより消費SEED数が異なります）</p>';
        
        let lastRollText = 'Null';
        if (initialLastRollId && itemMaster[initialLastRollId]) {
            lastRollText = `${itemMaster[initialLastRollId].name}(${initialLastRollId}(${itemMaster[initialLastRollId].rarity}))`;
        }
        detailsHtml += `ＬａｓｔＲｏｌｌ：${lastRollText}<br><br>`;
        
        for (let i = 1; i <= maxNodes; i++) {
            const seedStartIdx = (i - 1) * 3 + 1;
            const s1 = SEED[seedStartIdx];     
            const s2 = SEED[seedStartIdx + 1]; 
            const s3 = SEED[seedStartIdx + 2]; 
            const s4 = SEED[seedStartIdx + 3]; 
            const s5 = SEED[seedStartIdx + 4]; // For reRoll consistency in display

            const node = {
                index: i,
                address: getAddressString(i),
                seed1: s1, seed2: s2, seed3: s3, seed4: s4, seed5: s5,
                isFeatured: (s1 % 10000) < gacha.featuredItemRate
            };

            node.featuredNextAddress = getAddressString(i + 1);
            node.normalNextAddress = getAddressString(i + 3);
            node.reRollNextAddress = getAddressString(i + 4);

            node.rarity = getRarityFromRoll(s2 % 10000);
            node.rarityId = node.rarity.id;

            // Guaranteed Item Calculation for Uncomp Node
            const uberRate = gacha.uberGuaranteedFlag ? (gacha.rarityRates['3'] || 0) : 0;
            const legendRate = gacha.legendGuaranteedFlag ? (gacha.rarityRates['4'] || 0) : 0;
            const gDivisor = uberRate + legendRate;
            if (gDivisor > 0) {
                const gRoll = node.seed1 % gDivisor;
                node.rarityGId = (gRoll < uberRate) ? '3' : '4';
                const poolG = gacha.rarityItems[node.rarityGId] || [];
                if (poolG.length > 0) {
                    node.slotG = node.seed2 % poolG.length;
                    node.itemGId = poolG[node.slotG];
                    node.itemGName = itemMaster[node.itemGId]?.name || '---';
                } else {
                    node.slotG = 0; node.itemGId = -1; node.itemGName = '---';
                }
            } else {
                node.rarityGId = null; node.itemGId = -1; node.itemGName = '---';
            }

            const pool = gacha.rarityItems[node.rarityId] || [];
            node.poolSize = pool.length;
            if (pool.length > 0) {
                node.slot = s3 % pool.length;
                node.itemId = pool[node.slot];
                node.itemName = itemMaster[node.itemId]?.name || '---';
            } else {
                node.slot = 0; node.itemId = -1; node.itemName = '---';
            }
            
            // ReRoll Logic
            const isRare = (node.rarityId === 1);
            if (isRare && pool.length > 1) {
                const reRollPool = pool.filter(id => id !== node.itemId);
                if (reRollPool.length > 0) {
                    node.reRollSlot = s4 % reRollPool.length;
                    node.reRollItemId = reRollPool[node.reRollSlot];
                    node.reRollItemName = itemMaster[node.reRollItemId]?.name || '---';
                } else {
                    node.reRollItemId = -1; node.reRollItemName = '---';
                }
            } else {
                node.reRollItemId = -1; node.reRollItemName = '---';
            }

            // Calculate Duplication Status
            let prevId = -1;
            if (i <= 3) {
                prevId = initialLastRollId || -1;
            } else {
                if (Nodes[i-4]) prevId = Nodes[i-4].itemId;
            }
            node.isDupe = (node.rarityId === 1 && node.itemId !== -1 && node.itemId === prevId);

            Nodes.push(node);

            let lines = [];
            lines.push(`(番地) ${node.index}(${node.address})`);
            lines.push(`(目玉) isFeatured[${node.index}]=(S${seedStartIdx}(${node.seed1})%10000(=${node.seed1%10000})<${gacha.featuredItemRate})=${node.isFeatured}`);
            lines.push(`(レアリティ) (S${seedStartIdx+1}(${node.seed2})%10000(=${node.seed2%10000})<=${thresholdStr})=${node.rarityId}(${node.rarity.name})`);
            
            let prevIdForDetail = -1;
            let compTargetName = "Null";
            if (i <= 3) {
                if (initialLastRollId) {
                    prevIdForDetail = initialLastRollId;
                    compTargetName = `LastRoll(${initialLastRollId})`;
                }
            } else {
                const pNode = Nodes[i-4];
                prevIdForDetail = pNode.itemId;
                compTargetName = `Item[${pNode.index}]${pNode.itemId}`;
            }
            
            const fmt = getFormattedItemComparison(node.itemName, node.itemId, node.rarityId, prevIdForDetail, compTargetName);

            lines.push(`(スロット,アイテム) S${seedStartIdx+2}(${node.seed3})%${node.poolSize}=${node.slot},Item[${node.index}]=${fmt.text}${fmt.isDupe ? 'レア被り' : ''}`);
            
            if (node.reRollItemId !== -1) {
                 lines.push(`(スロット,アイテム(再抽選)) S${seedStartIdx+3}(${node.seed4})%(${pool.length-1})=${node.reRollSlot},ReRollItem[${node.index}]=${node.reRollItemName}(${node.reRollItemId}(1))`);
            }
            
            lines.push(`(遷移先) 目玉時:${node.index}+1=${node.index+1}(${node.featuredNextAddress}), 通常:${node.index}+3=${node.index+3}(${node.normalNextAddress}), 被り時:${node.index}+4=${node.index+4}(${node.reRollNextAddress})`);
            
            detailsHtml += `<strong>No.${node.index}</strong><br>` + lines.join('<br>') + '<br><br>';
        }

        // --- 2. 単発ルート計算 (Single Route Log) ---
        let singleRouteLog = '<h2>＜単発ルート＞</h2>';
        singleRouteLog += `(LastRoll=${lastRollText})<br>`;

        let sIdx = 1; 
        let sLastActualItemId = initialLastRollId || -1; // 目玉/確定を除いた最後のアイテムID
        let singleRoutePath = new Map(); // ハイライト用 (NodeIdx -> RollCount)
        let ngVal = parseInt(params.get('ng'), 10);
        const hasGuaranteed = !isNaN(ngVal);
        let currentNg = hasGuaranteed ? ngVal : -1;
        const guaranteedCycle = gacha.guaranteedCycle || 30;

        let tableRowData = []; // For creating the HTML table later

        for (let roll = 1; roll <= tableRows; roll++) {
            if (sIdx > maxNodes) break;
            const node = Nodes[sIdx - 1];
            singleRoutePath.set(sIdx, roll);

            const isGuaranteedRoll = hasGuaranteed && (currentNg === 1); // NG=1 means this roll is guaranteed

            if (isGuaranteedRoll) {
                // Guaranteed Roll: 0 seed consumption, shows as "目玉(確定)"
                const addrStr = `${sIdx}(${node.address})`;
                singleRouteLog += `Roll${roll} guaranteed (番地) ${sIdx}+0=${sIdx}(${node.address})／Item[${roll}]=目玉(確定)／(レア被り)false(0seed消費)<br>`;
                
                tableRowData.push({
                    roll: roll,
                    isGuaranteed: true,
                    isFeatured: false,
                    isReroll: false,
                    node: node,
                    sIdx: sIdx,
                    ngForLink: 30 
                });
                
                let oldNg = currentNg;
                currentNg = guaranteedCycle; 
                continue; 
            }

            // Normal Roll Logic
            let usedSeeds = 0;
            let finalId = -1;
            let itemName = '';
            let isFeat = false;
            let isReroll = false;
            
            if (node.isFeatured) {
                isFeat = true;
                usedSeeds = 1;
                itemName = "目玉"; 
                finalId = -2; 
            } else {
                const isRare = (node.rarityId === 1);
                const poolSize = gacha.rarityItems[1] ? gacha.rarityItems[1].length : 0;
                const isMatch = (node.itemId !== -1 && node.itemId === sLastActualItemId);
                isReroll = isRare && isMatch && poolSize > 1;
                
                finalId = isReroll ? node.reRollItemId : node.itemId;
                itemName = node.itemName;
                
                usedSeeds = isReroll ? 4 : 3;
                sLastActualItemId = finalId; 
            }

            const nextIdx = sIdx + usedSeeds;
            const nextAddr = getAddressString(nextIdx);
            
            let line = `Roll${roll} (番地) ${sIdx}(${node.address})`;
            if (isFeat) {
                 line += `／Item[${roll}]=目玉`;
                 line += `／(レア被り)false`;
            } else {
                 let targetStr = (sLastActualItemId === -1) ? "Null" : `${sLastActualItemId}`;
                 if (roll === 1 && initialLastRollId) targetStr = `LastRoll(${initialLastRollId})`;
                 
                 const fmt = getFormattedItemComparison(node.itemName, node.itemId, node.rarityId, sLastActualItemId, targetStr);
                 const dupeMark = isReroll ? 'レア被り' : '';

                 line += `／Item[${roll}]=${fmt.text}${dupeMark}`;
                 
                 if (isReroll) {
                     line += `／(再抽選)${sIdx}+4=${nextIdx}(${nextAddr}),ReRollItem[${roll}]=${node.reRollItemName}(${node.reRollItemId}(1))`;
                 }
            }
            line += `(${usedSeeds}seed消費)`;
            singleRouteLog += line + '<br>';

            tableRowData.push({
                roll: roll,
                isGuaranteed: false,
                isFeatured: isFeat,
                isReroll: isReroll,
                node: node,
                sIdx: sIdx,
                usedSeeds: usedSeeds,
                itemId: finalId,
                itemName: itemName,
                rerollName: node.reRollItemName,
                rerollNextAddr: node.reRollNextAddress,
                featuredNextAddr: node.featuredNextAddress,
                ngForLink: currentNg
            });

            if (hasGuaranteed) {
                let oldNg = currentNg;
                currentNg = currentNg - 1;
                if (currentNg <= 0) currentNg = guaranteedCycle;
            }
            sIdx = nextIdx;
        }
        detailsHtml += singleRouteLog;

        // --- 3. 10連ルート計算 (10-Pull Route Log) ---
        let tenPullRouteLog = '<h2>＜10連ルート＞</h2>';
        tenPullRouteLog += '(※1サイクル目のみ表示。NextGuaranteedに該当する場合は「目玉(確定)」になるので、それ以外のRollを判定します。未コンプ時の10連は、まずNextGuaranteedを除く9～10個分のSEEDで目玉判定を一括で行い、その後残りのSEEDで中身を抽選します。)<br><br>';
        
        let tpNgVal = parseInt(params.get('ng'), 10);
        if (isNaN(tpNgVal)) tpNgVal = -999;

        const featuredFlags = [];
        let batchLog = '(目玉一括判定)<br>';
        
        for (let i = 1; i <= 10; i++) {
            let isGuaranteedSlot = (i === tpNgVal);
            
            if (isGuaranteedSlot) {
                batchLog += `Roll${i}：Guaranteed<br>`;
                featuredFlags.push({ isFeatured: false, isGuaranteed: true }); 
            } else {
                const checkSeed = SEED[i - (featuredFlags.filter(f=>f.isGuaranteed).length)];
                const isFeatured = (checkSeed % 10000) < gacha.featuredItemRate;
                batchLog += `Roll${i}：isFeatured [${i- (featuredFlags.filter(f=>f.isGuaranteed).length)}]= ${isFeatured}<br>`;
                featuredFlags.push({ isFeatured: isFeatured, isGuaranteed: false });
            }
        }
        tenPullRouteLog += batchLog + '<br>続きのSEEDから順次SEEDを消費して、レアリティ判定、スロット判定、再抽選スロット判定を行う<br><br>';
        tenPullRouteLog += 'LastRoll：null<br><br>';

        let currentSeedIndex = (10 - featuredFlags.filter(f=>f.isGuaranteed).length) + 1;

        let tpLastItemId = initialLastRollId || -1;
        let tenPullResults = []; // G列表示用テキスト配列

        for (let r = 1; r <= 10; r++) {
            const flagData = featuredFlags[r-1];
            tenPullRouteLog += `Roll${r}<br>`;
            
            if (flagData.isGuaranteed) {
                 tenPullRouteLog += `目玉(確定)<br><br>`;
                 tenPullResults.push({text: '目玉(確定)', isFeatured: true});
                 tpLastItemId = -1; 
            } else if (flagData.isFeatured) {
                 tenPullRouteLog += `目玉<br><br>`;
                 tenPullResults.push({text: '目玉', isFeatured: true});
            } else {
                 const s_rarity = SEED[currentSeedIndex];
                 const s_slot = SEED[currentSeedIndex + 1];
                 const s_reroll = SEED[currentSeedIndex + 2];
                 
                 const rarityObj = getRarityFromRoll(s_rarity % 10000);
                 tenPullRouteLog += `(レアリティ) (S${currentSeedIndex}(${s_rarity})%10000(=${s_rarity%10000}) <=${thresholdStr})=${rarityObj.id}(${rarityObj.name})<br>`;
                 
                 const pool = gacha.rarityItems[rarityObj.id] || [];
                 let itemVal = -1;
                 let itemName = '---';
                 let slotInfo = '';
                 if (pool.length > 0) {
                     const slot = s_slot % pool.length;
                     itemVal = pool[slot];
                     itemName = itemMaster[itemVal]?.name || '---';
                     
                     let targetStr = (tpLastItemId === -1) ? "Null" : `${tpLastItemId}`;
                     if (r === 1 && initialLastRollId) targetStr = `LastRoll(${initialLastRollId})`;

                     const fmt = getFormattedItemComparison(itemName, itemVal, rarityObj.id, tpLastItemId, targetStr);
                     
                     slotInfo = `S${currentSeedIndex+1}(${s_slot})%${pool.length}=${slot}, ${fmt.text}`;
                 } else {
                     slotInfo = 'Pool Empty';
                 }
                 tenPullRouteLog += `(スロット,アイテム) ${slotInfo}<br>`;

                 const isRare = (rarityObj.id === 1);
                 const isDupe = (itemVal !== -1 && itemVal === tpLastItemId);
                 const reRoll = isRare && isDupe && pool.length > 1;
                 
                 if (reRoll) tenPullRouteLog += `(レア被り) レア被り<br>`;
                 else tenPullRouteLog += `(レア被り) false<br>`;
                 
                 let finalName = itemName;
                 if (reRoll) {
                     const rePool = pool.filter(id => id !== itemVal);
                     const reSlot = s_reroll % rePool.length;
                     const reItem = rePool[reSlot];
                     const reName = itemMaster[reItem]?.name || '---';
                     tenPullRouteLog += `(スロット,アイテム(再抽選)) S${currentSeedIndex+2}(${s_reroll})%${rePool.length}=${reSlot},${reName}(${reItem}(1))<br>`;
                     tpLastItemId = reItem;
                     currentSeedIndex += 3;
                     finalName = `${itemName}<br>(再)${reName}`;
                 } else {
                     tpLastItemId = itemVal;
                     currentSeedIndex += 2;
                 }
                 tenPullResults.push({text: finalName, isFeatured: false});
                 tenPullRouteLog += '<br>';
            }
        }
        detailsHtml += tenPullRouteLog;

        // --- 4. 表の構築 ---
        let table = '<table style="table-layout: fixed;"><thead>';
        let header1 = `<tr><th rowspan="${displaySeed === '1' ? 2 : 1}" id="forceRerollToggle" class="col-no" style="cursor: pointer;">${forceRerollMode ? '☑' : '□'}</th>`;
        let header2 = '<tr>';
        if (displaySeed === '1') {
            header1 += '<th colspan="5">A</th><th colspan="5">B</th><th colspan="5">C</th><th colspan="5">G</th>';
            const subHeaders = ['S1<br>Feat', 'S2<br>Rare', 'S3<br>Slot', 'S4<br>Re', 'Item'];
            for(let i=0; i<4; i++) header2 += subHeaders.map(h => `<th>${h}</th>`).join('');
        } else {
            header1 += '<th>A</th><th>B</th><th>C</th><th>G</th>';
        }
        header1 += '</tr>';
        if (displaySeed === '1') { header2 += '</tr>'; table += header1 + header2; } else { table += header1; }
        table += '</thead><tbody>';
        
        for (let r = 0; r < tableRows; r++) {
            table += `<tr><td class="col-no">${r + 1}</td>`;
            const nodeIndices = [r * 3 + 1, r * 3 + 2, r * 3 + 3];
            
            // Next Guaranteed Logic Check for Uncomp (Single Route)
            const currentRollNum = r + 1;
            let isNextGuaranteedTarget = false;
            if (!isNaN(ngVal) && gacha.uberGuaranteedFlag) {
                // Logic: Roll == NG OR (Roll > NG && (Roll - NG) % 30 == 0)
                if (currentRollNum === ngVal) isNextGuaranteedTarget = true;
                else if (currentRollNum > ngVal && (currentRollNum - ngVal) % 30 === 0) isNextGuaranteedTarget = true;
            }

            nodeIndices.forEach(idx => {
                const node = Nodes[idx - 1];
                if (!node) {
                    table += displaySeed === '1' ? '<td colspan="5"></td>' : '<td></td>';
                    return;
                }

                let cls = '';
                let rollNum = singleRoutePath.get(idx);
                if (rollNum) {
                    if (rollNum % 10 === 0) cls = 'highlight-roll-dark';
                    else cls = 'highlight-roll';
                }
                
                let content = '';

                if (node.isFeatured) {
                    const href = generateItemLink(node.seed1, -2, params.get('ng'), r+1, false);
                    content = `${node.featuredNextAddress})<a href="${href}"><span class="featuredItem-text">目玉</span></a>`;
                } else {
                    const href = generateItemLink(node.seed3, node.itemId, params.get('ng'), r+1, false);
                    let itemName = node.itemName;
                    let css = '';
                    if (itemMaster[node.itemId]?.rarity >= 3) css = 'featuredItem-text';
                    if (itemMaster[node.itemId]?.rarity === 4) css = 'legendItem-text';

                    content = `<a href="${href}" class="${css}">${itemName}</a>`;

                    if (node.reRollItemId !== -1 && node.isDupe) {
                        const rrHref = generateItemLink(node.seed4, node.reRollItemId, params.get('ng'), r+1, false);
                        let rrName = node.reRollItemName;
                        let rrCss = '';
                        if (itemMaster[node.reRollItemId]?.rarity >= 3) rrCss = 'featuredItem-text';
                        if (itemMaster[node.reRollItemId]?.rarity === 4) rrCss = 'legendItem-text';
                        content += `<br>${node.reRollNextAddress})<a href="${rrHref}" class="${rrCss}">${rrName}</a>`;
                    }
                }
                
                // Overwrite content if it's a Guaranteed Target on Single Route
                if (isNextGuaranteedTarget && singleRoutePath.has(idx)) {
                    content = `<span class="featuredItem-text">目玉(確定)</span><br>/${node.itemGName}`;
                }

                if (displaySeed === '1') {
                    const sub1 = `(S${(idx-1)*3+1})${node.seed1}<br>${node.seed1%10000}<br>${node.isFeatured}`;
                    const sub2 = `(S${(idx-1)*3+2})${node.seed2}<br>${node.seed2%10000}<br>${node.rarity.name}`;
                    const sub3 = `(S${(idx-1)*3+3})${node.seed3}<br>${node.poolSize}<br>${node.slot}`;
                    let sub4 = '---';
                    if (!node.isFeatured && node.reRollItemId !== -1) {
                        sub4 = `(S${(idx-1)*3+4})${node.seed4}<br>ReRoll`;
                    }
                    table += `<td${cls ? ' class="'+cls+'"' : ''}>${sub1}</td><td${cls ? ' class="'+cls+'"' : ''}>${sub2}</td><td${cls ? ' class="'+cls+'"' : ''}>${sub3}</td><td${cls ? ' class="'+cls+'"' : ''}>${sub4}</td><td${cls ? ' class="'+cls+'"' : ''}>${content}</td>`;
                } else {
                    table += `<td${cls ? ' class="'+cls+'"' : ''}>${content}</td>`;
                }
            });

            // G Column
            let gStyle = '';
            if (r < 9) {
                gStyle = 'background-color: #ffffe0;';
            } else if (r === 9) { // 10th row
                gStyle = 'background-color: #ffff8d;'; 
            }
            
            if (tenPullResults[r]) {
                 let tRes = tenPullResults[r];
                 let gContent = tRes.text;
                 if (tRes.isFeatured) gContent = `<span class="featuredItem-text">${gContent}</span>`;
                 if (displaySeed === '1') table += `<td colspan="5" style="${gStyle}">${gContent}</td>`;
                 else table += `<td style="${gStyle}">${gContent}</td>`;
            } else {
                 if (displaySeed === '1') table += `<td colspan="5" style="${gStyle}">-</td>`;
                 else table += `<td style="${gStyle}">-</td>`;
            }
            table += '</tr>';
        }

        table += '</tbody></table>';
        
        document.getElementById('result-table-container').innerHTML = table;
        
        // Setup Details
        const detailsDiv = document.getElementById('calculation-details');
        detailsDiv.innerHTML = detailsHtml;
        const detailsControls = document.getElementById('details-controls');
        const toggleBtn = document.getElementById('toggleDetailsBtn');
        const scrollButtons = detailsControls.querySelector('.scroll-buttons');
        
        detailsControls.style.display = 'flex';
        toggleBtn.style.display = 'inline-block'; 

        toggleBtn.onclick = () => {
            if (detailsDiv.style.display === 'none') {
                detailsDiv.style.display = 'block';
                scrollButtons.style.display = 'flex';
                toggleBtn.textContent = '計算過程を非表示';
            } else {
                detailsDiv.style.display = 'none';
                scrollButtons.style.display = 'none';
                toggleBtn.textContent = '計算過程を表示';
            }
        };
    }

    // --- ディスパッチャー & メイン ---
    let activeGachaId;
    let forceRerollMode = false;

    function runSimulationAndDisplay(options = {}) {
        const { hideSeedInput = false, uiOverrides = {} } = options;
        const params = new URLSearchParams(window.location.search);
        const latestGachaId = Object.keys(gachaMaster).reduce((a, b) => parseInt(a) > parseInt(b) ? a : b);
        
        const p = {};
        ['gacha', 'seed', 'ng', 'fs', 'lr', 'comp', 'tx', 'roll', 'displaySeed'].forEach(k => {
            p[k] = params.get(k);
        });
        if (!p.gacha || !gachaMaster[p.gacha]) p.gacha = latestGachaId;
        if (!p.seed) p.seed = DEFAULT_PARAMS.seed;
        if (!p.roll) p.roll = DEFAULT_PARAMS.roll;
        if (!p.ng) p.ng = DEFAULT_PARAMS.ng;
        if (p.tx === 'true') p.tx = '1'; else if (p.tx === 'false') p.tx = '0';
        if (!p.tx && DEFAULT_PARAMS.tx) p.tx = '1';
        if (p.comp === '1') p.comp = 'true'; else if (p.comp === '0') p.comp = 'false';
        
        if (uiOverrides.seed !== undefined) p.seed = uiOverrides.seed;
        if (uiOverrides.guaranteedRolls !== undefined) p.ng = uiOverrides.guaranteedRolls;
        if (uiOverrides.featuredStock !== undefined) p.fs = uiOverrides.featuredStock;
        if (uiOverrides.isComplete !== undefined) p.comp = uiOverrides.isComplete ? 'true' : 'false';
        
        activeGachaId = p.gacha;
        const gacha = gachaMaster[p.gacha];
        
        document.getElementById('seedInput').value = p.seed;
        const isComplete = (p.comp === 'true');
        document.getElementById('featuredCompleteCheckbox').checked = isComplete;
        
        if (gacha.featuredItemStock === 0) {
            document.getElementById('featuredCompleteCheckbox').checked = true;
            document.getElementById('featuredCompleteCheckbox').parentElement.classList.add('hidden-control');
        } else {
            document.getElementById('featuredCompleteCheckbox').parentElement.classList.remove('hidden-control');
        }
        
        const isComp = document.getElementById('featuredCompleteCheckbox').checked;
        const stockControl = document.getElementById('stockControl');
        const guaranteedControl = document.getElementById('guaranteedControl');
        const legendDisplay = document.getElementById('legendDisplay');

        populateFeaturedStockInput(p.gacha, p.fs);

        const legendCommon = document.getElementById('legendCommon');
        if (isComp) {
            stockControl.classList.add('hidden-control');
            if (gacha.uberGuaranteedFlag || gacha.legendGuaranteedFlag) {
                guaranteedControl.classList.remove('hidden-control');
                legendDisplay.classList.remove('hidden-control');
                populateGuaranteedRolls(10, p.ng);
            } else {
                guaranteedControl.classList.add('hidden-control');
                legendDisplay.classList.add('hidden-control');
            }
            legendCommon.style.display = 'inline-block';
        } else {
            stockControl.classList.remove('hidden-control');
            guaranteedControl.classList.remove('hidden-control');
            legendDisplay.classList.remove('hidden-control');
            populateGuaranteedRolls(gacha.guaranteedCycle || 30, p.ng);
            legendCommon.style.display = 'none'; 
        }

        const lastRollDisplay = document.getElementById('lastRollDisplay');
        if (p.lr && itemMaster[p.lr]) {
            lastRollDisplay.textContent = `LastRoll: ${itemMaster[p.lr].name}`;
        } else {
            lastRollDisplay.textContent = '';
        }

        const newParams = {
            gacha: p.gacha, seed: p.seed, ng: p.ng, fs: p.fs, lr: p.lr,
            comp: isComp ? 'true' : 'false',
            tx: (p.tx === '1' || (!hideSeedInput && document.getElementById('seedRow').classList.contains('hidden-control') === false)) ? '1' : '0',
            roll: p.roll, displaySeed: p.displaySeed
        };
        if (!hideSeedInput && document.getElementById('seedRow').style.display === 'flex') newParams.tx = '1';

        const newQuery = generateUrlQuery(newParams);
        window.history.replaceState({ path: newQuery }, '', `${window.location.pathname}${newQuery}`);

        const seedValue = parseInt(p.seed, 10);
        const lastRollId = p.lr ? parseInt(p.lr, 10) : null;
        const rows = parseInt(p.roll, 10);
        const thresholds = {
            '0': gacha.rarityRates['0'],
            '1': gacha.rarityRates['0'] + gacha.rarityRates['1'],
            '2': gacha.rarityRates['0'] + gacha.rarityRates['1'] + gacha.rarityRates['2'],
            '3': gacha.rarityRates['0'] + gacha.rarityRates['1'] + gacha.rarityRates['2'] + gacha.rarityRates['3'],
            '4': 10000
        };

        if (isComp) {
            createAndDisplayCompletedSeedView(seedValue, gacha, rows, thresholds, lastRollId, p.displaySeed, new URLSearchParams(newQuery), p.ng);
        } else {
            createAndDisplayUncompletedSeedView(seedValue, gacha, rows, thresholds, lastRollId, p.displaySeed, new URLSearchParams(newQuery));
        }
    }
    
    function populateGuaranteedRolls(max, currentVal) {
        const input = document.getElementById('guaranteedRollsInput');
        input.innerHTML = '';
        const unsetOption = document.createElement('option');
        unsetOption.value = 'none'; unsetOption.textContent = '未設定'; input.appendChild(unsetOption);
        for (let i = 1; i <= max; i++) {
            const option = document.createElement('option'); option.value = i; option.textContent = i; input.appendChild(option);
        }
        if (currentVal && input.querySelector(`option[value="${currentVal}"]`)) {
            input.value = currentVal;
        } else {
            input.value = 'none';
        }
    }
    function populateFeaturedStockInput(gachaId, preferredValue) {
        const gacha = gachaMaster[gachaId];
        const input = document.getElementById('featuredStockInput');
        if (!gacha) return;
        input.innerHTML = '';
        const unsetOption = document.createElement('option');
        unsetOption.value = 'none'; unsetOption.textContent = '-'; input.appendChild(unsetOption);
        for (let i = 1; i <= gacha.featuredItemStock; i++) {
            const option = document.createElement('option'); option.value = i; option.textContent = i; input.appendChild(option);
        }
        if (preferredValue && preferredValue !== 'none' && input.querySelector(`option[value="${preferredValue}"]`)) {
            input.value = preferredValue;
        } else {
            input.value = 'none';
        }
    }

    function generateItemLink(newSeed, newItemId, initialInputNg, rollNumberInSequence, isCompleted) {
        const currentParams = new URLSearchParams(window.location.search);
        const paramsForQuery = {};
        for (const [key, value] of currentParams.entries()) paramsForQuery[key] = value;
        if (!paramsForQuery.gacha) paramsForQuery.gacha = activeGachaId;

        paramsForQuery.seed = newSeed;
        if (newItemId !== undefined) paramsForQuery.lr = newItemId;

        const initialInputNgInt = parseInt(initialInputNg, 10);
        if (initialInputNg !== 'none' && !isNaN(initialInputNgInt) && rollNumberInSequence !== undefined) {
            if (isCompleted) {
                const rollInCycle = (rollNumberInSequence - 1) % 10;
                let ngValue = initialInputNgInt - 1 - rollInCycle;
                if (ngValue <= 0) ngValue += 10;
                paramsForQuery.ng = ngValue.toString();
            } else {
                const gacha = gachaMaster[activeGachaId];
                const periodicity = gacha.guaranteedCycle || 30;
                let ngValue = initialInputNgInt;
                ngValue = ngValue - 1;
                if (ngValue <= 0) ngValue = periodicity;
                paramsForQuery.ng = ngValue.toString();
            }
        } else {
            paramsForQuery.ng = 'none';
        }
        return generateUrlQuery(paramsForQuery);
    }
    
    function toggleSeedInput() {
        const seedRow = document.getElementById('seedRow');
        if (seedRow.classList.contains('hidden-control')) {
            seedRow.classList.remove('hidden-control');
        } else {
            seedRow.classList.add('hidden-control');
        }
    }

    document.addEventListener('DOMContentLoaded', () => {
        setupGachaRarityItems();
        document.getElementById('executeButton').addEventListener('click', () => runSimulationAndDisplay({ hideSeedInput: true, uiOverrides: { seed: document.getElementById('seedInput').value } }));
        document.getElementById('guaranteedRollsInput').addEventListener('change', (e) => runSimulationAndDisplay({ uiOverrides: { guaranteedRolls: e.target.value } }));
        document.getElementById('featuredStockInput').addEventListener('change', (e) => runSimulationAndDisplay({ uiOverrides: { featuredStock: e.target.value } }));
        document.getElementById('featuredCompleteCheckbox').addEventListener('change', () => runSimulationAndDisplay({ uiOverrides: { isComplete: document.getElementById('featuredCompleteCheckbox').checked } }));
        document.getElementById('copySeedLink').addEventListener('click', (event) => {
            event.preventDefault();
            const seedToCopy = new URLSearchParams(window.location.search).get('seed');
            if (seedToCopy && navigator.clipboard) {
                navigator.clipboard.writeText(seedToCopy).then(() => {
                    const originalText = event.target.textContent;
                    event.target.textContent = 'Copied!';
                    setTimeout(() => { event.target.textContent = originalText; }, 1500);
                });
            }
        });
        document.getElementById('result-table-container').addEventListener('click', (event) => {
            if (event.target.id === 'forceRerollToggle') {
                forceRerollMode = !forceRerollMode;
                runSimulationAndDisplay();
            }
        });

        document.getElementById('showSeedInputLink').addEventListener('click', (e) => {
            e.preventDefault();
            toggleSeedInput();
        });

        const applyHighlightMode = () => {
             const table = document.querySelector('#result-table-container table');
             if (!table) return;
             table.classList.remove('mode-single', 'mode-multi');
             if (currentHighlightMode === 'single') table.classList.add('mode-single');
             if (currentHighlightMode === 'multi') table.classList.add('mode-multi');
        };

        document.getElementById('legendSingle').addEventListener('click', () => {
            if (document.getElementById('featuredCompleteCheckbox').checked) {
                currentHighlightMode = (currentHighlightMode === 'single') ? 'all' : 'single';
                applyHighlightMode();
            }
        });
        document.getElementById('legendMulti').addEventListener('click', () => {
            if (document.getElementById('featuredCompleteCheckbox').checked) {
                currentHighlightMode = (currentHighlightMode === 'multi') ? 'all' : 'multi';
                applyHighlightMode();
            }
        });

        document.getElementById('scrollToSingle').addEventListener('click', () => {
            const h2s = document.querySelectorAll('#calculation-details h2');
            for (const h2 of h2s) {
                if (h2.textContent.includes('＜単発ルート＞')) {
                    h2.scrollIntoView({ behavior: 'smooth' });
                    break;
                }
            }
        });

        document.getElementById('scrollToMulti').addEventListener('click', () => {
            const h2s = document.querySelectorAll('#calculation-details h2');
            for (const h2 of h2s) {
                if (h2.textContent.includes('＜10連ルート＞')) {
                    h2.scrollIntoView({ behavior: 'smooth' });
                    break;
                }
            }
        });

        runSimulationAndDisplay();
    });
</script>
</body>
</html>