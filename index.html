<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>イベントガチャロールズ</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.2;
            padding: 5px;
            max-width: 1200px; /* Increased width for new layout */
            margin: 0 auto;
            background-color: #f4f7f9;
            color: #333;
            font-size: 9px;
        }
        .container {
            background: #fff;
            padding: 5px;
            border-radius: 12px;
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.1);
        }
        h1 {
            color: #004085;
            font-size: 0.9rem;
            border-bottom: 1px solid #e9ecef;
            padding-bottom: 3px;
            margin-top: 0;
            text-align: center;
        }
        .controls {
            display: flex;
            flex-direction: column;
            gap: 5px;
            margin-bottom: 10px;
            padding: 4px;
            background-color: #f9fbfd;
            border-radius: 4px;
        }
        .row {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
            gap: 5px;
            align-items: center;
        }
        .control-group-left, .control-group-right {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        .input-item {
            flex: 0 1 auto;
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 3px;
        }
        .input-item-display-only {
            flex: 0 1 auto;
            display: flex;
            align-items: center;
            font-size: 0.7rem;
            color: #555;
            padding: 0 5px;
        }
        .input-item-seed {
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 3px;
        }
        .seed-input-group {
            display: flex;
            align-items: center;
            gap: 5px;
            flex: 1 1 200px;
        }
        label {
            font-weight: 600;
            color: #555;
        }
        input[type="number"],
        select {
            padding: 3px;
            border: 1px solid #ccc;
            border-radius: 3px;
            font-size: 0.8rem;
            width: 100%;
            box-sizing: border-box;
            transition: border-color 0.3s;
        }
        input[type="number"]:focus,
        select:focus {
            outline: none;
            border-color: #007bff;
        }
        button {
            flex-shrink: 0;
            width: auto;
            padding: 5px 10px;
            background-color: #007bff;
            color: #fff;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.8rem;
            font-weight: bold;
            transition: background-color 0.3s ease, transform 0.2s ease;
        }
        .hidden-control {
            display: none !important;
        }
        #showSeedInputLink {
            color: #007bff;
            text-decoration: underline;
            cursor: pointer;
            padding: 0 5px;
        }
        #copySeedLink {
            color: #007bff;
            text-decoration: underline;
            cursor: pointer;
            white-space: nowrap;
        }

        button:hover {
            background-color: #0056b3;
            transform: translateY(-2px);
        }
        #result-container {
            margin-top: 15px;
        }
        #result-table-container {
            overflow-x: auto;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
        }
        table {
            width: 100%;
            border-collapse: collapse;
        }
        th, td {
            padding: 3px;
            text-align: center;
            border: 1px solid #e0e0e0;
            word-break: break-word; /* Allow long words to break */
            font-size: 0.8rem;
            min-width: 25px; /* Halved width */
        }
        th {
            background-color: #f0f4f7;
            color: #444;
            font-weight: 600;
            position: sticky;
            top: 0;
            z-index: 1;
        }
        thead th:first-child {
            z-index: 2;
        }
        td {
            background-color: #fff;
        }
        .row-number-header {
            font-family: Arial, sans-serif;
            font-weight: bold;
            width: 25px;
            cursor: pointer;
        }
        .col-no {
            width: 25px;
        }
        .featuredItem-text {
            color: #d9534f;
            font-weight: bold;
        }

        /* --- ▼ 修正 (1): リンクのスタイルを無効化 ▼ --- */
        #result-table-container td a {
            color: inherit; /* 親要素の色を継承 */
            text-decoration: none; /* 下線を削除 */
        }
        /* --- ▲ 修正 (1) 完了 ▲ --- */

        /* --- ▼ 修正 (3): ハイライト用CSS (全色) ▼ --- */
        /* 単発ルート (青) */
        .highlight-roll { background-color: #e0f7ff !important; } /* 薄い青 */
        .highlight-roll-10 { background-color: #a0eaff !important; } /* やや濃い薄い青色 */
        /* 10連ルート (黄) */
        .highlight-roll-10pull { background-color: #ffffe0 !important; }
        .highlight-roll-10pull-10 { background-color: #FFF39B !important; }
        /* 重複ルート (緑) */
        .highlight-roll-overlap { background-color: #e0ffe0 !important; }
        .highlight-roll-overlap-10 { background-color: #a0eda0 !important; }
        /* --- ▲ 修正 (3) 完了 ▲ --- */
    </style>
</head>
<body>

<div class="container">
    <h1>イベントガチャロールズ</h1>
    <div class="input-group">
        <div class="controls">
            <div class="row">
                <div class="control-group-left">
                    <div class="input-item" id="seedLinkContainer">
                        <a id="showSeedInputLink" href="#">SEED入力</a>
                    </div>
                    <div class="input-item" id="guaranteedControl">
                        <label for="guaranteedRollsInput">next guaranteed</label>
                        <select id="guaranteedRollsInput"></select>
                    </div>
                    <div class="input-item" id="legendDisplay" style="font-size: 0.7rem;">
                        <span style="background-color: #e0ffe0; padding: 2px 5px; border-radius: 3px; margin-left: 10px;">単発ルート</span>
                        <span style="background-color: #ffffe0; padding: 2px 5px; border-radius: 3px; margin-left: 5px;">10連ルート</span>
                        <span style="background-color: #dfffb0; padding: 2px 5px; border-radius: 3px; margin-left: 5px;">共通ルート</span>
                    </div>
                    <div id="lastRollDisplay" class="input-item-display-only">
                        </div>
                </div>
                <div class="control-group-right">
                    <div class="input-item">
                        <label for="featuredCompleteCheckbox">コンプ済み</label>
                        <input type="checkbox" id="featuredCompleteCheckbox">
                    </div>
                    <div class="input-item" id="stockControl">
                        <label for="featuredStockInput">目玉残数</label>
                        <select id="featuredStockInput"></select>
                    </div>
                    <a id="copySeedLink" href="#">Copy SEED</a>
                </div>
            </div>
            <div class="row hidden-control" id="seedRow">
                <div class="input-item-seed">
                    <label for="seedInput">SEED</label>
                    <div class="seed-input-group">
                        <input type="number" id="seedInput" value="123456789">
                        <button id="executeButton">更新</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div id="result-container">
        <div id="output"></div>
        <div id="result-table-container"></div>
    </div>
</div>

<script>
    // --- マスターデータ ---
    const gachaMaster = {
        '34': { name: '(旧)ハロウィン', featuredItemRate: 600, featuredItemStock: 5, guaranteedCycle: 30, uberGuaranteedFlag: false, legendGuaranteedFlag: false, rarityRates: { '0': 2000, '1': 5000, '2': 3000, '3': 0, '4': 0 }, pool: [0, 2, 3, 4, 5, 10, 11, 12, 14] },
        '42': { name: '1.1億DL記念', featuredItemRate: 500, featuredItemStock: 5, guaranteedCycle: 30, uberGuaranteedFlag: false, legendGuaranteedFlag: false, rarityRates: { '0': 1000, '1': 5000, '2': 3000, '3': 1000, '4': 0 }, pool: [0, 2, 3, 4, 5, 10, 11, 12, 14, 375, 381, 689] },
        '44': { name: 'ハロウィン', featuredItemRate: 500, featuredItemStock: 8, guaranteedCycle: 30, uberGuaranteedFlag: false, legendGuaranteedFlag: false, rarityRates: { '0': 2000, '1': 4900, '2': 3000, '3': 0, '4': 100 }, pool: [0, 2, 3, 4, 5, 10, 11, 12, 14, 18] },
        '45': { name: 'にゃんこレンジャー', featuredItemRate: 0, featuredItemStock: 0, guaranteedCycle: 10, uberGuaranteedFlag: true, legendGuaranteedFlag: false, rarityRates: { '0': 0, '1': 7000, '2': 2300, '3': 500, '4': 200 }, pool: [0,2,3,4,5,11,12,14,197,184,375,726,831] }
    };
    const itemMaster = {
        0: { name: "スピダ", rarity: 1 }, 2: { name: "ネコボン", rarity: 2 }, 3: { name: "ニャンピュ", rarity: 1 }, 4: { name: "おかめ", rarity: 2 }, 5: { name: "スニャ", rarity: 2 },
        10: { name: "5千XP", rarity: 0 }, 11: { name: "1万XP", rarity: 1 }, 12: { name: "3万XP", rarity: 1 }, 14: { name: "10万XP", rarity: 2 }, 18: { name: "200万XP", rarity: 4 },
        197: { name: "100万XP", rarity: 4 }, 184: { name: "ミスターニンジャ", rarity: 3 }, 375: { name: "記念ネコ", rarity: 3 }, 381: { name: "ねこ農家", rarity: 3 },
        689: { name: "石の上にも10年ネコ", rarity: 3 }, 726: { name: "ネコメダル王", rarity: 3 }, 831: { name: "スカーフにゃんこ", rarity: 3 }
    };

    const DEFAULT_PARAMS = {
        gacha: '45', // Assuming '45' is the latest/default gacha based on the provided master data
        seed: '123456789',
        ng: 'none',
        fs: 'none',
        lr: null,
        comp: false,
        tx: false,
        roll: 100,
        displaySeed: '0' // デフォルト値
    };

    // --- ユーティリティ関数 ---

    /**
     * URLクエリパラメーターを生成します。
     * displaySeed='0' の場合はパラメーターから除外します。
     * @param {Object} p - パラメーターオブジェクト
     * @returns {string} - クエリ文字列 (?...)
     */
    function generateUrlQuery(p) {
        const query = new URLSearchParams();
        for (const key in p) {
            // displaySeed=0 の場合にクエリから除外する
            if (key === 'displaySeed' && p[key] === DEFAULT_PARAMS.displaySeed) {
                continue; 
            }
            if (p[key] !== null && p[key] !== undefined) {
                 query.set(key, p[key]);
            }
        }
        return '?' + query.toString();
    }
    
    function xorshift32(seed) {
        let x = seed;
        x ^= x << 13; x ^= x >>> 17; x ^= x << 15;
        return x >>> 0;
    }
    function setupGachaRarityItems() {
        for (const gachaId in gachaMaster) {
            const gacha = gachaMaster[gachaId];
            if (gacha && gacha.pool) {
                gacha.rarityItems = { '0': [], '1': [], '2': [], '3': [], '4': [] };
                for (const itemId of gacha.pool) {
                    const item = itemMaster[itemId];
                    if (item && gacha.rarityItems[item.rarity] !== undefined) {
                        gacha.rarityItems[item.rarity].push(itemId);
                    }
                }
                for (const rarity in gacha.rarityItems) gacha.rarityItems[rarity].sort((a, b) => a - b);
            }
        }
    }
    // --- ▼ 修正 (4): ハイライト計算・適用ロジック追加 ▼ ---
    /**
     * レンダリングされたセルのHTML文字列にクラスを追加します。
     * @param {string} cellHtml - 1つ以上の <td>...</td> を含むHTML文字列
     * @param {string} className - 追加するクラス名 (空の場合は何もしない)
     * @returns {string} - クラスが追加されたHTML文字列
     */
    function addClassToCell(cellHtml, className) {
        if (!className) return cellHtml;
        // <td> で始まる最初のタグにクラスを追加します (colspan対応)
        return cellHtml.replace(/<td/, `<td class="${className}"`);
    }
    /**
     * レンダリングされたセルのHTML文字列の最後の<td>にクラスを追加します。
     * @param {string} cellHtml - 1つ以上の <td>...</td> を含むHTML文字列
     * @param {string} className - 追加するクラス名 (空の場合は何もしない)
     * @returns {string} - クラスが追加されたHTML文字列
     */
    function addClassToLastCell(cellHtml, className) {
        if (!className) return cellHtml;
        const lastTdIndex = cellHtml.lastIndexOf('<td');
        if (lastTdIndex === -1) return cellHtml; // No <td> found
        return cellHtml.substring(0, lastTdIndex) + cellHtml.substring(lastTdIndex).replace(/<td/, `<td class="${className}"`);
    }
    /**
     * コンプ済みガチャの1ロール分のシミュレーションを行います（ハイライトパス計算用）。
     * @param {number} startSeedIndex - このロールの開始シードIndex (S1)
     * @param {number} lastItemId - 直前のロールのアイテムID (レア被り判定用)
     * @param {number[]} SEED - シード配列
     * @param {object} gacha - ガチャのマスターデータ
     * @param {function} getRarityFromRoll - レアリティ判定関数
     * @returns {{nextSeedIndex: number, newItemId: number, address: number}}
     */
    function calculateCompletedRoll(startSeedIndex, lastItemId, SEED, gacha, getRarityFromRoll, forceDetails = false) { // forceDetails is now always on for completed gacha
        const details = [];
        // 少なくともS1, S2 が必要
        if (startSeedIndex + 1 >= SEED.length) {
            return { nextSeedIndex: startSeedIndex + 2, newItemId: -1, address: startSeedIndex, reRollFlag: false, details: [], itemSeed: 0 };
        }
        
        const s1 = SEED[startSeedIndex];
        const s2 = SEED[startSeedIndex + 1];
        const rarityResult = getRarityFromRoll(s1 % 10000);
        const rarityName = rarityResult.name;
        const rarityId = rarityResult.id;
        const pool = gacha.rarityItems[rarityId] || [];
        
        details.push({ type: 'rarity', seedIndex: startSeedIndex, seedValue: s1, roll: s1 % 10000, result: rarityName });

        let regularItemId = -1;
        let regularSlot = null;
        if (pool.length > 0) {
            regularSlot = s2 % pool.length;
            regularItemId = pool[regularSlot];
            const regularItemName = itemMaster[regularItemId]?.name || '---';
            details.push({ type: 'slot', seedIndex: startSeedIndex + 1, seedValue: s2, poolSize: pool.length, roll: regularSlot, result: regularSlot, itemName: regularItemName, itemSeedIndex: startSeedIndex + 1 });
        } else {
            details.push({ type: 'slot', seedIndex: startSeedIndex + 1, seedValue: s2, poolSize: 0, roll: null, result: null, itemName: '---', itemSeedIndex: startSeedIndex + 1 });
        }

        const canReRoll = rarityId === 1 && pool.length >= 2;
        const reRollFlag = canReRoll && regularItemId !== -1 && regularItemId === lastItemId;
        
        let finalItemId = regularItemId;
        let nextSeedIndex = startSeedIndex + 2; // s1, s2 の2シード消費
        let itemSeedIndex = startSeedIndex + 1;

        if (reRollFlag) {
            // レア被り時、S3 が必要
            if (startSeedIndex + 2 < SEED.length) {
                const s3 = SEED[startSeedIndex + 2];
                const reRollPool = pool.filter(id => id !== lastItemId);
                if (reRollPool.length > 0) {
                    const reRollSlot = s3 % reRollPool.length;
                    finalItemId = reRollPool[reRollSlot];
                    const reRollItemName = itemMaster[finalItemId]?.name || '---';
                    details.push({ type: 'reroll', seedIndex: startSeedIndex + 2, seedValue: s3, poolSize: reRollPool.length, roll: reRollSlot, result: reRollSlot, itemName: reRollItemName, itemSeedIndex: startSeedIndex + 2 });
                }
                nextSeedIndex = startSeedIndex + 3; // s1, s2, s3 の3シード消費
                itemSeedIndex = startSeedIndex + 2;
            }
        } else if (forceRerollMode && canReRoll) {
             // 強制再抽選モード時も、S3 を消費する
            if (startSeedIndex + 2 < SEED.length) {
                nextSeedIndex = startSeedIndex + 3; // s1, s2, s3 の3シード消費
                // finalItemId は変わらない (表示のみのため)
            }
        }

        return { nextSeedIndex: nextSeedIndex, newItemId: finalItemId, address: startSeedIndex, reRollFlag: reRollFlag, details: details, itemSeedIndex: itemSeedIndex };
    }
    // --- ▲ 修正 (4) 完了 ▲ ---
    // --- 表示ロジック ---
    // --- 未コンプガチャの計算と表示 ---
    function calculateUncompletedCell(startSeedIndex, lastItemId, gacha, SEED, getRarityFromRoll, getAddressString, forceRerollMode, displaySeed, params) {
        // This function calculates the result for a single cell and returns its HTML and the resulting item ID.
        // Guard against running out of seeds
        if (startSeedIndex + 4 >= SEED.length) {
            return { html: '<td colspan="5"></td>', newItemId: -1 };
        }
        const s1 = SEED[startSeedIndex];
        const featuredFlag = (s1 % 10000) < gacha.featuredItemRate;
        let finalItemId;
        let html;
        let sub5;

        if (featuredFlag) {
            finalItemId = -2; // 目玉
            const nextSeedIndex = startSeedIndex + 1;
            const href = generateItemLink(s1, -2); // 目玉は s1 が最後のSEED
            sub5 = `${getAddressString(nextSeedIndex)})<span class="featuredItem-text"><a href="${href}">目玉</a></span>`;
            if (displaySeed === '1') {
                const sub1 = `(S${startSeedIndex})${s1}<br>${s1 % 10000}<br>${featuredFlag}`;
                html = `<td>${sub1}</td><td>---</td><td>---</td><td>---</td><td>${sub5}</td>`;
            }
        } else {
            const s2 = SEED[startSeedIndex + 1];
            const s3 = SEED[startSeedIndex + 2];
            const rarityResult = getRarityFromRoll(s2 % 10000);
            const rarityId = rarityResult.id;
            const pool = gacha.rarityItems[rarityId] || [];
            let regularItemId = -1;
            let regularSlot = null;
            let regularItemName = '---';
            if (pool.length > 0) {
                regularSlot = s3 % pool.length;
                regularItemId = pool[regularSlot];
                regularItemName = itemMaster[regularItemId]?.name || '---';
            }
            finalItemId = regularItemId;
            const canReRoll = rarityId === 1 && pool.length >= 2;
            const reRollFlag = canReRoll && regularItemId !== -1 && regularItemId === lastItemId;
            
            let reRollLine = '';
            let reRollItemNameForDisplay = null;
            let reRollSeed = null;
            let reRollItemId;


            if (reRollFlag) {
                const s_reroll_idx = startSeedIndex + 3;
                reRollSeed = SEED[s_reroll_idx];
                const reRollPool = pool.filter(id => id !== lastItemId);
                if (reRollPool.length > 0) {
                    const reRollSlot = reRollSeed % reRollPool.length;
                    reRollItemId = reRollPool[reRollSlot];
                    reRollItemNameForDisplay = itemMaster[reRollItemId]?.name || '---';
                    finalItemId = reRollItemId;
                }
            } else if (forceRerollMode && canReRoll) {
                const reRollPool = pool.filter(id => id !== regularItemId);
                if (reRollPool.length > 0) {
                    const s_reroll_idx = startSeedIndex + 3;
                    reRollSeed = SEED[s_reroll_idx];
                    const reRollSlot = reRollSeed % reRollPool.length;
                    reRollItemId = reRollPool[reRollSlot];
                    reRollItemNameForDisplay = itemMaster[reRollItemId]?.name || '---';
                }
            }

            // Styling & Linking
            let styledRegularName = regularItemName;
            if (regularItemId !== -1) {
                const href = generateItemLink(s3, regularItemId); // 通常抽選は s3 が最後のSEED
                let nameWithLink = `<a href="${href}">${regularItemName}</a>`;
                if (itemMaster[regularItemId]?.rarity >= 3) {
                    styledRegularName = `<span class="featuredItem-text">${nameWithLink}</span>`;
                } else {
                    styledRegularName = nameWithLink;
                }
            }
            const regularLine = styledRegularName;

            if (reRollItemNameForDisplay) {
                const href = generateItemLink(reRollSeed, reRollItemId); // 再抽選は reRollSeed (s4) が最後のSEED
                let styledRerollName = `<a href="${href}">${reRollItemNameForDisplay}</a>`;
                if (reRollItemId && itemMaster[reRollItemId]?.rarity >= 3) {
                    styledRerollName = `<span class="featuredItem-text">${styledRerollName}</span>`;
                }
                reRollLine = `<br>${getAddressString(startSeedIndex + 4)})${styledRerollName}`;
            }
            
            sub5 = regularLine + reRollLine;

            if (displaySeed === '1') {
                const sub1 = `(S${startSeedIndex})${s1}<br>${s1 % 10000}<br>${featuredFlag}`;
                const sub2 = `(S${startSeedIndex + 1})${s2}<br>${s2 % 10000}<br>${rarityResult.name || ''}`;
                const sub3 = `(S${startSeedIndex + 2})${s3}<br>${pool.length || 1}<br>${regularSlot ?? ''}`;
                let sub4 = '---';
                if (reRollFlag || (forceRerollMode && canReRoll)) {
                    const s_reroll_idx = startSeedIndex + 3;
                    const s_reroll = SEED[s_reroll_idx];
                    const reRollPool = pool.filter(id => id !== (reRollFlag ? lastItemId : regularItemId));
                    if (reRollPool.length > 0) {
                        const reRollSlot = s_reroll % reRollPool.length;
                        sub4 = `(S${s_reroll_idx})${s_reroll}<br>${reRollPool.length}<br>${reRollSlot}`;
                    }
                }
                html = `<td>${sub1}</td><td>${sub2}</td><td>${sub3}</td><td>${sub4}</td><td>${sub5}</td>`;
            }
        }
        if (displaySeed === '0') {
            html = `<td>${sub5}</td>`;
        }
        return { html, newItemId: finalItemId };
    }
                function calculateUncompletedRoll(startSeedIndex, lastItemId, gacha, SEED, getRarityFromRoll) {
        // Guard against running out of seeds
        if (startSeedIndex + 4 >= SEED.length) {
            return { nextSeedIndex: startSeedIndex + 1, newItemId: -1, reRollFlag: false, address: startSeedIndex };
        }

        const s1 = SEED[startSeedIndex];
        const featuredFlag = (s1 % 10000) < gacha.featuredItemRate;

        if (featuredFlag) {
            // 目玉の場合
            return {
                nextSeedIndex: startSeedIndex + 1,
                newItemId: -2, // 目玉
                reRollFlag: false,
                address: startSeedIndex
            };
        } else {
            // 通常抽選
            const s2 = SEED[startSeedIndex + 1];
            const s3 = SEED[startSeedIndex + 2];
            const rarityResult = getRarityFromRoll(s2 % 10000);
            const rarityId = rarityResult.id;
            const pool = gacha.rarityItems[rarityId] || [];
            
            let regularItemId = -1;
            if (pool.length > 0) {
                regularItemId = pool[s3 % pool.length];
            }

            const canReRoll = rarityId === 1 && pool.length >= 2;
            const reRollFlag = canReRoll && regularItemId !== -1 && regularItemId === lastItemId;

            let finalItemId = regularItemId;
            let nextSeedIndex = startSeedIndex + 3; // s1, s2, s3

            if (reRollFlag) {
                if (startSeedIndex + 3 < SEED.length) {
                    const s4 = SEED[startSeedIndex + 3];
                    const reRollPool = pool.filter(id => id !== lastItemId);
                    if (reRollPool.length > 0) {
                        finalItemId = reRollPool[s4 % reRollPool.length];
                    }
                    nextSeedIndex = startSeedIndex + 4; // s1, s2, s3, s4
                }
            }
            
            return {
                nextSeedIndex: nextSeedIndex,
                newItemId: finalItemId,
                reRollFlag: reRollFlag,
                address: startSeedIndex
            };
        }
    }
                function createAndDisplayUncompletedSeedView(initialSeed, gacha, tableRows, thresholds, initialLastRollId, displaySeed, params) {
                    const SEED = [initialSeed];
                    // Each row consumes up to 4 seeds for 3 cells, plus G column seeds. Buffer generously.
                    for (let i = 1; i < tableRows * 15 + 20; i++) {
                        SEED[i] = xorshift32(SEED[i - 1]);
                    }
                    const getRarityFromRoll = (roll) => {
                        if (roll < thresholds['0']) return { id: 0, name: 'ノーマル' };
                        if (roll < thresholds['1']) return { id: 1, name: 'レア' };
                        if (roll < thresholds['2']) return { id: 2, name: '激レア' };
                        if (roll < thresholds['3']) return { id: 3, name: '超激レア' };
                        return { id: 4, name: '伝説レア' };
                    };
                    const getAddressString = (n) => {
                        if (n <= 0) return '';
                        const zeroBasedIndex = n - 1;
                        const col_char = String.fromCharCode('A'.charCodeAt(0) + (zeroBasedIndex % 3));
                        const row_num = Math.floor(zeroBasedIndex / 3) + 1;
                        return `${row_num}${col_char}`;
                    };
                    const getAddressStringForG = (n) => {
                        if (n <= 0) return '';
                        const zeroBasedIndex = n - 1;
                        const col_char = String.fromCharCode('A'.charCodeAt(0) + (zeroBasedIndex % 3));
                        const row_num = Math.floor(zeroBasedIndex / 3) + 1;
                        return `${col_char}${row_num}`;
                    };

                    let table = '<table style="table-layout: fixed;"><thead>';
                    let header1 = `<tr><th rowspan="${displaySeed === '1' ? 2 : 1}" id="forceRerollToggle" class="col-no" style="cursor: pointer;">${forceRerollMode ? '☑' : '□'}</th>`;
                    let header2 = '<tr>';
            
                    if (displaySeed === '1') {
                        header1 += '<th colspan="5">A</th><th colspan="5">B</th><th colspan="5">C</th><th colspan="5">G</th>';
                        const subHeaders = ['S1<br>Featured', 'S2<br>Rarity', 'S3<br>Slot', 'S4<br>ReRoll', 'Item<br>Next'];
                        for(let i=0; i<4; i++) header2 += subHeaders.map(h => `<th>${h}</th>`).join('');
                    } else {
                        header1 += '<th>A</th><th>B</th><th>C</th><th>G</th>';
                    }
                    header1 += '</tr>';
                    if (displaySeed === '1') {
                        header2 += '</tr>';
                        table += header1 + header2;
                    } else {
                        table += header1;
                    }
                    table += '</thead><tbody>';
                    
                    let lastItemA = initialLastRollId;
                    let lastItemB = initialLastRollId;
                    let lastItemC = initialLastRollId;
                    let lastGuaranteedItemId = initialLastRollId;

                    let gSeedCounter = 11; // G column seeds start from S11
            
                    for (let r = 0; r < tableRows; r++) {
                        table += `<tr><td class="col-no">${r + 1}</td>`;
                        
                        // Cell A, B, C
                        const cellA = calculateUncompletedCell(r * 3 + 1, lastItemA, gacha, SEED, getRarityFromRoll, getAddressString, forceRerollMode, displaySeed, params);
                        lastItemA = cellA.newItemId; // A列のIDを更新
                        table += cellA.html;
                        const cellB = calculateUncompletedCell(r * 3 + 2, lastItemB, gacha, SEED, getRarityFromRoll, getAddressString, forceRerollMode, displaySeed, params);
                        lastItemB = cellB.newItemId; // B列のIDを更新
                        table += cellB.html;
                        const cellC = calculateUncompletedCell(r * 3 + 3, lastItemC, gacha, SEED, getRarityFromRoll, getAddressString, forceRerollMode, displaySeed, params);
                        lastItemC = cellC.newItemId; // C列のIDを更新
                        table += cellC.html;

                        // G column calculation
                        const rollNumber = r + 1;
                        if (rollNumber > 10) {
                             table += `<td colspan="${displaySeed === '1' ? 5 : 1}"></td>`;
                             table += '</tr>';
                             continue;
                        }
                        
                        const s_feat_idx = rollNumber;
                        const s_feat = SEED[s_feat_idx];
                        const feat_roll = s_feat % 10000;
                        const is_featured = feat_roll < gacha.featuredItemRate;
                        
                        let g_sub5 = '---';
                        let finalItemId;
                        let g_sub1, g_sub2 = '---', g_sub3 = '---', g_sub4 = '---';

                        if (is_featured) {
                            finalItemId = -2;
                            const href = generateItemLink(s_feat, -2); // G列目玉は s_feat が最後のSEED
                            g_sub5 = `<span class="featuredItem-text"><a href="${href}">目玉</a></span>`;
                        } else {
                            const s_rarity_idx = gSeedCounter;
                            const s_slot_idx = gSeedCounter + 1;
                            const s_rarity = SEED[s_rarity_idx];
                            const rarity_roll = s_rarity % 10000;
                            const rarityResult = getRarityFromRoll(rarity_roll);
                            const s_slot = SEED[s_slot_idx];
                            const pool = gacha.rarityItems[rarityResult.id] || [];
                            const poolSize = pool.length;
                            const slot = poolSize > 0 ? s_slot % poolSize : 0;
                            const regularItemId = poolSize > 0 ? pool[slot] : -1;
                            let regularItemName = regularItemId !== -1 ? itemMaster[regularItemId]?.name : '---';
                            finalItemId = regularItemId;
                            
                            const canReRoll = rarityResult.id === 1 && poolSize >= 2;
                            const reRollFlag = canReRoll && regularItemId !== -1 && regularItemId === lastGuaranteedItemId;
                            let reRollItemName = null;
                            let reRollSeed = null;
                            let reRollItemId;


                            if (reRollFlag) {
                                const s_reroll_idx = gSeedCounter + 2;
                                reRollSeed = SEED[s_reroll_idx];
                                const reRollPool = pool.filter(id => id !== lastGuaranteedItemId);
                                const reRollPoolSize = reRollPool.length;
                                if (reRollPoolSize > 0) {
                                    const reRollSlot = reRollSeed % reRollPoolSize;
                                    reRollItemId = reRollPool[reRollSlot];
                                    reRollItemName = reRollItemId !== -1 ? itemMaster[reRollItemId]?.name : '---';
                                    finalItemId = reRollItemId;
                                }
                            }
                            
                            gSeedCounter += 2 + (reRollFlag ? 1 : 0);

                            let styledRegularName = regularItemName;
                            if(regularItemId !== -1) {
                                const href = generateItemLink(s_slot, regularItemId); // G列通常は s_slot が最後のSEED
                                let nameWithLink = `<a href="${href}">${regularItemName}</a>`;
                                if(itemMaster[regularItemId]?.rarity >= 3) {
                                    styledRegularName = `<span class="featuredItem-text">${nameWithLink}</span>`;
                                } else {
                                    styledRegularName = nameWithLink;
                                }
                            }

                            let reRollLine = '';
                            if(reRollItemName) {
                                const href = generateItemLink(reRollSeed, reRollItemId); // G列再抽選は reRollSeed が最後のSEED
                                let styledRerollName = `<a href="${href}">${reRollItemName}</a>`;
                                if (reRollItemId && itemMaster[reRollItemId]?.rarity >= 3) {
                                    styledRerollName = `<span class="featuredItem-text">${styledRerollName}</span>`;
                                }
                                reRollLine = `<br>${styledRerollName}`;
                            }

                            const finalItemNameG = reRollItemName || regularItemName;
                            if (rollNumber < 10) {
                                g_sub5 = styledRegularName + reRollLine;
                            } else {
                                const destinationSeedIndex = is_featured ? (s_feat_idx + 1) : gSeedCounter;
                                const destinationAddress = getAddressStringForG(destinationSeedIndex);
                                const finalItemIdForStyle = Object.keys(itemMaster).find(key => itemMaster[key].name === finalItemNameG);
                                const finalHref = generateItemLink(reRollSeed || s_slot, finalItemIdForStyle);
                                let finalStyledName = `<a href="${finalHref}">${finalItemNameG}</a>`;
                                if(finalItemIdForStyle && itemMaster[finalItemIdForStyle]?.rarity >= 3) {
                                     finalStyledName = `<span class="featuredItem-text">${finalStyledName}</span>`;
                                }
                                g_sub5 = `${destinationAddress})${finalStyledName}`;
                            }

                            if (displaySeed === '1') {
                                g_sub2 = `(S${s_rarity_idx})${s_rarity}<br>${rarity_roll}<br>${rarityResult.name}`;
                                g_sub3 = `(S${s_slot_idx})${s_slot}<br>${poolSize}<br>${slot}`;
                                if (reRollFlag) {
                                    const s_reroll_idx = gSeedCounter - 1;
                                    const s_reroll = SEED[s_reroll_idx];
                                    const reRollPool = pool.filter(id => id !== lastGuaranteedItemId);
                                    g_sub4 = `(S${s_reroll_idx})${s_reroll}<br>${reRollPool.length}<br>${s_reroll % reRollPool.length}`;
                                }
                            }
                        }
                        
                        if (displaySeed === '1') {
                            g_sub1 = `(S${s_feat_idx})${s_feat}<br>${feat_roll}<br>${is_featured}`;
                            table += `<td>${g_sub1}</td><td>${g_sub2}</td><td>${g_sub3}</td><td>${g_sub4}</td><td>${g_sub5}</td>`;
                        } else {
                            table += `<td>${g_sub5}</td>`;
                        }
                        lastGuaranteedItemId = finalItemId;
                        table += '</tr>';
                    }
                    table += '</tbody></table>';
                    document.getElementById('result-table-container').innerHTML = table;
                }    // --- コンプ済みガチャの計算と表示 ---
    function calculateCompletedCell(startSeedIndex, lastItemId, gacha, SEED, getRarityFromRoll, getAddressString, forceRerollMode, displaySeed, params, ngForDisplay, initialInputNg, rollNumber) {
        let finalItemId = -1;
        let html;
        let sub4;

        if (startSeedIndex + 3 >= SEED.length) {
            return { html: (displaySeed === '1') ? '<td colspan="4"></td>' : '<td></td>', newItemId: -1, details: [], itemSeed: 0 };
        }

        const details = [];
        const s1 = SEED[startSeedIndex];
        const s2 = SEED[startSeedIndex + 1];
        const s3 = SEED[startSeedIndex + 2];
        const rarityResult = getRarityFromRoll(s1 % 10000);
        const rarityName = rarityResult.name;
        const rarityId = rarityResult.id;
        const pool = gacha.rarityItems[rarityId] || [];

        details.push(`{(S${startSeedIndex})${s1}, ${s1 % 10000},${rarityName}}`);

        let regularItemId = -1;
        let regularItemName = '---';
        let regularSlot = null;
        if (pool.length > 0) {
            regularSlot = s2 % pool.length;
            regularItemId = pool[regularSlot];
            regularItemName = itemMaster[regularItemId]?.name || '---';
        }
        details.push(`{(S${startSeedIndex + 1})${s2}, ${pool.length}, ${s2 % pool.length}, (slot)${regularSlot !== null ? regularSlot : ''}}`);
        finalItemId = regularItemId;
        const canReRoll = rarityId === 1 && pool.length >= 2;
        const reRollFlag = canReRoll && regularItemId !== -1 && regularItemId === lastItemId;
        
        let reRollLine = '';
        let reRollItemNameForDisplay = null;
        let reRollItemId;
        let itemSeed = s2;


        if (reRollFlag) {
            const reRollPool = pool.filter(id => id !== lastItemId);
            if (reRollPool.length > 0) {
                const reRollSlot = s3 % reRollPool.length;
                reRollItemId = reRollPool[reRollSlot];
                reRollItemNameForDisplay = itemMaster[reRollItemId]?.name || '---';
                finalItemId = reRollItemId;
                itemSeed = s3;
                details.push(`{(S${startSeedIndex + 2})${s3}, ${reRollPool.length}, ${s3 % reRollPool.length}, (ReRollSlot)${reRollSlot}}`);
            }
        } else if (forceRerollMode && canReRoll) {
            const reRollPool = pool.filter(id => id !== regularItemId);
            if (reRollPool.length > 0) {
                reRollItemId = reRollPool[s3 % reRollPool.length];
                reRollItemNameForDisplay = itemMaster[reRollItemId]?.name || '---';
            }
        }
        
        let styledRegularName = regularItemName;
        if (regularItemId !== -1) {
            const href = generateItemLink(s2, regularItemId, initialInputNg, rollNumber, true); // Added initialInputNg, rollNumber
            let nameWithLink = `<a href="${href}">${regularItemName}</a>`;
            if (itemMaster[regularItemId]?.rarity >= 3) {
                styledRegularName = `<span class="featuredItem-text">${nameWithLink}</span>`;
            } else {
                styledRegularName = nameWithLink;
            }
        }
        const regularLine = styledRegularName;

        if (reRollItemNameForDisplay) {
            const href = generateItemLink(s3, reRollItemId, initialInputNg, rollNumber, true); // Added initialInputNg, rollNumber
            let styledRerollName = `<a href="${href}">${reRollItemNameForDisplay}</a>`;
            if (reRollItemId && itemMaster[reRollItemId]?.rarity >= 3) {
                styledRerollName = `<span class="featuredItem-text">${styledRerollName}</span>`;
            }
            reRollLine = `<br>${getAddressString(startSeedIndex + 3)})${styledRerollName}`;
        }

        sub4 = regularLine + reRollLine;

        if (displaySeed === '1') {
            const sub1 = `(S${startSeedIndex})${s1}<br>${s1 % 10000}<br>${rarityName || ''}`;
            const sub2 = pool.length > 0 ? `(S${startSeedIndex + 1})${s2}<br>${pool.length}<br>${s2 % pool.length}` : '---';
            let sub3 = '---';
            if (reRollFlag || (forceRerollMode && canReRoll)) {
                const reRollPool = pool.filter(id => id !== (reRollFlag ? lastItemId : regularItemId));
                if (reRollPool.length > 0) {
                    sub3 = `(S${startSeedIndex + 2})${s3}<br>${reRollPool.length}<br>${s3 % reRollPool.length}`;
                }
            }
            html = `<td>${sub1}</td><td>${sub2}</td><td>${sub3}</td><td>${sub4}</td>`;
        } else {
            html = `<td>${sub4}</td>`;
        }
        return { html, newItemId: finalItemId, details, itemSeed };
    }
    function calculateGuaranteedCell(startSeedIndex, gacha, SEED, displaySeed, params, ngForDisplay, initialInputNg, rollNumber) {
        if (!gacha.uberGuaranteedFlag && !gacha.legendGuaranteedFlag) {
            const emptyHtml = (displaySeed === '1') ? '<td colspan="3"></td>' : '<td></td>';
            return { html: emptyHtml, simpleHtml: emptyHtml, itemId: -1, itemName: '', seedForLink: 0 };
        }
        const uberRate = gacha.uberGuaranteedFlag ? (gacha.rarityRates['3'] || 0) : 0;
        const legendRate = gacha.legendGuaranteedFlag ? (gacha.rarityRates['4'] || 0) : 0;
        const rarityDivisor = uberRate + legendRate;
        if (rarityDivisor === 0) {
            const msg = 'レート設定なし';
            const errorHtml = (displaySeed === '1') ? `<td colspan="3">${msg}</td>` : `<td>${msg}</td>`;
            return { html: errorHtml, simpleHtml: errorHtml, itemId: -1, itemName: msg, seedForLink: 0 };
        }
        const s_rarity_idx = startSeedIndex;
        const s_slot_idx = startSeedIndex + 1;
        if (s_slot_idx >= SEED.length) {
            const emptyHtml = (displaySeed === '1') ? '<td colspan="3">---</td>' : '<td>---</td>';
            return { html: emptyHtml, simpleHtml: emptyHtml, itemId: -1, itemName: '---', seedForLink: 0 };
        }
        const s_rarity = SEED[s_rarity_idx];
        const s_slot = SEED[s_slot_idx];
        const rarityRoll = s_rarity % rarityDivisor;
        
        let rarityId, rarityName;
        if (rarityRoll < uberRate) {
            rarityId = '3';
            rarityName = '超激レア';
        } else {
            rarityId = '4';
            rarityName = '伝説レア';
        }
        const pool = gacha.rarityItems[rarityId];
        if (!pool || pool.length === 0) {
            const msg = `${rarityName}プールなし`;
            const errorHtml = (displaySeed === '1') ? `<td colspan="3">${msg}</td>` : `<td>${msg}</td>`;
            return { html: errorHtml, simpleHtml: errorHtml, itemId: -1, itemName: msg, seedForLink: 0 };
        }
        const poolSize = pool.length;
        const slot = s_slot % poolSize;
        const itemId = pool[slot];
        
        const itemName = itemMaster[itemId]?.name || '---';

        const col3Text = itemName;

        let fullHtml, simpleHtml;
        if (displaySeed === '0') {
            simpleHtml = `<td>${col3Text}</td>`;
            fullHtml = ''; // Not needed but to be consistent
        } else {
            const col1 = `(S${s_rarity_idx})${s_rarity}<br>${rarityRoll}<br>${rarityName}`;
            const col2 = `(S${s_slot_idx})${s_slot}<br>${poolSize}<br>${slot}`;
            fullHtml = `<td>${col1}</td><td>${col2}</td><td>${col3Text}</td>`;
            simpleHtml = `<td>${col3Text}</td>`;
        }

        return {
            html: fullHtml,
            simpleHtml: simpleHtml,
            itemId: itemId,
            itemName: itemName,
            seedForLink: s_slot
        };
    }
    // --- ▼ 修正 (5): ハイライトロジックの組み込み (デュアルハイライト対応) ▼ ---
    function createAndDisplayCompletedSeedView(initialSeed, gacha, tableRows, thresholds, initialLastRollId, displaySeed, params) {
        const SEED = [initialSeed];
        for (let i = 1; i < tableRows * 2 * 3 + 20; i++) {
            SEED[i] = xorshift32(SEED[i - 1]);
        }
        const getRarityFromRoll = (roll) => {
            if (roll < thresholds['0']) return { id: 0, name: 'ノーマル' };
            if (roll < thresholds['1']) return { id: 1, name: 'レア' };
            if (roll < thresholds['2']) return { id: 2, name: '激レア' };
            if (roll < thresholds['3']) return { id: 3, name: '超激レア' };
            return { id: 4, name: '伝説レア' };
        };
        const getAddressString = (n) => {
            if (n <= 0) return '';
            const zeroBasedIndex = n - 1;
            const col_char = String.fromCharCode('A'.charCodeAt(0) + (zeroBasedIndex % 2));
            const row_num = Math.floor(zeroBasedIndex / 2) + 1;
            return `${row_num}${col_char}`;
        };

        // --- ▼ 新しいハイライトパス計算ロジック ▼ ---

        function calculateGuaranteedRoll(raritySeedIndex, slotSeedIndex, gacha, SEED) {
            const result = {
                details: [],
                newItemId: -1,
                nextSeedIndex: slotSeedIndex + 1, // Default consumption
                itemSeedIndex: slotSeedIndex
            };
            if (!gacha.uberGuaranteedFlag && !gacha.legendGuaranteedFlag) {
                return result;
            }
            const uberRate = gacha.uberGuaranteedFlag ? (gacha.rarityRates['3'] || 0) : 0;
            const legendRate = gacha.legendGuaranteedFlag ? (gacha.rarityRates['4'] || 0) : 0;
            const rarityDivisor = uberRate + legendRate;
            if (rarityDivisor === 0 || raritySeedIndex >= SEED.length || slotSeedIndex >= SEED.length) {
                return result;
            }
            const s_rarity = SEED[raritySeedIndex];
            const s_slot = SEED[slotSeedIndex];
            const rarityRoll = s_rarity % rarityDivisor;
            const rarityId = (rarityRoll < uberRate) ? '3' : '4';
            const rarityName = (rarityId === '3') ? '超激レア' : '伝説レア';
            
            result.details.push({ type: 'guaranteed_rarity', seedIndex: raritySeedIndex, seedValue: s_rarity, divisor: rarityDivisor, roll: rarityRoll, result: rarityName });

            const pool = gacha.rarityItems[rarityId];
            if (!pool || pool.length === 0) {
                return result;
            }
            const slot = s_slot % pool.length;
            const itemId = pool[slot];
            const itemName = itemMaster[itemId]?.name || '---';

            result.details.push({ type: 'guaranteed_slot', seedIndex: slotSeedIndex, seedValue: s_slot, poolSize: pool.length, roll: slot, result: slot, itemName: itemName, itemSeedIndex: slotSeedIndex });
            result.newItemId = itemId;
            // nextSeedIndex and itemSeedIndex are already set correctly
            return result;
        }

        // --- Declarations of singleRollMap and tenPullRollMap ---
        const singleRollMap = new Map();
        const tenPullRollMap = new Map();
        
        // --- ▼ 計算過程を格納する配列 ▼ ---
        const singleRollProcess = [];
        const tenPullRollProcess = [];
        // --- ▲ 計算過程を格納する配列 ▲ ---

        const MAX_ROLLS = tableRows * 2;

        const nextGuaranteed = parseInt(document.getElementById('guaranteedRollsInput').value, 10);
        const hasGuaranteed = !isNaN(nextGuaranteed);
        
        // Helper function to calculate ng for a cell
        const calculateNgForCell = (prevNg, is10Pull10RollPeriodic, inputNg) => {
            if (!hasGuaranteed) return 'none'; // If no input ng, then no ng for cells

            let calculatedNg = (prevNg - 1 < 1) ? 10 : prevNg - 1;

            if (is10Pull10RollPeriodic) {
                return inputNg; // Override with input ng for 10-pull 10-roll periodic
            }
            return calculatedNg;
        };

        let ngValuePrev = hasGuaranteed ? nextGuaranteed : 'none'; // Initialize for the first cell

        // 1. 単発ロールパス
        let currentSeedIndexSingle = 1;
        let currentLastItemIdSingle = initialLastRollId;
        let previousRollWasGuaranteedSingle = false;
        for (let i = 1; i <= MAX_ROLLS; i++) {
            if (currentSeedIndexSingle >= SEED.length) break;
            const isGuaranteedRoll = hasGuaranteed && i >= nextGuaranteed && (i - nextGuaranteed) % 10 === 0;
            
            const processInfo = { roll: i, isGuaranteed: isGuaranteedRoll };

            if (isGuaranteedRoll) {
                singleRollMap.set(currentSeedIndexSingle, i);
                processInfo.address = getAddressString(currentSeedIndexSingle) + 'G';
                processInfo.startSeedIndex = currentSeedIndexSingle;

                // 単発の場合、レアリティとスロットのSEEDは連続している
                const rollData = calculateGuaranteedRoll(currentSeedIndexSingle, currentSeedIndexSingle + 1, gacha, SEED);
                processInfo.details = rollData.details;
                processInfo.itemSeedIndex = rollData.itemSeedIndex;

                currentSeedIndexSingle += 2; // 確定枠は常に2つ消費
                currentLastItemIdSingle = rollData.newItemId;
                previousRollWasGuaranteedSingle = true;
            } else {
                const lastItemIdForCheck = previousRollWasGuaranteedSingle ? null : currentLastItemIdSingle;
                const rollData = calculateCompletedRoll(currentSeedIndexSingle, lastItemIdForCheck, SEED, gacha, getRarityFromRoll, true);
                singleRollMap.set(rollData.address, i);
                processInfo.address = getAddressString(rollData.address);
                processInfo.startSeedIndex = rollData.address;
                processInfo.details = rollData.details;
                processInfo.itemSeedIndex = rollData.itemSeedIndex;

                currentSeedIndexSingle = rollData.nextSeedIndex;
                currentLastItemIdSingle = rollData.newItemId;
                previousRollWasGuaranteedSingle = false;
            }
            singleRollProcess.push(processInfo);
        }

        // 2. 10連ロールパス (シーケンシャルモデル + 周期判定)
        if (hasGuaranteed) {
            // 10連確定枠のレアリティ抽選 (S1, S11, S21...)
            const getGuaranteedRarity = (seedIndex, gacha, SEED) => {
                const uberRate = gacha.uberGuaranteedFlag ? (gacha.rarityRates['3'] || 0) : 0;
                const legendRate = gacha.legendGuaranteedFlag ? (gacha.rarityRates['4'] || 0) : 0;
                const rarityDivisor = uberRate + legendRate;
                const rarityRoll_g = SEED[seedIndex] % rarityDivisor;
                return (rarityRoll_g < uberRate) ? { id: '3', name: '超激レア', roll: rarityRoll_g, divisor: rarityDivisor } : { id: '4', name: '伝説レア', roll: rarityRoll_g, divisor: rarityDivisor };
            };
            let seed_counter = 1; // S1から開始
            let currentLastItemId10 = initialLastRollId;
            let guaranteedRarityId = '3'; // 周期ごとに更新される
            let previousRollWasGuaranteed10 = false;
            let raritySeedForThis10PullCycle;

            for (let i = 1; i <= MAX_ROLLS; i++) {
                if (seed_counter >= SEED.length) break;

                const processInfo = { roll: i };

                if ((i - 1) % 10 === 0) {
                    raritySeedForThis10PullCycle = seed_counter; // レアリティ判定用SEEDを保存
                    seed_counter++; // カウンターを進め、通常ロールは次のSEEDから開始
                }

                const isGuaranteedRoll = (i >= nextGuaranteed) && ((i - nextGuaranteed) % 10 === 0);
                processInfo.isGuaranteed = isGuaranteedRoll;

                if (isGuaranteedRoll) {
                    const mapIndex = seed_counter - 1; // スロット判定SEEDの1つ前のSEEDをアドレスとする
                    processInfo.startSeedIndex = mapIndex;
                    processInfo.address = getAddressString(mapIndex) + 'G';

                    // 10連の場合、レアリティとスロットのSEEDは離れている
                    const rollData = calculateGuaranteedRoll(raritySeedForThis10PullCycle, seed_counter, gacha, SEED);
                    processInfo.details = rollData.details;
                    processInfo.itemSeedIndex = rollData.itemSeedIndex;

                    tenPullRollMap.set(mapIndex, i);
                    seed_counter++; // スロットSEEDを1つ消費
                    currentLastItemId10 = rollData.newItemId;
                    previousRollWasGuaranteed10 = true;
                } else {
                    // 確定枠の直後、または通常のロール
                    const lastItemIdForCheck = previousRollWasGuaranteed10 ? null : currentLastItemId10;
                    const rollData = calculateCompletedRoll(seed_counter, lastItemIdForCheck, SEED, gacha, getRarityFromRoll, true);
                    
                    processInfo.address = getAddressString(rollData.address);
                    processInfo.startSeedIndex = rollData.address;
                    processInfo.details = rollData.details;
                    processInfo.itemSeedIndex = rollData.itemSeedIndex;

                    tenPullRollMap.set(rollData.address, i);
                    seed_counter = rollData.nextSeedIndex;
                    currentLastItemId10 = rollData.newItemId;
                    previousRollWasGuaranteed10 = false;
                }
                processInfo.newItemId = currentLastItemId10; // Store the final item for this roll
                tenPullRollProcess.push(processInfo);
            }
        }

        let table = '<table style="table-layout: fixed;"><thead>';
        let header1 = `<tr><th rowspan="${displaySeed === '1' ? 2 : 1}" id="forceRerollToggle" class="col-no" style="cursor: pointer;">${forceRerollMode ? '☑' : '□'}</th>`;
        let header2 = '<tr>';

        if (displaySeed === '1') {
            header1 += '<th colspan="4">A</th><th colspan="3">AG</th><th colspan="4">B</th><th colspan="3">BG</th>';
            const subHeadersA = ['S1<br>Rarity', 'S2<br>Slot', 'S3<br>ReRoll', 'Item<br>Next'];
            const subHeadersAG = ['S1<br>Guaranteed', 'S2<br>Slot', 'Item'];
            header2 += subHeadersA.map(h => `<th>${h}</th>`).join('');
            header2 += subHeadersAG.map(h => `<th>${h}</th>`).join('');
            header2 += subHeadersA.map(h => `<th>${h}</th>`).join('');
            header2 += subHeadersAG.map(h => `<th>${h}</th>`).join('');
        } else {
            header1 += '<th>A</th><th>AG</th><th>B</th><th>BG</th>';
        }
        header1 += '</tr>';
        if (displaySeed === '1') {
            header2 += '</tr>';
            table += header1 + header2;
        } else {
            table += header1;
        }
        table += '</thead><tbody>';
        
        let lastItemA = initialLastRollId;
        let lastItemB = initialLastRollId; // This will no longer be used directly in the loop

        for (let r = 0; r < tableRows; r++) {
            const seedIndexA = r * 2 + 1; // 1, 3, 5, ...
            const seedIndexB = r * 2 + 2;
            
            let classA = '', classAG = '', classB = '', classBG = '';

            // A列のハイライトクラス決定
            const roll_A_single = singleRollMap.has(seedIndexA) ? singleRollMap.get(seedIndexA) : undefined;
            const roll_A_10pull = tenPullRollMap.has(seedIndexA) ? tenPullRollMap.get(seedIndexA) : undefined;
            const rollForA = roll_A_single !== undefined ? roll_A_single : roll_A_10pull;
            const isGuaranteed_A_single = roll_A_single !== undefined && hasGuaranteed && roll_A_single >= nextGuaranteed && (roll_A_single - nextGuaranteed) % 10 === 0;
            const isGuaranteed_A_10pull = roll_A_10pull !== undefined && hasGuaranteed && roll_A_10pull >= nextGuaranteed && (roll_A_10pull - nextGuaranteed) % 10 === 0;

            if (roll_A_single && roll_A_10pull) { // 共通ルート
                const is10th_single = roll_A_single % 10 === 0;
                const is10th_10pull = roll_A_10pull % 10 === 0;
                let overlap_class = 'highlight-roll-overlap'; // 通常の共通ルート色
                if (is10th_10pull) { // 10連ルートの10n回目
                    overlap_class = 'highlight-roll-overlap-10'; // 共通ルート上の10連10n回目は濃い緑色
                }
                // is10th_single の場合は濃い色にしない (ユーザー要求)
                
                if (isGuaranteed_A_single || isGuaranteed_A_10pull) {
                    classAG = overlap_class;
                } else {
                    classA = overlap_class;
                }
            } else if (roll_A_single) { // 単発ルートのみ
                let singleRollClass = 'highlight-roll'; // Default to lighter blue
                if (!hasGuaranteed && (roll_A_single % 10 === 0)) { // Only apply darker blue if no next guaranteed and it's a 10th roll
                    singleRollClass = 'highlight-roll-10';
                }
                if (isGuaranteed_A_single) {
                    classAG = singleRollClass;
                } else {
                    classA = singleRollClass;
                }
            } else if (roll_A_10pull) { // 10連ルートのみ
                if (isGuaranteed_A_10pull) {
                    classAG = (roll_A_10pull % 10 === 0) ? 'highlight-roll-10pull-10' : 'highlight-roll-10pull';
                } else {
                    classA = (roll_A_10pull % 10 === 0) ? 'highlight-roll-10pull-10' : 'highlight-roll-10pull';
                }
            }

            // B列のハイライトクラス決定
            const roll_B_single = singleRollMap.has(seedIndexB) ? singleRollMap.get(seedIndexB) : undefined;
            const roll_B_10pull = tenPullRollMap.has(seedIndexB) ? tenPullRollMap.get(seedIndexB) : undefined;
            const rollForB = roll_B_single !== undefined ? roll_B_single : roll_B_10pull;
            const isGuaranteed_B_single = roll_B_single !== undefined && hasGuaranteed && roll_B_single >= nextGuaranteed && (roll_B_single - nextGuaranteed) % 10 === 0;
            const isGuaranteed_B_10pull = roll_B_10pull !== undefined && hasGuaranteed && roll_B_10pull >= nextGuaranteed && (roll_B_10pull - nextGuaranteed) % 10 === 0;

            if (roll_B_single && roll_B_10pull) { // 共通ルート
                const is10th_single = roll_B_single % 10 === 0;
                const is10th_10pull = roll_B_10pull % 10 === 0;
                let overlap_class = 'highlight-roll-overlap'; // 通常の共通ルート色
                if (is10th_10pull) { // 10連ルートの10n回目
                    overlap_class = 'highlight-roll-overlap-10'; // 共通ルート上の10連10n回目は濃い緑色
                }
                // is10th_single の場合は濃い色にしない (ユーザー要求)

                if (isGuaranteed_B_single || isGuaranteed_B_10pull) {
                    classBG = overlap_class;
                } else {
                    classB = overlap_class;
                }
            } else if (roll_B_single) { // 単発ルートのみ
                let singleRollClass = 'highlight-roll'; // Default to lighter blue
                if (!hasGuaranteed && (roll_B_single % 10 === 0)) { // Only apply darker blue if no next guaranteed and it's a 10th roll
                    singleRollClass = 'highlight-roll-10';
                }
                if (isGuaranteed_B_single) {
                    classBG = singleRollClass;
                } else {
                    classB = singleRollClass;
                }
            } else if (roll_B_10pull) { // 10連ルートのみ
                if (isGuaranteed_B_10pull) {
                    classBG = (roll_B_10pull % 10 === 0) ? 'highlight-roll-10pull-10' : 'highlight-roll-10pull';
                } else {
                    classB = (roll_B_10pull % 10 === 0) ? 'highlight-roll-10pull-10' : 'highlight-roll-10pull';
                }
            }

            // Calculate ng for each cell
            let ngForCellA = 'none';
            let ngForCellAG = 'none';
            let ngForCellB = 'none';
            let ngForCellBG = 'none';

            if (hasGuaranteed) {
                // Cell A
                let is10Pull10RollPeriodicA = roll_A_10pull && (roll_A_10pull % 10 === 0);
                ngForCellA = calculateNgForCell(ngValuePrev, is10Pull10RollPeriodicA, nextGuaranteed);
                
                // Cell AG
                let is10Pull10RollPeriodicAG = (isGuaranteed_A_single || isGuaranteed_A_10pull) && roll_A_10pull && (roll_A_10pull % 10 === 0);
                ngForCellAG = calculateNgForCell(ngForCellA, is10Pull10RollPeriodicAG, nextGuaranteed);

                // Cell B
                let is10Pull10RollPeriodicB = roll_B_10pull && (roll_B_10pull % 10 === 0);
                ngForCellB = calculateNgForCell(ngForCellAG, is10Pull10RollPeriodicB, nextGuaranteed);

                // Cell BG
                let is10Pull10RollPeriodicBG = (isGuaranteed_B_single || isGuaranteed_B_10pull) && roll_B_10pull && (roll_B_10pull % 10 === 0);
                ngForCellBG = calculateNgForCell(ngForCellB, is10Pull10RollPeriodicBG, nextGuaranteed);

                // Update ngValuePrev for the next row
                ngValuePrev = ngForCellBG;
            }

            // --- ▼ 新しい描画ロジック ▼ ---
            // 事前に計算したパス情報から、このセルを描画すべきロールを見つける
            const singleRollA = singleRollProcess.find(p => p.startSeedIndex === seedIndexA && !p.isGuaranteed);
            const tenPullRollA = tenPullRollProcess.find(p => p.startSeedIndex === seedIndexA && !p.isGuaranteed);
            const rollA = singleRollA || tenPullRollA; // どちらかの情報を使う
            const lastItemIdForA = rollA ? (singleRollProcess.find(p => p.roll === rollA.roll - 1)?.newItemId ?? tenPullRollProcess.find(p => p.roll === rollA.roll - 1)?.newItemId ?? initialLastRollId) : initialLastRollId;

            const singleRollB = singleRollProcess.find(p => p.startSeedIndex === seedIndexB && !p.isGuaranteed);
            const tenPullRollB = tenPullRollProcess.find(p => p.startSeedIndex === seedIndexB && !p.isGuaranteed);
            const rollB = singleRollB || tenPullRollB;
            const lastItemIdForB = rollB ? (singleRollProcess.find(p => p.roll === rollB.roll - 1)?.newItemId ?? tenPullRollProcess.find(p => p.roll === rollB.roll - 1)?.newItemId ?? initialLastRollId) : initialLastRollId;

            table += `<tr><td class="col-no">${r + 1}</td>`;
            
            const cellA = calculateCompletedCell(seedIndexA, lastItemIdForA, gacha, SEED, getRarityFromRoll, getAddressString, forceRerollMode, displaySeed, params, ngForCellA, nextGuaranteed, rollForA);
            table += addClassToLastCell(cellA.html, classA);
            
            // AG Cell
            const agData = calculateGuaranteedCell(seedIndexA, gacha, SEED, displaySeed, params, ngForCellAG, nextGuaranteed, rollForA);
            if (agData.itemId !== -1) {
                let agSeed = agData.seedForLink;
                if (classAG === 'highlight-roll-10pull-10') {
                    agSeed = SEED[seedIndexA];
                }
                const agHref = generateItemLink(agSeed, agData.itemId, nextGuaranteed, rollForA, true);
                const agHtml = (displaySeed === '1' ? agData.html : agData.simpleHtml).replace(agData.itemName, `<a href="${agHref}">${agData.itemName}</a>`);
                table += addClassToLastCell(agHtml, classAG);
            } else {
                table += addClassToLastCell(displaySeed === '1' ? agData.html : agData.simpleHtml, classAG);
            }

            const cellB = calculateCompletedCell(seedIndexB, lastItemIdForB, gacha, SEED, getRarityFromRoll, getAddressString, forceRerollMode, displaySeed, params, ngForCellB, nextGuaranteed, rollForB);
            table += addClassToLastCell(cellB.html, classB);

            // BG Cell
            const bgData = calculateGuaranteedCell(seedIndexB, gacha, SEED, displaySeed, params, ngForCellBG, nextGuaranteed, rollForB);
            if (bgData.itemId !== -1) {
                let bgSeed = bgData.seedForLink;
                if (classBG === 'highlight-roll-10pull-10') {
                    bgSeed = SEED[seedIndexB];
                }
                const bgHref = generateItemLink(bgSeed, bgData.itemId, nextGuaranteed, rollForB, true);
                const bgHtml = (displaySeed === '1' ? bgData.html : bgData.simpleHtml).replace(bgData.itemName, `<a href="${bgHref}">${bgData.itemName}</a>`);
                table += addClassToLastCell(bgHtml, classBG);
            } else {
                table += addClassToLastCell(displaySeed === '1' ? bgData.html : bgData.simpleHtml, classBG);
            }
            
            table += '</tr>';
            // --- ▲ 新しい描画ロジック完了 ▲ ---
        }
        table += '</tbody></table>';
        document.getElementById('result-table-container').innerHTML = table;

        // --- ▼ 計算過程の表示ロジック ▼ ---
        if (displaySeed === '1') {
            let detailsHtml = '<div id="calculation-details" style="font-family: monospace; font-size: 11px; line-height: 1.4; margin-top: 15px; padding: 10px; border: 1px solid #ccc; border-radius: 5px; background: #f9f9f9;">';

            const buildProcessString = (processArray) => {
                return processArray.map(p => {
                    let detailsParts = [];
                    let initialPart = `(No.)${p.startSeedIndex},(address)${p.address}`;
                    if (p.isGuaranteed) initialPart += ',(Guaranteed)True';
                    detailsParts.push(initialPart);

                    if (p.details) {
                        p.details.forEach(d => {
                            switch (d.type) {
                                case 'rarity':
                                    detailsParts.push(`(S${d.seedIndex})${d.seedValue}, ${d.roll},${d.result}`);
                                    break; 
                                case 'slot':
                                    detailsParts.push(`(S${d.seedIndex})${d.seedValue},${d.poolSize}, ${d.roll},(slot)${d.result} -> ${d.itemName},(seedParameter=S${d.itemSeedIndex})${SEED[d.itemSeedIndex]}`);
                                    break; 
                                case 'reroll':
                                    detailsParts.push(`(S${d.seedIndex})${d.seedValue},${d.poolSize},${d.roll},(ReRollSlot)${d.result} -> ${d.itemName},(seedParameter=S${d.itemSeedIndex})${SEED[d.itemSeedIndex]}`);
                                    break; 
                                case 'guaranteed_rarity':
                                    detailsParts.push(`(S${d.seedIndex})${d.seedValue}, ${d.seedValue}%${d.divisor},${d.result}`);
                                    break; 
                                case 'guaranteed_slot':
                                    detailsParts.push(`(S${d.seedIndex})${d.seedValue},${d.poolSize}, ${d.seedValue}%${d.poolSize},(slot)${d.result} -> ${d.itemName},(seedParameter=S${d.itemSeedIndex})${SEED[d.itemSeedIndex]}`);
                                    break;
                            }
                        });
                    }

                    // 最終的なアイテム情報を取得
                    const itemId = p.newItemId;
                    if (itemId && itemMaster[itemId]) {
                        const itemSeedValue = SEED[p.itemSeedIndex]; 
                        detailsParts.push(`<strong>(Item)</strong>${itemMaster[itemId].name},(seedParameter=S${p.itemSeedIndex})${itemSeedValue}`);
                    }

                    const nextProcess = processArray.find(next_p => next_p.roll === p.roll + 1);
                    if (nextProcess) {
                        detailsParts.push(`(nextNo.)${nextProcess.startSeedIndex},(nextAddress)${nextProcess.address}`);
                    } 
                    
                    let processHtml = `<strong>Roll${p.roll}：</strong> `;
                    processHtml += detailsParts.join(' ／ ');
                    return processHtml;
                }).join('<br>');
            };

            detailsHtml += '<h3>＜単発ルート＞</h3>' + buildProcessString(singleRollProcess);
            if (hasGuaranteed) detailsHtml += '<h3>＜10連ルート＞</h3>' + buildProcessString(tenPullRollProcess);
            detailsHtml += '</div>'; 
            document.getElementById('result-table-container').insertAdjacentHTML('afterend', detailsHtml);
        }
    }
    // --- ▲ 修正 (5) 完了 ▲ ---
    // --- ディスパッチャー ---
    function createAndDisplaySeedViewNew(initialSeed, gacha, tableRows, isFeaturedComplete, thresholds, initialLastRollId, displaySeed, params, urlGuaranteed) {
        if (isFeaturedComplete) {
            createAndDisplayCompletedSeedView(initialSeed, gacha, tableRows, thresholds, initialLastRollId, displaySeed, params, urlGuaranteed);
        } else {
            createAndDisplayUncompletedSeedView(initialSeed, gacha, tableRows, thresholds, initialLastRollId, displaySeed, params);
        }
    }
    
    // --- ▼ 修正 (1): runSimulationAndDisplay 関数を更新 ▼ ---
    // --- メイン関数 ---
    let activeGachaId;
    function runSimulationAndDisplay(options = {}) {
        const { hideSeedInput = false, uiOverrides = {} } = options;
        const params = new URLSearchParams(window.location.search);
        
        const gachaIds = Object.keys(gachaMaster);
        const latestGachaId = gachaIds.reduce((a, b) => parseInt(a) > parseInt(b) ? a : b);

        // デフォルト値で置き換えるパラメーターの定義
        // --- ▼ 修正: calculation-details の重複表示を防ぐ ▼ ---
        const existingDetails = document.getElementById('calculation-details');
        if (existingDetails) {
            existingDetails.remove();
        }
        // --- ▲ 修正完了 ▲ ---
        const paramDefaults = {
            gacha: latestGachaId,
            seed: DEFAULT_PARAMS.seed,
            ng: DEFAULT_PARAMS.ng,
            fs: DEFAULT_PARAMS.fs,
            comp: DEFAULT_PARAMS.comp.toString(), // 'false'
            tx: DEFAULT_PARAMS.tx ? '1' : '0', // '0'
            roll: DEFAULT_PARAMS.roll.toString(),
            displaySeed: DEFAULT_PARAMS.displaySeed
        };
        
        // 'lr' は特殊。null がデフォルトなので、'undefined' や 'null' 文字列の場合のみ削除する。
        const lrValue = params.get('lr');
        if (lrValue === 'undefined' || lrValue === 'null') {
             params.delete('lr');
        }

        // 'tx' を '1'/'0' に正規化 ( 'true' -> '1', 'false' -> '0' )
        const txValue = params.get('tx');
        if (txValue === 'true') {
            params.set('tx', '1');
        } else if (txValue === 'false') {
            params.set('tx', '0');
        }

        // 'comp' を 'true'/'false' に正規化 ( '1' -> 'true', '0' -> 'false' )
        const compValue = params.get('comp');
        if (compValue === '1') {
            params.set('comp', 'true');
        } else if (compValue === '0') {
             params.set('comp', 'false');
        }
        
        // デフォルト値適用のパラメーターをチェック
        for (const paramName in paramDefaults) {
            const currentValue = params.get(paramName);
            // パラメーターがない(null)、または無効な文字列 ('undefined', 'null', 空白) の場合
            const isMissingOrInvalid = (currentValue === null || currentValue === 'undefined' || currentValue === 'null' || currentValue === '');

            if (isMissingOrInvalid) {
                if (paramName === 'displaySeed' && paramDefaults[paramName] === '0') {
                    continue; 
                }
                params.set(paramName, paramDefaults[paramName]);
            }
        }
        
        // gacha ID がマスターに存在しない場合もデフォルトに
        if (!gachaMaster[params.get('gacha')]) {
             params.set('gacha', latestGachaId);
        }

        const urlSeed = params.get('seed');
        const urlGuaranteed = params.get('ng');
        const urlFeaturedStock = params.get('fs');
        const urlLastRoll = params.get('lr');
        const urlComp = params.get('comp');
        const urlGachaId = params.get('gacha'); // リダイレクト処理により、この時点では存在するはず
        activeGachaId = urlGachaId;
        const urlTx = params.get('tx');
        const urlRoll = params.get('roll');
        
        // リダイレクト回避ロジックを適用したので、ここでは params.get('displaySeed') が null のままであり得る
        const urlDisplaySeed = params.get('displaySeed'); 

        // デフォルト値の適用 (リダイレクトされなかった場合や、uiOverrides がない場合のフォールバック)
        const seedValueStr = uiOverrides.seed !== undefined ? String(uiOverrides.seed) : (urlSeed || DEFAULT_PARAMS.seed);
        
        // isFeaturedComplete の決定ロジックをより堅牢にする
        let isFeaturedComplete;
        if (uiOverrides.isComplete !== undefined) {
            isFeaturedComplete = uiOverrides.isComplete;
        } else if (urlComp === 'true') {
            isFeaturedComplete = true;
        } else if (urlComp === 'false') { // URLに明示的に'false'がある場合
            isFeaturedComplete = false;
        } else { // URLに'comp'がない場合、または無効な値の場合
            isFeaturedComplete = DEFAULT_PARAMS.comp; // false
        }

        // displaySeedValue の宣言を再挿入
        const displaySeedValue = uiOverrides.displaySeed !== undefined ? uiOverrides.displaySeed : (urlDisplaySeed || DEFAULT_PARAMS.displaySeed);

        document.getElementById('seedInput').value = seedValueStr;
        // featuredCompleteCheckbox の状態は isFeaturedComplete に基づいて設定される
        document.getElementById('featuredCompleteCheckbox').checked = isFeaturedComplete;
        const seedValue = parseInt(seedValueStr, 10);
        let lastRollItemId = urlLastRoll ? parseInt(urlLastRoll, 10) : DEFAULT_PARAMS.lr;
        if (isNaN(seedValue)) {
            document.getElementById('output').textContent = '有効な数値を入力してください。';
            return;
        }
        const gacha = gachaMaster[urlGachaId];
        if (!gacha) {
            // リダイレクト処理でカバーされているはずだが、フェイルセーフ
            document.getElementById('output').textContent = '無効なガチャIDです。デフォルトにリダイレクトします。';
            params.set('gacha', latestGachaId);
            window.location.search = params.toString();
            return;
        }
        const featuredCompleteControl = document.getElementById('featuredCompleteCheckbox').parentElement;
        // gacha.featuredItemStock === 0 の場合は isFeaturedComplete を強制的に true にする
        if (gacha.featuredItemStock === 0) {
            isFeaturedComplete = true;
            document.getElementById('featuredCompleteCheckbox').checked = true;
            featuredCompleteControl.classList.add('hidden-control');
        } else {
            featuredCompleteControl.classList.remove('hidden-control');
        }
        const rates = gacha.rarityRates;
        const thresholds = {
            '0': rates['0'],
            '1': rates['0'] + rates['1'], 
            '2': rates['0'] + rates['1'] + rates['2'],
            '3': rates['0'] + rates['1'] + rates['2'] + rates['3'], 
            '4': 10000
        };
        const tableRows = parseInt(urlRoll, 10) || DEFAULT_PARAMS.roll;
        
        updateUIAndURL(options);
        createAndDisplaySeedViewNew(seedValue, gacha, tableRows, isFeaturedComplete, thresholds, lastRollItemId, displaySeedValue, params, urlGuaranteed);
    }
    // --- ▲ 修正 (1) 完了 ▲ ---

    // --- UI更新とイベントリスナー ---
    function updateUIAndURL(options = {}) {
        const { hideSeedInput = false, uiOverrides = {} } = options;
        const params = new URLSearchParams(window.location.search); // Re-read params to ensure it's fresh
        const gachaIds = Object.keys(gachaMaster);
        const latestGachaId = gachaIds.reduce((a, b) => parseInt(a) > parseInt(b) ? a : b);
        const urlGachaId = params.get('gacha') || latestGachaId;
        const gacha = gachaMaster[urlGachaId];
        
        // Use the ng from the URL directly
        const newNG = uiOverrides.guaranteedRolls !== undefined ? uiOverrides.guaranteedRolls : (params.get('ng') || DEFAULT_PARAMS.ng);
        
        const newUrlQuery = generateUrlQuery({
            gacha: urlGachaId, // Use 'gacha' key for generateUrlQuery
            seed: document.getElementById('seedInput').value,
            ng: newNG, // Use the newNG derived from URL
            fs: uiOverrides.featuredStock !== undefined ? uiOverrides.featuredStock : document.getElementById('featuredStockInput').value,
            lr: params.get('lr'),
            comp: document.getElementById('featuredCompleteCheckbox').checked ? 'true' : 'false',
            tx: params.get('tx') && !hideSeedInput ? '1' : (DEFAULT_PARAMS.tx ? '1' : '0'), 
            roll: params.get('roll') || DEFAULT_PARAMS.roll, 
            displaySeed: uiOverrides.displaySeed !== undefined ? uiOverrides.displaySeed : (params.get('displaySeed') || DEFAULT_PARAMS.displaySeed)
        });
        
        window.history.replaceState({ path: newUrlQuery }, '', `${window.location.pathname}${newUrlQuery}`);
        const seedRow = document.getElementById('seedRow');
        const seedLinkContainer = document.getElementById('seedLinkContainer');
        const showSeedInputLink = document.getElementById('showSeedInputLink');
        const stockControl = document.getElementById('stockControl');
        const guaranteedControl = document.getElementById('guaranteedControl');
        const legendDisplay = document.getElementById('legendDisplay'); // Get legend element
        
        const linkParams = {};
        for (const [key, value] of params.entries()) {
            linkParams[key] = value;
        }
        linkParams.gacha = urlGachaId; // Ensure gacha is always set to the active gacha ID
        linkParams.tx = '1'; // Always show seed input for this link
        linkParams.displaySeed = params.get('displaySeed') || DEFAULT_PARAMS.displaySeed; // Ensure displaySeed is passed to link
        showSeedInputLink.href = generateUrlQuery(linkParams);

        // (runSimulationAndDisplay で 'tx' のデフォルト値が '0' に設定されていることを前提)
        if ((params.get('tx') === '1') && !hideSeedInput) {
            seedRow.classList.remove('hidden-control');
            seedLinkContainer.classList.add('hidden-control');
        } else {
            seedRow.classList.add('hidden-control');
            seedLinkContainer.classList.remove('hidden-control');
        }
        const isFeaturedComplete = document.getElementById('featuredCompleteCheckbox').checked;
        
        populateFeaturedStockInput(urlGachaId, params.get('fs') || DEFAULT_PARAMS.fs); // Use DEFAULT_PARAMS.fs

        // (runSimulationAndDisplay で 'ng' のデフォルト値が 'none' に設定されていることを前提)
        // const urlNG = params.get('ng') || DEFAULT_PARAMS.ng; // This is now handled by newNG
        
        if (isFeaturedComplete) {
            stockControl.classList.add('hidden-control');
            if (gacha.uberGuaranteedFlag || gacha.legendGuaranteedFlag) {
                guaranteedControl.classList.remove('hidden-control');
                legendDisplay.classList.remove('hidden-control'); // Show legend
                populateGuaranteedRolls(10, newNG); // Use newNG here
            } else {
                guaranteedControl.classList.add('hidden-control');
                legendDisplay.classList.add('hidden-control'); // Hide legend
            }
        } else {
            stockControl.classList.remove('hidden-control');
            guaranteedControl.classList.remove('hidden-control');
            legendDisplay.classList.remove('hidden-control'); // Show legend
            populateGuaranteedRolls(gacha.guaranteedCycle || 30, newNG); // Use newNG here
        }
        const lastRollDisplay = document.getElementById('lastRollDisplay');
        const lr = params.get('lr');
        if (lr && itemMaster[lr]) {
            lastRollDisplay.textContent = `LastRoll: ${itemMaster[lr].name}`;
        } else {
            lastRollDisplay.textContent = '';
        }
    }

    function generateItemLink(newSeed, newItemId, initialInputNg, rollNumberInSequence, isCompleted) { // Added new parameters
        const currentParams = new URLSearchParams(window.location.search);
        const paramsForQuery = {};
        // Inherit from URL
        for (const [key, value] of currentParams.entries()) {
            paramsForQuery[key] = value;
        }

        // If gacha is not in the URL, use the active one.
        if (!paramsForQuery.gacha) {
            paramsForQuery.gacha = activeGachaId;
        }

        // Override with new values for the link
        paramsForQuery.seed = newSeed;
        if (newItemId !== undefined) {
            paramsForQuery.lr = newItemId;
        }

        // --- Handle ng parameter ---
        const initialInputNgInt = parseInt(initialInputNg, 10);
        if (initialInputNg !== 'none' && !isNaN(initialInputNgInt) && rollNumberInSequence !== undefined && rollNumberInSequence !== null) {
            
            if (isCompleted) {
                // コンプ済みの場合の新しい計算ロジック
                const rollInCycle = (rollNumberInSequence - 1) % 10;
                let ngValue = initialInputNgInt - 1 - rollInCycle;
                if (ngValue <= 0) {
                    ngValue += 10;
                }
                paramsForQuery.ng = ngValue.toString();
            } else {
                // 未コンプの場合の既存ロジック
                const periodicity = 30;
                let ngValue = (initialInputNgInt - (rollNumberInSequence % periodicity) + periodicity) % periodicity;
                if (ngValue === 0) {
                    ngValue = periodicity;
                }
                paramsForQuery.ng = ngValue.toString();
            }
        } else {
            // initialInputNg が 'none' または rollNumberInSequence がない場合
            paramsForQuery.ng = 'none';
        }
        // --- End ng parameter handling ---

        // Explicitly ensure 'comp' is carried over from the current URL
        if (isCompleted) {
            paramsForQuery.comp = 'true';
        } else {
            const currentComp = currentParams.get('comp');
            if (currentComp !== null) {
                paramsForQuery.comp = currentComp;
            } else {
                delete paramsForQuery.comp;
            }
        }


        // Call the existing centralized query builder
        return generateUrlQuery(paramsForQuery);
    }

    function populateGuaranteedRolls(max, currentVal) {
        const input = document.getElementById('guaranteedRollsInput');
        input.innerHTML = '';
        const unsetOption = document.createElement('option');
        unsetOption.value = 'none'; unsetOption.textContent = '未設定'; input.appendChild(unsetOption);
        for (let i = 1; i <= max; i++) {
            const option = document.createElement('option'); option.value = i; option.textContent = i; input.appendChild(option);
        }
        if (input.querySelector(`option[value="${currentVal}"]`)) {
            input.value = currentVal;
        } else {
            input.value = 'none';
        }
    }
    function populateFeaturedStockInput(gachaId, preferredValue = 'none') {
        const gacha = gachaMaster[gachaId];
        const input = document.getElementById('featuredStockInput');
        if (!gacha) return;
        input.innerHTML = '';
        const unsetOption = document.createElement('option');
        unsetOption.value = 'none'; unsetOption.textContent = '-'; input.appendChild(unsetOption);
        for (let i = 1; i <= gacha.featuredItemStock; i++) {
            const option = document.createElement('option'); option.value = i; option.textContent = i; input.appendChild(option);
        }
        if (preferredValue && preferredValue !== 'none' && input.querySelector(`option[value="${preferredValue}"]`)) {
            input.value = preferredValue;
        } else {
            input.value = 'none';
        }
    }
    let forceRerollMode = false;
    // --- 初期化とイベントリスナー設定 ---
    document.addEventListener('DOMContentLoaded', () => {
        setupGachaRarityItems();
        document.getElementById('executeButton').addEventListener('click', () => runSimulationAndDisplay({ hideSeedInput: true, uiOverrides: { seed: document.getElementById('seedInput').value } }));
        // --- ▼ 修正 (7): 'ng' の値が 'none' でも runSimulationAndDisplay が呼ばれるように修正 ▼ ---
        document.getElementById('guaranteedRollsInput').addEventListener('change', (e) => runSimulationAndDisplay({ uiOverrides: { guaranteedRolls: e.target.value } }));
        document.getElementById('featuredStockInput').addEventListener('change', (e) => runSimulationAndDisplay({ uiOverrides: { featuredStock: e.target.value } }));
        // --- ▲ 修正 (7) 完了 ▲ ---
        document.getElementById('featuredCompleteCheckbox').addEventListener('change', () => runSimulationAndDisplay({ uiOverrides: { isComplete: document.getElementById('featuredCompleteCheckbox').checked } }));
        document.getElementById('copySeedLink').addEventListener('click', (event) => {
            event.preventDefault();
            const seedToCopy = new URLSearchParams(window.location.search).get('seed');
            if (seedToCopy && navigator.clipboard) {
                navigator.clipboard.writeText(seedToCopy).then(() => {
                    const originalText = event.target.textContent;
                    event.target.textContent = 'Copied!';
                    setTimeout(() => { event.target.textContent = originalText; }, 1500);
                });
            }
        });
        document.getElementById('result-table-container').addEventListener('click', (event) => {
            if (event.target.id === 'forceRerollToggle') {
                forceRerollMode = !forceRerollMode;
                // The text content will be updated by the function that re-renders the table
                runSimulationAndDisplay();
            }
        });
        runSimulationAndDisplay();
    });
</script>
</body>
</html>
