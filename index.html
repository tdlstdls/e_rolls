<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>イベントガチャロールズ</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.2;
            padding: 5px;
            max-width: 750px;
            margin: 0 auto;
            background-color: #f4f7f9;
            color: #333;
            font-size: 9px;
        }
        .container {
            background: #fff;
            padding: 5px;
            border-radius: 12px;
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.1);
        }
        h1 {
            color: #004085;
            font-size: 0.9rem;
            border-bottom: 1px solid #e9ecef;
            padding-bottom: 3px;
            margin-top: 0;
            text-align: center;
        }
        .controls {
            display: flex;
            flex-direction: column;
            gap: 5px;
            margin-bottom: 10px;
            padding: 4px;
            background-color: #f9fbfd;
            border-radius: 4px;
        }
        .row {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
            gap: 5px;
            align-items: center;
        }
        .control-group-left, .control-group-right {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        .input-item {
            flex: 0 1 auto;
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 3px;
        }
        .input-item-display-only {
            flex: 0 1 auto;
            display: flex;
            align-items: center;
            font-size: 0.7rem;
            color: #555;
            padding: 0 5px;
        }
        .input-item-seed {
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 3px;
        }
        .seed-input-group {
            display: flex;
            align-items: center;
            gap: 5px;
            flex: 1 1 200px;
        }
        label {
            font-weight: 600;
            color: #555;
        }
        input[type="number"],
        select {
            padding: 3px;
            border: 1px solid #ccc;
            border-radius: 3px;
            font-size: 0.8rem;
            width: 100%;
            box-sizing: border-box;
            transition: border-color 0.3s;
        }
        input[type="number"]:focus,
        select:focus {
            outline: none;
            border-color: #007bff;
        }
        button {
            flex-shrink: 0;
            width: auto;
            padding: 5px 10px;
            background-color: #007bff;
            color: #fff;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.8rem;
            font-weight: bold;
            transition: background-color 0.3s ease, transform 0.2s ease;
        }
        .hidden-control {
            display: none !important;
        }
        #showSeedInputLink {
            color: #007bff;
            text-decoration: underline;
            cursor: pointer;
            padding: 0 5px;
        }
        #copySeedLink {
            color: #007bff;
            text-decoration: underline;
            cursor: pointer;
            white-space: nowrap;
        }

        button:hover {
            background-color: #0056b3;
            transform: translateY(-2px);
        }
        .hidden-control {
            display: none !important;
        }
        #result-container {
            margin-top: 15px;
        }
        #result-table-container {
            overflow-x: auto;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
        }
        table {
            width: 100%;
            border-collapse: collapse;
            table-layout: fixed;
        }
        th, td {
            padding: 3px;
            text-align: center;
            border: 1px solid #e0e0e0;
            word-break: break-word;
            font-size: 0.8rem;
        }
        th {
            background-color: #f0f4f7;
            color: #444;
            font-weight: 600;
            position: sticky;
            top: 0;
        }
        td {
            background-color: #fff;
        }
        .row-number-header {
            font-family: Arial, sans-serif;
            font-weight: bold;
            width: 25px;
            cursor: pointer;
        }
        .featuredItem-text {
            color: #d9534f;
            font-weight: bold;
        }
        .re-gacha-cell {
            line-height: 1.2;
        }
        .path-cell {
            background-color: #e6ffe6 !important;
        }
        .path-cell-milestone {
            background-color: #c8e6c9 !important; /* 少し濃いめの緑 */
        }
        .g-ten-pull-highlight {
            background-color: #fffacd;
        }
        a {
            color: inherit;
            text-decoration: none;
        }
        #gachaIdSelector { width: 150px; }
        #guaranteedRollsInput { width: 75px; }
        #featuredStockInput { width: 75px; }
    </style>
</head>
<body>

<div class="container">
    <h1>イベントガチャロールズ<br>（目玉なし10連の対応中）</h1>
    <div class="input-group">
        <div class="controls">
            <div class="row">
                <div class="control-group-left">
                    <div class="input-item" id="seedLinkContainer">
                        <a id="showSeedInputLink" href="#">SEED入力</a>
                    </div>
                    <div class="input-item" id="guaranteedControl">
                        <label for="guaranteedRollsInput">next guaranteed</label>
                        <select id="guaranteedRollsInput"></select>
                    </div>
                    <div id="lastRollDisplay" class="input-item-display-only">
                        </div>
                </div>
                <div class="control-group-right">
                    <div class="input-item">
                        <label for="featuredCompleteCheckbox">コンプ済み</label>
                        <input type="checkbox" id="featuredCompleteCheckbox">
                    </div>
                    <div class="input-item" id="stockControl">
                        <label for="featuredStockInput">目玉残数</label>
                        <select id="featuredStockInput"></select>
                    </div>
                    <a id="copySeedLink" href="#">Copy SEED</a>
                </div>
            </div>
            <div class="row hidden-control" id="seedRow">
                <div class="input-item-seed">
                    <label for="seedInput">SEED</label>
                    <div class="seed-input-group">
                        <input type="number" id="seedInput" value="123456789">
                        <button id="executeButton">更新</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div id="result-container">
        <div id="output"></div>
        <div id="result-table-container"></div>
    </div>
</div>

<script>
    // --- グローバル変数 ---
    // これらの変数はスクリプト全体で使われるため、ここで宣言しています。
    let pathNotComplete = []; // コンプしていないとき用の進行経路
    let pathComplete = []; // コンプ済み用の進行経路
    let xorshiftArray = []; // Xorshift32アルゴリズムで生成された乱数（シード値）を格納する配列
    let moduloArray = []; // 乱数を10000で割った余り。排出率の判定に使う。
    
    // --- URLパラメータの読み込み ---
    function xorshift32(seed) { // Xorshift32というアルゴリズムで、予測可能な乱数列を生成する関数
        let x = seed; // 元になるシード値
        x ^= x << 13; // ビット演算で値をかき混ぜる
        x ^= x >>> 17; // さらにビット演算でかき混ぜる
        x ^= x << 15; // さらにビット演算でかき混ぜる
        return x >>> 0; // 32ビットの符号なし整数として結果を返す
    }
    
    // --- マスターデータ ---
    // ガチャやアイテムの基本的な情報を定義しています。
    const gachaMaster = { // ガチャごとの設定
        '34': {
            name: '(旧)ハロウィン', // ガチャ名
            featuredItemRate: 600, // 目玉アイテムの排出率 (0.01%単位)
            featuredItemStock: 5, // 目玉アイテムの在庫数
            guaranteedCycle: 30, // 確定枠の周期
            uberGuaranteedFlag: false, // 目玉なし（コンプ済み時）超激レア確定処理の有無
            legendGuaranteedFlag: false, // 目玉なし（コンプ済み時）伝説レア確定処理の有無
            rarityRates: { '0': 2000, '1': 5000, '2': 3000, '3': 0, '4': 0 }, // 各レアリティの排出率
            pool: [0, 2, 3, 4, 5, 10, 11, 12, 14] // このガチャから排出される可能性のあるアイテムIDのリスト
        },
        '42': {
            name: '1.1億DL記念',
            featuredItemRate: 500,
            featuredItemStock: 5,
            guaranteedCycle: 30,
            uberGuaranteedFlag: false,
            legendGuaranteedFlag: false,
            rarityRates: { '0': 1000, '1': 5000, '2': 3000, '3': 1000, '4': 0 },
            pool: [0, 2, 3, 4, 5, 10, 11, 12, 14, 375, 381, 689]
        },
        '44': {
            name: 'ハロウィン',
            featuredItemRate: 500,
            featuredItemStock: 8,
            guaranteedCycle: 30,
            uberGuaranteedFlag: false,
            legendGuaranteedFlag: false,
            rarityRates: { '0': 2000, '1': 4900, '2': 3000, '3': 0, '4': 100 },
            pool: [0, 2, 3, 4, 5, 10, 11, 12, 14, 18]
        },
        '45': {
            name: 'にゃんこレンジャー',
            featuredItemRate: 500,
            featuredItemStock: 0,
            guaranteedCycle: 30,
            uberGuaranteedFlag: true,
            legendGuaranteedFlag: true,
            rarityRates: { '0': 0, '1': 5900, '2': 3000, '3': 1000, '4': 100 },
            pool: [0,2,3,4,5,11,12,14,197,184,375,726,831]
        }
    };

    const itemMaster = { // アイテムIDと名前、レアリティの対応表
        0: { name: "スピダ", rarity: 1 }, // キーがアイテムID
        2: { name: "ネコボン", rarity: 2 }, // name: アイテム名, rarity: レアリティID
        3: { name: "ニャンピュ", rarity: 1 },
        4: { name: "おかめ", rarity: 2 },
        5: { name: "スニャ", rarity: 2 },
        10: { name: "5千XP", rarity: 0 },
        11: { name: "1万XP", rarity: 1 },
        12: { name: "3万XP", rarity: 1 },
        14: { name: "10万XP", rarity: 2 },
        18: { name: "200万XP", rarity: 4 },
        197: { name: "100万XP", rarity: 4 },
        184: { name: "ミスターニンジャ", rarity: 3 },
        375: { name: "記念ネコ", rarity: 3 },
        381: { name: "ねこ農家", rarity: 3 },
        689: { name: "石の上にも10年ネコ", rarity: 3 },
        726: { name: "ネコメダル王", rarity: 3 },
        831: { name: "スカーフにゃんこ", rarity: 3 }
    };
    
    // アイテム名からIDを逆引き（逆検索）するためのマップを事前に作成
    const itemNameMap = Object.fromEntries(
        Object.entries(itemMaster).map(([id, { name }]) => [name, parseInt(id, 10)])
    );
    
    // gachaMasterのデータを使いやすく整理する関数
    function setupGachaRarityItems() {
        for (const gachaId in gachaMaster) { // 全てのガチャ設定をループ
            const gacha = gachaMaster[gachaId]; // 個別のガチャ設定を取得
            if (gacha && gacha.pool) { // ガチャ設定と排出アイテムリストがあれば
                const pool = gacha.pool; // 排出アイテムリスト
                const rarityItems = { '0': [], '1': [], '2': [], '3': [], '4': [] }; // レアリティごとにアイテムIDを分類する箱

                for (const itemId of pool) { // 排出アイテムを一つずつチェック
                    const item = itemMaster[itemId]; // アイテムのマスターデータを取得
                    if (item && rarityItems[item.rarity] !== undefined) { // アイテムが存在し、対応するレアリティの箱があれば
                        rarityItems[item.rarity].push(itemId); // そのレアリティの箱にアイテムIDを追加
                    }
                }

                // 各レアリティのアイテムリストをIDの昇順でソートする（計算結果を安定させるため）
                for (const rarity in rarityItems) { // 各レアリティの箱をループ
                    rarityItems[rarity].sort((a, b) => a - b); // IDの小さい順に並び替え
                }

                gacha.rarityItems = rarityItems; // 整理したデータを元のガチャ設定に追加
            }
        }
    }

    // --- HTML要素の取得 ---
    // JavaScriptでHTMLの各部品を操作するために、あらかじめ部品を変数に格納しておきます。
    const seedInput = document.getElementById('seedInput'); // SEED入力欄
    const guaranteedRollsInput = document.getElementById('guaranteedRollsInput'); // 「next guaranteed」ドロップダウン
    const featuredStockInput = document.getElementById('featuredStockInput'); // 「目玉残数」ドロップダウン
    const executeButton = document.getElementById('executeButton'); // 「更新」ボタン
    const featuredCompleteCheckbox = document.getElementById('featuredCompleteCheckbox'); // 「コンプ済み」チェックボックス
    const output = document.getElementById('output'); // （現在未使用）デバッグ情報などを表示するための要素
    const guaranteedControl = document.getElementById('guaranteedControl'); // 「next guaranteed」を囲む要素
    const stockControl = document.getElementById('stockControl'); // 「目玉残数」を囲む要素
    const seedRow = document.getElementById('seedRow'); // SEED入力欄と更新ボタンの行
    const seedLinkContainer = document.getElementById('seedLinkContainer'); // 「SEED入力」リンクを囲む要素
    const showSeedInputLink = document.getElementById('showSeedInputLink'); // 「SEED入力」リンク
    const copySeedLink = document.getElementById('copySeedLink'); // 「Copy SEED」リンク

    const resultTableContainer = document.getElementById('result-table-container'); // 結果テーブル全体を囲むコンテナ
    let forceReGachaMode = false; // 再抽選の表示を強制的に切り替えるためのフラグ

    // --- 初期化処理 ---
    setupGachaRarityItems();

    // 「next guaranteed」ドロップダウンは runSimulationAndDisplay 内で動的に生成されます。

    // 目玉残数ドロップダウンを生成する関数
    function populateFeaturedStockInput(gachaId, preferredValue = 'none') {
        const gacha = gachaMaster[gachaId]; // 指定されたガチャIDの情報を取得
        if (!gacha) return; // ガチャ情報がなければ何もしない
        const stock = gacha.featuredItemStock; // 目玉の在庫数を取得

        // 既存の選択肢を一旦すべてクリア
        featuredStockInput.innerHTML = '';

        // 「-」（未設定）の選択肢を追加
        const unsetOption = document.createElement('option');
        unsetOption.value = 'none';
        unsetOption.textContent = '-';
        featuredStockInput.appendChild(unsetOption);

        // 1から在庫数までの選択肢を追加
        for (let i = 1; i <= stock; i++) {
            const option = document.createElement('option');
            option.value = i;
            option.textContent = i;
            featuredStockInput.appendChild(option);
        }

        // URLパラメータや前の状態を引き継いで、値を設定する
        if (preferredValue && preferredValue !== 'none' && featuredStockInput.querySelector(`option[value="${preferredValue}"]`)) {
            featuredStockInput.value = preferredValue;
        } else {
            featuredStockInput.value = 'none'; // 該当がなければ「-」にする
        }
    }

    // --- イベントリスナーの設定 ---
    // ユーザーの操作（クリックなど）に応じて特定の処理を実行するように設定します。

    // 「更新」ボタンがクリックされたときの処理
    executeButton.addEventListener('click', () => {
        runSimulationAndDisplay({
            hideSeedInput: true,
            uiOverrides: { seed: seedInput.value }
        });
    });

    // 「next guaranteed」ドロップダウンが変更されたときの処理
    guaranteedRollsInput.addEventListener('change', () => {
        runSimulationAndDisplay({ uiOverrides: { guaranteedRolls: guaranteedRollsInput.value } });
    });

    // 「目玉残数」ドロップダウンが変更されたときの処理
    featuredStockInput.addEventListener('change', () => {
        runSimulationAndDisplay({ uiOverrides: { featuredStock: featuredStockInput.value } });
    });

    // 「コンプ済み」チェックボックスの初期化と変更時の処理
    featuredCompleteCheckbox.addEventListener('change', () => {
        runSimulationAndDisplay({
            hideSeedInput: true,
            uiOverrides: { isComplete: featuredCompleteCheckbox.checked }
        });
    });

    // 「Copy SEED」リンクがクリックされたときの処理
    copySeedLink.addEventListener('click', (event) => {
        event.preventDefault(); // リンク本来のページ遷移動作をキャンセル

        const currentParams = new URLSearchParams(window.location.search); // 現在のURLのパラメータを取得
        const seedToCopy = currentParams.get('seed'); // 'seed'パラメータの値を取得
        if (!seedToCopy) return; // SEEDがなければ何もしない

        if (!navigator.clipboard) { // ブラウザがクリップボード機能に対応しているかチェック
            alert('お使いのブラウザはクリップボードAPIをサポートしていません。');
            return;
        }

        // クリップボードにSEED値を書き込む
        navigator.clipboard.writeText(seedToCopy).then(() => {
            // 成功した場合
            const originalText = copySeedLink.textContent; // 元のテキストを保存
            copySeedLink.textContent = 'Copied!'; // テキストを「Copied!」に変更
            setTimeout(() => { // 1.5秒後に
                copySeedLink.textContent = originalText; // 元のテキストに戻す
            }, 1500);
        }).catch(err => {
            // 失敗した場合
            console.error('クリップボードへのコピーに失敗しました: ', err);
            alert('クリップボードへのコピーに失敗しました。');
        });
    });

    // --- ヘルパー関数 ---
    // URLのクエリパラメータ文字列を生成する
    function generateUrlQuery(params) {
        // パラメータ、URL、デフォルトの順でガチャIDを取得
        const currentUrlParams = new URLSearchParams(window.location.search);
        const urlGachaId = currentUrlParams.get('gacha');
        const currentGachaId = params.gachaId || urlGachaId || '45';

        let query = `?gacha=${currentGachaId}`;
        if (params.seed !== undefined) query += `&seed=${params.seed}`;
        if (params.ng !== undefined && params.ng !== 'none') query += `&ng=${params.ng}`;
        if (params.fs !== undefined && params.fs !== 'none' && params.fs !== Infinity) query += `&fs=${params.fs}`;
        if (params.lr !== undefined && params.lr !== -1 && params.lr !== null) query += `&lr=${params.lr}`;
        if (params.comp) query += `&comp=true`;
        if (params.tx) query += `&tx=${params.tx}`;
        if (params.roll !== undefined && params.roll !== 100) query += `&roll=${params.roll}`; // rollが100（デフォルト）でない場合のみ追加
        return query;
    }

    // --- メイン処理関数 ---
    // シミュレーションを実行し、結果を画面に表示する一連の流れを管理します。
    function runSimulationAndDisplay(options = {}) {
        const { hideSeedInput = false, uiOverrides = {} } = options;

        // --- URLパラメータの読み込みとUIの同期 ---
        // 実行のたびに現在のURLを解析し、UIの状態をURLに合わせます。
        const params = new URLSearchParams(window.location.search);
        const urlSeed = params.get('seed');
        const urlGuaranteed = params.get('ng');
        const urlFeaturedStock = params.get('fs');
        const urlLastRoll = params.get('lr');
        const urlComp = params.get('comp');
        const urlGachaId = params.get('gacha');
        const urlTx = params.get('tx');
        const urlRoll = params.get('roll');

        // 状態を決定（UI操作によるオーバーライド > URLパラメータ）
        const seedValueStr = uiOverrides.seed !== undefined ? uiOverrides.seed : (urlSeed || seedInput.value);
        let isFeaturedComplete = uiOverrides.isComplete !== undefined ? uiOverrides.isComplete : (urlComp === 'true');
        const guaranteedRollsValue = uiOverrides.guaranteedRolls !== undefined ? uiOverrides.guaranteedRolls : (urlGuaranteed || 'none');
        const featuredStockValue = uiOverrides.featuredStock !== undefined ? uiOverrides.featuredStock : (urlFeaturedStock || 'none');

        const tableRows = parseInt(urlRoll, 10) || 100; // rollパラメータがなければ100行
        // 決定した状態でUIを同期
        seedInput.value = seedValueStr;
        // guaranteedRollsInput.value = guaranteedRollsValue; // populateGuaranteedRolls の中で設定
        featuredCompleteCheckbox.checked = isFeaturedComplete;

        const selectedGachaId = urlGachaId || '45'; // URLからガチャIDを取得、なければデフォルトに

        const seedValue = parseInt(seedInput.value, 10); // 入力されたシード値を取得し、整数に変換
        const firstGuaranteedRolls = parseInt(guaranteedRollsValue, 10) || 30; // 選択された次回確定枠の回数を取得（未設定の場合は30）

        let lastRollItemId = null; // 直前のアイテムIDを初期化
        if (urlLastRoll && !isNaN(parseInt(urlLastRoll, 10))) { // URLに 'lr' パラメータがあれば
            lastRollItemId = parseInt(urlLastRoll, 10); // 直前のアイテムIDとして設定
        }

        // 「目玉残数」ドロップダウンを現在のガチャIDとURLパラメータに合わせて更新
        populateFeaturedStockInput(selectedGachaId, featuredStockValue);

        const featuredStockLimitStr = featuredStockInput.value; // 「目玉残数」の値を取得
        const featuredStockLimit = featuredStockLimitStr === 'none' ? Infinity : parseInt(featuredStockLimitStr, 10); // 'none'なら無限、それ以外は整数に

        if (isNaN(seedValue)) { // シード値が有効な数値でなければ
            output.textContent = '有効な数値を入力してください。'; // エラーメッセージを表示
            return; // 処理を中断
        }

        const gacha = gachaMaster[selectedGachaId]; // 選択されたガチャのマスターデータを取得
        if (!gacha) { // ガチャデータが見つからなければ
            output.textContent = '無効なガチャIDです。'; // エラーメッセージを表示
            return; // 処理を中断
        }

        const featuredCompleteControl = document.getElementById('featuredCompleteCheckbox').parentElement;
        if (gacha.featuredItemStock === 0) {
            isFeaturedComplete = true;
            featuredCompleteCheckbox.checked = true;
            featuredCompleteControl.classList.add('hidden-control');
        } else {
            featuredCompleteControl.classList.remove('hidden-control');
        }
        
        
        const requiredSeeds = Math.max(1000, tableRows * 4); // 必要な乱数の数を計算
        // --- 乱数生成 ---
        xorshiftArray = []; // シード値の配列を初期化
        moduloArray = []; // 剰余の配列を初期化
        let currentSeed = seedValue; // 現在のシード値を初期化
        for (let i = 0; i < requiredSeeds; i++) { // 必要な数だけ乱数を生成
            currentSeed = xorshift32(currentSeed); // 次のシード値を生成
            xorshiftArray.push(currentSeed); // シード値配列に追加
            moduloArray.push(currentSeed % 10000); // 10000で割った余りを配列に追加（確率判定用）
        }
        
        // --- レアリティ確率のしきい値計算 ---
        const rates = gacha.rarityRates; // レアリティ排出率を取得
        const thresholds = { // 累積確率を計算して、判定用のしきい値を作成
            '0': rates['0'],
            '1': rates['0'] + rates['1'],
            '2': rates['0'] + rates['1'] + rates['2'],
            '3': rates['0'] + rates['1'] + rates['2'] + rates['3'],
            '4': 10000
        };

        // --- 単発ロールの計算 ---
        // ステップ1: 全300データインデックスに対する基本情報の事前計算
        // このステップでは、各乱数インデックスがどのアイテムに対応するかを計算します。
        const items = new Array(requiredSeeds).fill(-1); // 各データインデックスにおける再抽選前のアイテムID
        const rarities = new Array(requiredSeeds).fill(-1); // 各データインデックスにおけるレアリティID
        const reGachaItemIds = new Array(requiredSeeds).fill(-1); // 各データインデックスにおける再抽選後のアイテムID
        const isfeaturedItemCell = new Array(requiredSeeds).fill(false); // 各データインデックスが抽選目玉の対象か

        for (let i = 0; i < requiredSeeds; i++) {
            let hitSeedIndex, raritySeedIndex, itemSeedIndex, reGachaSeedIndexOffset;

            if (isFeaturedComplete) { // 目玉コンプ済の場合
                hitSeedIndex = -1; // 目玉抽選は行わない
                raritySeedIndex = i; // レアリティ抽選はi番目の乱数
                itemSeedIndex = i + 1; // アイテム抽選はi+1番目の乱数
                reGachaSeedIndexOffset = 2; // 再抽選はi+2番目の乱数
            } else { // 通常時
                hitSeedIndex = i; // 目玉抽選はi番目
                raritySeedIndex = i + 1; // レアリティ抽選はi+1番目
                itemSeedIndex = i + 2; // アイテム抽選はi+2番目
                reGachaSeedIndexOffset = 3; // 再抽選はi+3番目
            }

            if (itemSeedIndex >= xorshiftArray.length) continue;

            isfeaturedItemCell[i] = !isFeaturedComplete && (moduloArray[hitSeedIndex] < gacha.featuredItemRate);

            if (isfeaturedItemCell[i]) continue;
            
            // レアリティを決定
            let rarityId;
            if (moduloArray[raritySeedIndex] < thresholds['0']) { rarityId = 0; }
            else if (moduloArray[raritySeedIndex] < thresholds['1']) { rarityId = 1; }
            else if (moduloArray[raritySeedIndex] < thresholds['2']) { rarityId = 2; }
            else if (moduloArray[raritySeedIndex] < thresholds['3']) { rarityId = 3; }
            else { rarityId = 4; }
            rarities[i] = rarityId;

            // アイテムを決定
            const itemInfo = gacha.rarityItems[rarityId];
            const itemCounts = itemInfo.length;
            if (itemCounts > 0) {
                const itemOffset = xorshiftArray[itemSeedIndex] % itemCounts;
                items[i] = itemInfo[itemOffset];
            }

            // 再抽選後のアイテムIDを計算（実際に再抽選されるか否かに関わらず計算しておく）
            if (rarityId === 1 && itemCounts >= 2) {
                const reGachaSeedIndex = i + reGachaSeedIndexOffset; // 再抽選用の乱数インデックス
                if (reGachaSeedIndex < xorshiftArray.length) {
                    const originalItemNoList = [...itemInfo]; // 元のアイテムリストをコピー
                    const itemIndex = originalItemNoList.indexOf(items[i]); // 今回抽選されたアイテムのインデックスを探す
                    if (itemIndex > -1) {
                        originalItemNoList.splice(itemIndex, 1); // リストからそのアイテムを削除（再抽選では同じものは出ない）
                    }
                    const newDivisor = originalItemNoList.length; // 再抽選対象のアイテム数
                    if (newDivisor > 0) {
                        const seedForReGacha = xorshiftArray[reGachaSeedIndex]; // 再抽選用の乱数値
                        const reGachaOffset = seedForReGacha % newDivisor; // 再抽選結果のインデックスを計算
                        reGachaItemIds[i] = originalItemNoList[reGachaOffset];
                    }
                }
            }
        }

        // ステップ2: 事前計算した情報を用いて進行経路をシミュレート
        let currentPath; // このシミュレーションで使うパス変数を宣言
        const reRolledIndicesOnPath = new Set(); // 経路上で再抽選が発生したセルのインデックス
        const lastItemIdsOnPath = []; // 各パスステップの直前のアイテムID
        const visualToDataMap = new Map(); // 目玉コンプモード用のマップ

        let lastActualItemId = lastRollItemId !== null ? lastRollItemId : -1;
        const canReRollRarity1 = gacha.rarityItems[1] && gacha.rarityItems[1].length >= 2;

        if (isFeaturedComplete) { // 目玉コンプ済の場合
            pathComplete = []; // コンプ済み用のパスを初期化
            currentPath = pathComplete; // 現在のパスとしてコンプ済み用を使用
            let dataIndex = 0; // データ（乱数）の消費インデックス
            
            // (修正) A列(c=0)とB列(c=1)を順番に処理する
            for (let r = 0; r < tableRows; r++) { // 行ループ
                for (let c = 0; c < 2; c++) { // A列(c=0), B列(c=1)
                    if (dataIndex >= requiredSeeds) break; // 乱数枯渇

                    const visualIndex = r * 3 + c; // 見た目上のインデックス (0, 1, 3, 4, 6, 7, ...)
                    
                    lastItemIdsOnPath.push(lastActualItemId); // 現在の「直前のアイテム」を記録
                    currentPath.push(visualIndex); // 見た目のインデックスをパスに追加
                    visualToDataMap.set(visualIndex, dataIndex); // 見た目とデータの対応を記録

                    // (※) 再抽選の対象となるか判定
                    const isReRoll = canReRollRarity1 && rarities[dataIndex] === 1 && lastActualItemId === items[dataIndex];

                    if (isReRoll) { // 再抽選が発生した場合
                        reRolledIndicesOnPath.add(visualIndex); // 再抽選発生を記録
                        lastActualItemId = reGachaItemIds[dataIndex]; // 次の「直前のアイテム」は再抽選後のもの
                        dataIndex += 3; // データ（乱数）を3つ消費
                    } else { // 再抽選が発生しない場合
                        lastActualItemId = items[dataIndex]; // 次の「直前のアイテム」は今回引いたもの
                        dataIndex += 2; // データ（乱数）を2つ消費
                    }
                }
                if (dataIndex >= requiredSeeds) break; // 乱数枯渇
            }
        } else { // 目玉コンプ済でない場合
            pathNotComplete = []; // コンプしてないとき用のパスを初期化
            currentPath = pathNotComplete; // 現在のパスとしてコンプしてないとき用を使用
            let dataIndex = 0;
            while (dataIndex < requiredSeeds) {
                lastItemIdsOnPath.push(lastActualItemId);
                const visualIndex = dataIndex;
                currentPath.push(visualIndex);

                // (※) 再抽選の対象となるか判定
                const isReRoll = canReRollRarity1 && rarities[dataIndex] === 1 && lastActualItemId === items[dataIndex];

                if (isfeaturedItemCell[dataIndex]) { // 目玉が出た場合
                    dataIndex += 1; // 乱数を1つ消費
                    // lastActualItemId をリセットしないことで、目玉をまたいだ再抽選を可能にする
                } else if (isReRoll) { // 再抽選が発生した場合
                    reRolledIndicesOnPath.add(visualIndex);
                    lastActualItemId = reGachaItemIds[dataIndex];
                    dataIndex += 4; // 乱数を4つ消費
                } else { // 通常のアイテムが出た場合
                    lastActualItemId = items[dataIndex];
                    dataIndex += 3; // 乱数を3つ消費
                }
            }
        }
        
        // 表示用の再抽選アイテム名配列を生成（下位互換性のため）
        const reGachaItems = new Array(requiredSeeds).fill("---");
        for (let i = 0; i < requiredSeeds; i++) {
            if (reGachaItemIds[i] !== -1 && itemMaster[reGachaItemIds[i]]) {
                reGachaItems[i] = itemMaster[reGachaItemIds[i]].name;
            }
        }
        
        // --- G列（10連ガチャ）のシミュレーション ---
        const tenPullResults = new Array(10).fill(null); // 10連の結果（表示用）
        const tenPullRarities = new Array(10).fill(-1); // 10連の各枠のレアリティ
        const isFeaturedSlot = new Array(10).fill(false); // 10連の各枠が目玉かどうか
        let seedOffset = 0; // 10連ガチャ内で消費する乱数のオフセット

        // フェーズ1: 目玉判定
        const isGuaranteedInTenPull = firstGuaranteedRolls > 0 && firstGuaranteedRolls <= 10; // 10連内に確定枠があるか
        const guaranteedSlotIndex = isGuaranteedInTenPull ? firstGuaranteedRolls - 1 : -1; // 確定枠のインデックス (0-9)

        if (!isFeaturedComplete) { // 目玉コンプ済でなければ目玉抽選を行う
            const lotteryHitSlots = []; // 抽選で当たった枠のインデックス
            let hitCheckSeedOffset = 0; // 目玉抽選で使う乱数のインデックスを管理

            for (let i = 0; i < 10; i++) { // 10個のスロットをループ
                if (i === guaranteedSlotIndex) {
                    continue; // 確定枠は抽選しないのでスキップ
                }
                // 確定枠でないスロットで、順番に乱数を使って抽選
                if (moduloArray[hitCheckSeedOffset] < gacha.featuredItemRate) {
                    lotteryHitSlots.push(i); // 目玉が当たったスロットのインデックスを記録
                }
                hitCheckSeedOffset++; // 使用した乱数のインデックスを進める
            }

            // 抽選目玉と確定枠を、目玉残数を考慮して最終的な目玉スロットに反映する
            let featuredItemsDrawnCount = 0;

            // まず抽選で当たった目玉を反映
            for (const slotIndex of lotteryHitSlots) {
                if (featuredItemsDrawnCount < featuredStockLimit) {
                    isFeaturedSlot[slotIndex] = true;
                    featuredItemsDrawnCount++;
                }
            }

            // 次に確定枠を反映（まだ残数があり、かつその枠が抽選で目玉になっていない場合）
            if (guaranteedSlotIndex !== -1) {
                if (featuredItemsDrawnCount < featuredStockLimit && !isFeaturedSlot[guaranteedSlotIndex]) {
                    isFeaturedSlot[guaranteedSlotIndex] = true;
                }
            }

            // 目玉抽選で消費した乱数の分だけ、次のアイテム抽選の開始位置をずらす
            seedOffset = hitCheckSeedOffset;
        }

        // フェーズ2: レアリティ・アイテム抽選
        let prevItemId = lastRollItemId !== null ? lastRollItemId : -1; // 10連の1枠目の再抽選判定のために直前のアイテムIDを引き継ぐ

        for (let i = 0; i < 10; i++) {
            if (isFeaturedSlot[i]) { // その枠が目玉なら
                tenPullResults[i] = (i === guaranteedSlotIndex && !isFeaturedComplete) ? '目玉(確定)' : '目玉';
                // 目玉が出ても、次の再抽選判定のために直前のアイテムIDは保持する
                continue;
            }
            // 目玉ではなかったスロットの処理
            const raritySeedIndex = seedOffset;
            const itemSeedIndex = seedOffset + 1;
            const reGachaSeedIndex = seedOffset + 2;

            // レアリティ決定
            let rarityId;
            if (moduloArray[raritySeedIndex] < thresholds['0']) { rarityId = 0; }
            else if (moduloArray[raritySeedIndex] < thresholds['1']) { rarityId = 1; }
            else if (moduloArray[raritySeedIndex] < thresholds['2']) { rarityId = 2; }
            else if (moduloArray[raritySeedIndex] < thresholds['3']) { rarityId = 3; }
            else { rarityId = 4; }
            if (i === 9) tenPullRarities[i] = rarityId; // 10枠目のレアリティを保存

            // アイテム決定
            const itemInfo = gacha.rarityItems[rarityId];
            const itemCounts = itemInfo.length;
            let itemName = "---";
            let currentItemId = -1;
            if (itemCounts > 0) {
                const itemOffset = xorshiftArray[itemSeedIndex] % itemCounts;
                currentItemId = itemInfo[itemOffset];
                itemName = itemMaster[currentItemId] ? itemMaster[currentItemId].name : "不明";
            }
            
            let displayItemName = itemName;
            let seedsForThisRoll = 2; // 通常はレアリティとアイテムで2つ消費

            // 再抽選判定
            if (rarityId === 1 && itemCounts >= 2 && prevItemId !== -1 && prevItemId === currentItemId) {
                if (reGachaSeedIndex < xorshiftArray.length) {
                    const originalItemNoList = [...itemInfo];
                    const itemIndex = originalItemNoList.indexOf(currentItemId);
                    if (itemIndex > -1) originalItemNoList.splice(itemIndex, 1);
                    
                    const newDivisor = originalItemNoList.length;
                    if (newDivisor > 0) {
                        const seedForReGacha = xorshiftArray[reGachaSeedIndex];
                        const reGachaOffset = seedForReGacha % newDivisor;
                        const reGachaItemId = originalItemNoList[reGachaOffset];
                        
                        displayItemName = `${itemName}<br>${itemMaster[reGachaItemId].name}`; // 元のアイテムと再抽選後アイテムを両方表示
                        prevItemId = reGachaItemId; // 次の判定のためにIDを更新
                        seedsForThisRoll++; // 再抽選で乱数を1つ追加消費
                    } else {
                        prevItemId = currentItemId;
                    }
                } else {
                    prevItemId = currentItemId;
                }
            } else {
                prevItemId = currentItemId;
            }
            
            tenPullResults[i] = displayItemName;
            seedOffset += seedsForThisRoll; // 消費した乱数の分だけオフセットを進める
        }
        
        // 10連ガチャの10枠目に、次の状態へのリンクを付与する
        let actualItemIdForG9 = prevItemId; // 10連の最後のアイテムが次のLastRollになる

        const initialStockForUrl = featuredStockLimitStr === 'none' ? gacha.featuredItemStock : parseInt(featuredStockLimitStr, 10);
        const featuredItemsDrawnInTenPull = isFeaturedSlot.filter(Boolean).length;
        const stockAfterTenPull = Math.max(0, initialStockForUrl - featuredItemsDrawnInTenPull);
        const nextRollIndex = seedOffset; // 10連ガチャ後の次の乱数インデックス
        const nextRollRow = Math.floor(nextRollIndex / 3) + 1;
        const nextRollCol = String.fromCharCode('A'.charCodeAt(0) + ((nextRollIndex) % 3));
        const nextRollAddress = `${nextRollCol}${nextRollRow}`;
        const currentGuaranteedRolls = parseInt(guaranteedRollsInput.value, 10) || (gacha.guaranteedCycle || 30);
        const guaranteedCycle = gacha.guaranteedCycle || 30;
        let nextGuaranteedForTenPull = currentGuaranteedRolls - 10;
        if (nextGuaranteedForTenPull <= 0) nextGuaranteedForTenPull += guaranteedCycle;

        let lrParamForTenPull = '';
        if (actualItemIdForG9 !== -1) {
            lrParamForTenPull = `&lr=${actualItemIdForG9}`;
        }
        const tenPullLinkHref = `href="${generateUrlQuery({
            seed: xorshiftArray[nextRollIndex - 1], ng: nextGuaranteedForTenPull, fs: stockAfterTenPull, lr: actualItemIdForG9,
            comp: stockAfterTenPull === 0, gachaId: selectedGachaId
        })}"`;

        const originalG9Content = tenPullResults[9] || '---';
        let newG9Display;
        if (originalG9Content.includes('<br>')) { // 10連の最後が再抽選だった場合
            const originalItem = originalG9Content.split('<br>')[0].trim();
            const reGachaItem = originalG9Content.split('<br>')[1].trim();
            newG9Display = `${originalItem}<br><a ${tenPullLinkHref} class="re-gacha-cell">${nextRollAddress}) ${reGachaItem}</a>`;
        } else {
            if (tenPullRarities[9] === 3) { // レアリティ3（超激レアなど）の場合
                newG9Display = `<a ${tenPullLinkHref} class="re-gacha-cell"><span class="featuredItem-text">${nextRollAddress}) ${originalG9Content.trim()}</span></a>`;
            } else {
                newG9Display = `<a ${tenPullLinkHref} class="re-gacha-cell">${nextRollAddress}) ${originalG9Content.trim()}</a>`;
            }
        }
        tenPullResults[9] = newG9Display;

        // --- G列11行目以降（単発N回後の10連での目玉期待数）の計算 ---
        const expectedFeaturedItemsArray = [];
        const initialStock = featuredStockLimitStr === 'none' ? Infinity : parseInt(featuredStockLimitStr, 10);
        const initialGuaranteedRolls = parseInt(guaranteedRollsInput.value, 10); // 'none' なら NaN

        for (let start = 1; start <= 10; start++) { // 単発1回後〜10回後までループ
            if (currentPath[start] === undefined) {
                expectedFeaturedItemsArray[start] = "---";
                continue;
            }

            if (isFeaturedComplete) { // 目玉コンプ済なら期待値は0
                expectedFeaturedItemsArray[start] = 0;
                continue;
            }

            // 単発 `start` 回引いた後の目玉残数を計算
            const featuredSlotsBeforeTenPull = new Set();
            for (let i = 0; i < start; i++) {
                const pIndex = currentPath[i];
                const rollNumber = i + 1;
                if (isfeaturedItemCell[pIndex]) featuredSlotsBeforeTenPull.add(pIndex);
                if (!isNaN(initialGuaranteedRolls) && rollNumber >= initialGuaranteedRolls && (rollNumber - initialGuaranteedRolls) % guaranteedCycle === 0) {
                     featuredSlotsBeforeTenPull.add(pIndex);
                }
            }
            const featuredItemsDrawnBeforeTenPull = Math.min(featuredSlotsBeforeTenPull.size, initialStock);
            const stockAfterSingle = Math.max(0, initialStock - featuredItemsDrawnBeforeTenPull);

            // その状態から10連ガチャを引いた場合の目玉数をシミュレート
            const startSeedIndex = currentPath[start];
            let guaranteedRollsForThisTenPull = 'none';
            if (!isNaN(initialGuaranteedRolls)) {
                let nextG = initialGuaranteedRolls - start;
                while (nextG <= 0) { nextG += guaranteedCycle; }
                guaranteedRollsForThisTenPull = nextG;
            }
            
            const isGuaranteedInThisTenPull = guaranteedRollsForThisTenPull !== 'none' && guaranteedRollsForThisTenPull > 0 && guaranteedRollsForThisTenPull <= 10;
            const guaranteedSlotIndexInThisTenPull = isGuaranteedInThisTenPull ? guaranteedRollsForThisTenPull - 1 : -1;

            const lotteryHitSlots = [];
            let hitCheckSeedOffset = 0;
            for (let i = 0; i < 10; i++) {
                if (i === guaranteedSlotIndexInThisTenPull) continue;
                const seedIndex = startSeedIndex + hitCheckSeedOffset;
                if (seedIndex < moduloArray.length && moduloArray[seedIndex] < gacha.featuredItemRate) {
                    lotteryHitSlots.push(i);
                }
                hitCheckSeedOffset++;
            }

            let featuredItemsDrawnInThisTenPull = 0;
            const finalFeaturedSlotsInThisTenPull = new Array(10).fill(false);
            for (const slotIndex of lotteryHitSlots) {
                if (featuredItemsDrawnInThisTenPull < stockAfterSingle) {
                    finalFeaturedSlotsInThisTenPull[slotIndex] = true;
                    featuredItemsDrawnInThisTenPull++;
                }
            }
            if (guaranteedSlotIndexInThisTenPull !== -1 && featuredItemsDrawnInThisTenPull < stockAfterSingle && !finalFeaturedSlotsInThisTenPull[guaranteedSlotIndexInThisTenPull]) {
                finalFeaturedSlotsInThisTenPull[guaranteedSlotIndexInThisTenPull] = true;
            }

            expectedFeaturedItemsArray[start] = finalFeaturedSlotsInThisTenPull.filter(Boolean).length;
        }
        
        // --- 表示処理 ---
        // (修正) guaranteedRollsForTable には input の value (文字列) をそのまま渡す
        let guaranteedRollsForTable = guaranteedRollsInput.value;
        createAndDisplayTable(items, rarities, isfeaturedItemCell, currentPath, tenPullResults, reGachaItems, selectedGachaId, expectedFeaturedItemsArray, guaranteedRollsForTable, initialStockForUrl, reRolledIndicesOnPath, visualToDataMap, canReRollRarity1, lastItemIdsOnPath, tableRows);
    
        // --- URLとUIの更新 ---
        const shouldHaveTx = urlTx && !hideSeedInput;
        const newUrlQuery = generateUrlQuery({
            seed: seedValue,
            ng: guaranteedRollsInput.value,
            fs: featuredStockInput.value,
            lr: urlLastRoll,
            comp: featuredCompleteCheckbox.checked,
            gachaId: selectedGachaId,
            tx: shouldHaveTx ? urlTx : undefined,
            roll: tableRows
        });
        const newUrl = `${window.location.pathname}${newUrlQuery}`;
        window.history.replaceState({ path: newUrl }, '', newUrl);

        // 「SEED入力」リンクのURLを生成
        const showSeedLinkUrl = generateUrlQuery({
            seed: seedValue, ng: guaranteedRollsInput.value, fs: featuredStockInput.value, lr: urlLastRoll,
            comp: featuredCompleteCheckbox.checked, gachaId: selectedGachaId, tx: '1', roll: tableRows
        });
        showSeedInputLink.href = showSeedLinkUrl;

        // 「コンプ済み」の状態に応じてコントロールの表示を切り替える
        const populateGuaranteedRolls = (max, currentVal) => {
            const currentMax = guaranteedRollsInput.dataset.max || 0;
            // (修正) currentVal が 'none' でないか、またはオプションが未生成の場合のみ再生成
            if (currentMax == max && guaranteedRollsInput.options.length > 1 && (currentVal === 'none' || guaranteedRollsInput.querySelector(`option[value="${currentVal}"]`))) {
                guaranteedRollsInput.value = currentVal;
                return;
            }
            guaranteedRollsInput.innerHTML = '';
            const unsetOption = document.createElement('option');
            unsetOption.value = 'none';
            unsetOption.textContent = '未設定';
            guaranteedRollsInput.appendChild(unsetOption);
            for (let i = 1; i <= max; i++) {
                const option = document.createElement('option');
                option.value = i;
                option.textContent = i;
                guaranteedRollsInput.appendChild(option);
            }
            guaranteedRollsInput.dataset.max = max;
            if (guaranteedRollsInput.querySelector(`option[value="${currentVal}"]`)) {
                guaranteedRollsInput.value = currentVal;
            } else {
                guaranteedRollsInput.value = 'none';
            }
        };

        if (isFeaturedComplete) {
            stockControl.classList.add('hidden-control');
            // (修正) uberGuaranteedFlag または legendGuaranteedFlag が true なら確定枠を表示 (周期 10)
            if (gacha.uberGuaranteedFlag || gacha.legendGuaranteedFlag) {
                guaranteedControl.classList.remove('hidden-control');
                populateGuaranteedRolls(10, guaranteedRollsValue); // (修正) max=10, 値を guaranteedRollsValue で設定
            } else {
                guaranteedControl.classList.add('hidden-control');
                guaranteedRollsInput.value = 'none';
            }
        } else {
            guaranteedControl.classList.remove('hidden-control');
            stockControl.classList.remove('hidden-control');
            populateGuaranteedRolls(gacha.guaranteedCycle || 30, guaranteedRollsValue); // (修正) 値を guaranteedRollsValue で設定
        }

        // 'tx'パラメータに応じてSEED入力欄の表示/非表示を切り替える
        if (!shouldHaveTx) {
            seedRow.classList.add('hidden-control');
            seedLinkContainer.classList.remove('hidden-control');
        } else {
            seedRow.classList.remove('hidden-control');
            seedLinkContainer.classList.add('hidden-control');
        }

        // 「LastRoll」のアイテム名を表示
        const lastRollDisplay = document.getElementById('lastRollDisplay');
        if (lastRollItemId !== null && itemMaster[lastRollItemId]) {
            lastRollDisplay.textContent = `LastRoll: ${itemMaster[lastRollItemId].name}`;
        } else {
            lastRollDisplay.textContent = ''; // なければクリア
        }
    }

    // 再抽選の強制表示モードを切り替える関数
    function toggleReGachaMode() {
        forceReGachaMode = !forceReGachaMode; // フラグを反転
        runSimulationAndDisplay(); // シミュレーションを再実行
    }

    // 計算結果を元にHTMLのテーブルを生成して表示する関数
    function createAndDisplayTable(items, rarities, isfeaturedItemCell, path, tenPullRows, reGachaItems, gachaId, expectedFeaturedItemsArray, currentGuaranteedRolls, initialStockForUrl, reRolledIndicesOnPath, visualToDataMap, canReRollRarity1, lastItemIdsOnPath, tableRows) {
        const gacha = gachaMaster[gachaId];
        const guaranteedCycle = gacha.guaranteedCycle || 30;
        const isFeaturedComplete = featuredCompleteCheckbox.checked;
        
        // (修正) 渡された currentGuaranteedRolls (文字列 'none' の可能性がある) を数値に変換
        const initialGuaranteedRolls = parseInt(currentGuaranteedRolls, 10); // NaN または数値

        // G列用の確定超激・伝説レアを計算するヘルパー関数
        const getGuaranteedUber = (dataIndex) => {
            // (修正) uberGuaranteedFlag または legendGuaranteedFlag のどちらかが true であれば実行
            if ((!gacha.uberGuaranteedFlag && !gacha.legendGuaranteedFlag) || !isFeaturedComplete || dataIndex === undefined || dataIndex + 1 >= xorshiftArray.length) return null;

            const uberRate = gacha.rarityRates['3'];
            const legendRate = gacha.rarityRates['4'];
            const hasUbers = gacha.rarityItems['3'] && gacha.rarityItems['3'].length > 0;
            const hasLegends = gacha.rarityItems['4'] && gacha.rarityItems['4'].length > 0;

            // (修正) 実際にプールに存在するレートのみを考慮する
            const effectiveUberRate = hasUbers ? uberRate : 0;
            const effectiveLegendRate = hasLegends ? legendRate : 0;
            const totalRate = effectiveUberRate + effectiveLegendRate;

            if (totalRate === 0) return null; // No ubers or legends in the pool

            // (修正) 1シード目（レアリティ判定） - xorshiftArray[dataIndex] がレアリティ抽選用シード
            const rarityRoll = xorshiftArray[dataIndex] % totalRate;
            
            let rarityId;
            let itemPool;
            
            // (修正) レートに基づいてレアリティを決定
            if (rarityRoll < effectiveUberRate) {
                rarityId = 3; // 超激レア
                itemPool = gacha.rarityItems[rarityId];
            } else {
                rarityId = 4; // 伝説レア
                itemPool = gacha.rarityItems[rarityId];
            }

            if (!itemPool || itemPool.length === 0) return null; // Should not happen with effective rates, but for safety

            // (修正) 2シード目（キャラ判定） - xorshiftArray[dataIndex + 1] がアイテム抽選用シード
            const itemRoll = xorshiftArray[dataIndex + 1] % itemPool.length;
            const itemId = itemPool[itemRoll];
            return itemMaster[itemId] ? itemMaster[itemId].name : "不明";
        };

        // パス上にないセルが再抽選の対象となるかを判定するヘルパー関数
        function isReRollTriggeredOffPath(index) {
            if (isFeaturedComplete) {
                const dataIndex = visualToDataMap.get(index) ?? (Math.floor(index / 3) * 2 + (index % 3));
                const isReRoll = (dataIndex >= 2 && rarities[dataIndex] === 1 && items[dataIndex] === items[dataIndex - 2] && canReRollRarity1) || 
                                 (dataIndex >= 5 && rarities[dataIndex] === 1 && canReRollRarity1 && rarities[dataIndex - 3] === 1 && items[dataIndex - 3] === items[dataIndex - 5] && reGachaItems[dataIndex - 3] !== "---" && items[dataIndex] === itemNameMap[reGachaItems[dataIndex - 3]]);
                return isReRoll;
            } else {
                const simpleCase = (index >= 3 && rarities[index] === 1 && items[index] !== -1 && items[index] === items[index - 3] && canReRollRarity1);
                const reRollChainCase = (index >= 7 && rarities[index] === 1 && canReRollRarity1 && 
                                         rarities[index - 4] === 1 && items[index - 4] === items[index - 7] &&
                                         reGachaItems[index - 4] !== "---" && items[index] === itemNameMap[reGachaItems[index - 4]]);
                const featuredInMiddleCase = (index >= 6 && rarities[index] === 1 && isfeaturedItemCell[index - 3] && items[index] !== -1 && items[index] === items[index - 6] && canReRollRarity1);
                return simpleCase || reRollChainCase || featuredInMiddleCase;
            }
        }

        const pathSet = new Set(path);
        let table;

        if (isFeaturedComplete) {
            table = '<table><thead><tr><th class="row-number-header">❐</th><th>A</th><th>AG</th><th>B</th><th>BG</th></tr></thead><tbody>';
            for (let r = 0; r < tableRows; r++) {
                table += `<tr><td>${r + 1}</td>`;

                let cells = {
                    A: { content: '---', classList: ['re-gacha-cell'] },
                    AG: { content: '', classList: ['re-gacha-cell'] },
                    B: { content: '---', classList: ['re-gacha-cell'] },
                    BG: { content: '', classList: ['re-gacha-cell'] }
                };

                for (let c = 0; c < 2; c++) { // Process A and B columns
                    const visualIndex = r * 3 + c;
                    const colName = (c === 0) ? 'A' : 'B';
                    let cellContent = "---";
                    let classList = ['re-gacha-cell'];

                    if (pathSet.has(visualIndex)) {
                        classList.push('path-cell');
                        const dataIndex = visualToDataMap.get(visualIndex);
                        const pathPosition = path.indexOf(visualIndex);
                        const currentRollNumber = pathPosition + 1;
                        if (currentRollNumber > 0 && currentRollNumber % 10 === 0) classList.push('path-cell-milestone');

                        // (修正) 確定枠の周期を決定 (コンプ済み時)
                        const currentGuaranteedCycle = (gacha.uberGuaranteedFlag || gacha.legendGuaranteedFlag) ? 10 : guaranteedCycle;

                        // (★★★ ユーザーリクエストにより修正 ★★★) 
                        // next guaranteed の値に関わらず、常に確定枠の内容を表示
                        const guaranteedItemName = getGuaranteedUber(dataIndex);
                        if (guaranteedItemName) {
                            cells[colName + 'G'].content = `<span class="featuredItem-text">${guaranteedItemName}</span>`;
                        }

                        // (修正) 次の確定枠までの残り回数を計算 (リンク生成用)
                        let nextGuaranteedParam = 'none';
                        if (!isNaN(initialGuaranteedRolls)) {
                            let nextGuaranteed = initialGuaranteedRolls - currentRollNumber;
                            while (nextGuaranteed <= 0) {
                                nextGuaranteed += currentGuaranteedCycle;
                            }
                            nextGuaranteedParam = nextGuaranteed;
                        }

                        const showReGachaOnPath = (forceReGachaMode && reGachaItems[dataIndex] !== "---") || reRolledIndicesOnPath.has(visualIndex);
                        if (showReGachaOnPath) {
                            const r_re = Math.floor(visualIndex / 3), c_re = visualIndex % 3;
                            let nextReroll_r, nextReroll_c;
                            if (c_re === 0) { nextReroll_r = r_re; nextReroll_c = 1; } // (修正) A列 -> B列 (同じ行)
                            else { nextReroll_r = r_re + 1; nextReroll_c = 0; } // (修正) B列 -> A列 (次の行)
                            const nextRerollRollAddress = `${String.fromCharCode('A'.charCodeAt(0) + nextReroll_c)}${nextReroll_r + 1}`;
                            
                            const reGachaItemName = reGachaItems[dataIndex];
                            const reGachaItemId = itemNameMap[reGachaItemName];
                            const originalItemName = itemMaster[items[dataIndex]] ? itemMaster[items[dataIndex]].name : "不明";
                            const originalItemId = items[dataIndex];

                            // (修正) リンクに nextGuaranteedParam を使用
                            const reGachaLinkParams = { seed: xorshiftArray[dataIndex + 2], ng: nextGuaranteedParam, lr: reGachaItemId, comp: true, gachaId: gachaId };
                            const originalItemLinkParams = { seed: xorshiftArray[dataIndex + 1], ng: nextGuaranteedParam, lr: originalItemId, comp: true, gachaId: gachaId };

                            const originalItemContent = `<a href="${generateUrlQuery(originalItemLinkParams)}">${originalItemName}</a>`;
                            const reGachaLink = `<a href="${generateUrlQuery(reGachaLinkParams)}">${nextRerollRollAddress})${reGachaItemName}</a>`;
                            cellContent = `${originalItemContent}<br>${reGachaLink}`;
                        } else {
                            const currentItemId = items[dataIndex];
                            // (修正) リンクに nextGuaranteedParam を使用
                            const r_next = Math.floor(visualIndex / 3), c_next = visualIndex % 3;
                            let next_r, next_c;
                            if (c_next === 0) { next_r = r_next; next_c = 1; } // (修正) A列 -> B列 (同じ行)
                            else { next_r = r_next + 1; next_c = 0; } // (修正) B列 -> A列 (次の行)
                            const nextRollAddress = `${String.fromCharCode('A'.charCodeAt(0) + next_c)}${next_r + 1}`;
                            
                            const href = generateUrlQuery({ seed: xorshiftArray[dataIndex + 1], ng: nextGuaranteedParam, lr: currentItemId, comp: true, gachaId: gachaId });
                            const itemDisplayName = itemMaster[currentItemId] ? itemMaster[currentItemId].name : '---';
                            cellContent = `<a href="${href}">${nextRollAddress})${itemDisplayName}</a>`; // (修正) 次のセルへのリンク形式に変更
                            if (itemMaster[currentItemId] && (itemMaster[currentItemId].rarity === 3 || itemMaster[currentItemId].rarity === 4)) {
                                cellContent = `<span class="featuredItem-text">${cellContent}</span>`;
                            }
                        }
                    } else {
                        // オフパスのセル (コンプ済みモードでは C列 と、パス生成が追いついていない A/B列)
                        const offPathDataIndex = visualToDataMap.get(visualIndex); // マップにあれば使う
                        if(offPathDataIndex !== undefined) { // マップにある (＝パスの一部だが、表示範囲外などで pathSet にないだけ)
                             const currentItemId = items[offPathDataIndex];
                             if (itemMaster[currentItemId]) {
                                const href = generateUrlQuery({ seed: xorshiftArray[offPathDataIndex + 1], comp: true, lr: currentItemId, gachaId: gachaId, ng: 'none' });
                                cellContent = `<a href="${href}">${itemMaster[currentItemId].name}</a>`;
                                if (itemMaster[currentItemId].rarity === 3 || itemMaster[currentItemId].rarity === 4) {
                                    cellContent = `<span class="featuredItem-text">${cellContent}</span>`;
                                }
                             }
                        } else if (c < 2) { // パス生成が追いついていない A/B 列
                             cellContent = "---";
                        } else { // C列
                             cellContent = ""; // C列は空白
                        }
                    }
                    cells[colName].content = cellContent;
                    cells[colName].classList = classList;
                }
                table += `<td class="${cells.A.classList.join(' ')}">${cells.A.content}</td>`;
                table += `<td class="${cells.AG.classList.join(' ')}">${cells.AG.content}</td>`;
                table += `<td class="${cells.B.classList.join(' ')}">${cells.B.content}</td>`;
                table += `<td class="${cells.BG.classList.join(' ')}">${cells.BG.content}</td>`;
                table += '</tr>';
            }
        } else {
            // 従来: ABCG レイアウト
            table = '<table><thead><tr><th class="row-number-header">❐</th><th>A</th><th>B</th><th>C</th><th>G</th></tr></thead><tbody>';
            for (let r = 0; r < tableRows; r++) {
                table += `<tr><td>${r + 1}</td>`;
                for (let c = 0; c < 3; c++) {
                    const index = r * 3 + c;
                    if (index >= items.length) { table += `<td>---</td>`; continue; };

                    let classList = ['re-gacha-cell'];
                    let cellContent = "---";
                    const isOnPath = pathSet.has(index);
                    if (isOnPath) {
                        classList.push('path-cell');
                    }

                    const showReGacha = (forceReGachaMode && reGachaItems[index] !== "---") ||
                                        (isOnPath && reRolledIndicesOnPath.has(index)) ||
                                        (!isOnPath && isReRollTriggeredOffPath(index));
                    
                    // (修正) パス上かどうかに応じて、次の ng, fs, comp, lr パラメータを計算
                    let nextGuaranteedParam = 'none';
                    let stockParam = (initialStockForUrl === Infinity) ? 'none' : initialStockForUrl;
                    let compParam = isFeaturedComplete;
                    let lrParam = -1; // デフォルト
                    let pathPosition = -1;
                    let currentSlotNumber = -1;
                    
                    if (isOnPath) {
                        pathPosition = path.indexOf(index);
                        currentSlotNumber = pathPosition + 1;
                        
                        // ng (next guaranteed)
                        if (!isNaN(initialGuaranteedRolls)) {
                            let nextGuaranteed = initialGuaranteedRolls - currentSlotNumber;
                            while(nextGuaranteed <= 0) { nextGuaranteed += guaranteedCycle; }
                            nextGuaranteedParam = nextGuaranteed;
                        }
                        
                        // fs (featured stock) & comp (complete)
                        const featuredSlots = new Set();
                        for (let i = 0; i <= pathPosition; i++) { 
                             const rollNum = i + 1;
                             if (isfeaturedItemCell[path[i]] || (!isNaN(initialGuaranteedRolls) && rollNum >= initialGuaranteedRolls && (rollNum - initialGuaranteedRolls) % guaranteedCycle === 0)) {
                                 featuredSlots.add(path[i]); 
                             }
                        }
                        const stockAfterThisRoll = Math.max(0, initialStockForUrl - featuredSlots.size);
                        stockParam = (stockAfterThisRoll === Infinity) ? 'none' : stockAfterThisRoll;
                        compParam = stockAfterThisRoll === 0;
                    }

                    if (isfeaturedItemCell[index]) {
                        const nextIndex = index + 1;
                        const nextRollAddress = `${String.fromCharCode('A'.charCodeAt(0) + (nextIndex % 3))}${Math.floor(nextIndex / 3) + 1}`;
                        if (isOnPath) lrParam = lastItemIdsOnPath[pathPosition]; // 目玉を引く直前のアイテムID
                        
                        const linkParams = { seed: xorshiftArray[index], gachaId: gachaId, ng: nextGuaranteedParam, fs: stockParam, comp: compParam, lr: lrParam };
                        cellContent = `<a href="${generateUrlQuery(linkParams)}" class="featuredItem-text">${nextRollAddress})目玉</a>`;
                    
                    } else if (showReGacha) {
                        const nextIndex = index + 4;
                        const nextRollAddress = `${String.fromCharCode('A'.charCodeAt(0) + (nextIndex % 3))}${Math.floor(nextIndex / 3) + 1}`;
                        const reGachaItemName = reGachaItems[index];
                        const reGachaItemId = itemNameMap[reGachaItemName];
                        const originalItemName = itemMaster[items[index]] ? itemMaster[items[index]].name : "不明";
                        const originalItemId = items[index];
                        
                        lrParam = reGachaItemId; // 再抽選後のアイテムID
                        const reGachaLinkParams = { seed: xorshiftArray[index + 3], lr: lrParam, gachaId: gachaId, ng: nextGuaranteedParam, fs: stockParam, comp: compParam };
                        
                        // (修正) originalItemLink には lr として originalItemId を渡す
                        const originalItemLinkParams = { seed: xorshiftArray[index + 2], lr: originalItemId, gachaId: gachaId, ng: nextGuaranteedParam, fs: stockParam, comp: compParam };

                        let originalItemContent = originalItemName;
                        // (修正) オフパスでもリンクを表示 (ng='none', fs=initial, comp=initial, lr=originalId)
                        if (!isOnPath) {
                            originalItemLinkParams.ng = 'none';
                            originalItemLinkParams.fs = (initialStockForUrl === Infinity) ? 'none' : initialStockForUrl;
                            originalItemLinkParams.comp = featuredCompleteCheckbox.checked;
                        }
                        originalItemContent = `<a href="${generateUrlQuery(originalItemLinkParams)}">${originalItemName}</a>`;
                        
                        const reGachaLink = `<a href="${generateUrlQuery(reGachaLinkParams)}">${nextRollAddress})${reGachaItemName}</a>`;
                        cellContent = `${originalItemContent}<br>${reGachaLink}`;
                    
                    } else {
                        const currentItemId = items[index];
                        if (itemMaster[currentItemId]) {
                            lrParam = currentItemId; // 今回引いたアイテムID
                            const linkParams = { seed: xorshiftArray[index + 2], lr: lrParam, gachaId: gachaId, ng: nextGuaranteedParam, fs: stockParam, comp: compParam };
                            if (!isOnPath) { // (修正) オフパスのリンクパラメータ
                                linkParams.ng = 'none';
                                linkParams.fs = (initialStockForUrl === Infinity) ? 'none' : initialStockForUrl;
                                linkParams.comp = featuredCompleteCheckbox.checked;
                            }
                            
                            const nextIndex = index + 3; // (修正) 通常の次のインデックス
                            const nextRollAddress = `${String.fromCharCode('A'.charCodeAt(0) + (nextIndex % 3))}${Math.floor(nextIndex / 3) + 1}`;
                            
                            cellContent = `<a href="${generateUrlQuery(linkParams)}">${nextRollAddress})${itemMaster[currentItemId].name}</a>`; // (修正) 次のセルへのリンク形式
                            if (itemMaster[currentItemId].rarity === 3) {
                                cellContent = `<span class="featuredItem-text">${cellContent}</span>`;
                            }
                        }
                    }

                    if (isOnPath && !isFeaturedComplete) {
                        // (修正) 確定枠の判定 (initialGuaranteedRolls を使用)
                        if (!isNaN(initialGuaranteedRolls) && currentSlotNumber >= initialGuaranteedRolls && (currentSlotNumber - initialGuaranteedRolls) % guaranteedCycle === 0) {
                            
                            // (修正) ストック計算を再利用 (stockParam はこのロール後の値なので使えない)
                            const featuredSlots = new Set();
                            for (let i = 0; i <= pathPosition; i++) {
                                const rollNum = i + 1;
                                if (isfeaturedItemCell[path[i]] || (!isNaN(initialGuaranteedRolls) && rollNum >= initialGuaranteedRolls && (rollNum - initialGuaranteedRolls) % guaranteedCycle === 0)) {
                                    featuredSlots.add(path[i]); 
                                }
                            }
                            const stockAfterGuaranteed = Math.max(0, initialStockForUrl - featuredSlots.size);
                            const lrForGuaranteedLink = lastItemIdsOnPath[pathPosition];
                            
                            // (修正) リンクの ng パラメータを guaranteedCycle (次の確定枠までの回数) に
                            const linkHref = generateUrlQuery({ 
                                seed: (path[pathPosition] > 0) ? xorshiftArray[path[pathPosition] - 1] : parseInt(seedInput.value, 10), 
                                ng: guaranteedCycle, 
                                fs: (stockAfterGuaranteed === Infinity ? 'none' : stockAfterGuaranteed), 
                                lr: lrForGuaranteedLink, 
                                comp: stockAfterGuaranteed === 0, 
                                gachaId: gachaId 
                            });
                            cellContent = `<a href="${linkHref}" class="featuredItem-text">目玉(確定)</a>/` + cellContent;
                        }
                    }
                    table += `<td class="${classList.join(' ')}">${cellContent}</td>`;
                }

                let gCellClass = 're-gacha-cell';
                let gCellContent = '';
                if (r < 10) {
                    gCellClass += ' g-ten-pull-highlight';
                    gCellContent = tenPullRows[r] || '';
                    if (gCellContent && gCellContent.includes('目玉')) {
                        gCellContent = `<span class="featuredItem-text">${gCellContent}</span>`;
                    } else if (gCellContent) {
                        const extractedItemName = gCellContent.split('<br>').pop().replace(/.*\) /, '');
                        const extractedItemId = itemNameMap[extractedItemName];
                        if (extractedItemId !== undefined && itemMaster[extractedItemId] && (itemMaster[extractedItemId].rarity === 3 || itemMaster[extractedItemId].rarity === 4)) { // (修正) レアリティ4も
                            gCellContent = `<span class="featuredItem-text">${gCellContent}</span>`;
                        }
                    }
                } else if (r >= 10 && r < 20) {
                    gCellContent = expectedFeaturedItemsArray[r - 9];
                }
                table += `<td class="${gCellClass}">${gCellContent}</td>`;
                table += '</tr>';
            }
        }
        
        table += '</tbody></table>';
        resultTableContainer.innerHTML = table;

        const rowHeaderCell = document.querySelector('th.row-number-header');
        rowHeaderCell.textContent = forceReGachaMode ? '☑' : '❐';
        rowHeaderCell.addEventListener('click', toggleReGachaMode);
    }
    // --- ページ読み込み時の初回実行 ---
    runSimulationAndDisplay();
</script>
</body>
</html>