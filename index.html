<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>イベントガチャロールズ</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.2;
            padding: 5px;
            max-width: 1200px; /* Increased width for new layout */
            margin: 0 auto;
            background-color: #f4f7f9;
            color: #333;
            font-size: 9px;
        }
        .container {
            background: #fff;
            padding: 5px;
            border-radius: 12px;
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.1);
        }
        h1 {
            color: #004085;
            font-size: 0.9rem;
            border-bottom: 1px solid #e9ecef;
            padding-bottom: 3px;
            margin-top: 0;
            text-align: center;
        }
        .controls {
            display: flex;
            flex-direction: column;
            gap: 5px;
            margin-bottom: 10px;
            padding: 4px;
            background-color: #f9fbfd;
            border-radius: 4px;
        }
        .row {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
            gap: 5px;
            align-items: center;
        }
        .control-group-left, .control-group-right {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        .input-item {
            flex: 0 1 auto;
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 3px;
        }
        .input-item-display-only {
            flex: 0 1 auto;
            display: flex;
            align-items: center;
            font-size: 0.7rem;
            color: #555;
            padding: 0 5px;
        }
        .input-item-seed {
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 3px;
        }
        .seed-input-group {
            display: flex;
            align-items: center;
            gap: 5px;
            flex: 1 1 200px;
        }
        label {
            font-weight: 600;
            color: #555;
        }
        input[type="number"],
        select {
            padding: 3px;
            border: 1px solid #ccc;
            border-radius: 3px;
            font-size: 0.8rem;
            width: 100%;
            box-sizing: border-box;
            transition: border-color 0.3s;
        }
        input[type="number"]:focus,
        select:focus {
            outline: none;
            border-color: #007bff;
        }
        button {
            flex-shrink: 0;
            width: auto;
            padding: 5px 10px;
            background-color: #007bff;
            color: #fff;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.8rem;
            font-weight: bold;
            transition: background-color 0.3s ease, transform 0.2s ease;
        }
        .hidden-control {
            display: none !important;
        }
        #showSeedInputLink {
            color: #007bff;
            text-decoration: underline;
            cursor: pointer;
            padding: 0 5px;
        }
        #copySeedLink {
            color: #007bff;
            text-decoration: underline;
            cursor: pointer;
            white-space: nowrap;
        }

        button:hover {
            background-color: #0056b3;
            transform: translateY(-2px);
        }
        .hidden-control {
            display: none !important;
        }
        #result-container {
            margin-top: 15px;
        }
        #result-table-container {
            overflow-x: auto;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
        }
        table {
            width: 100%;
            border-collapse: collapse;
             /* table-layout: fixed; */ /* Allow flexible columns */
        }
        th, td {
            padding: 3px;
            text-align: center;
            border: 1px solid #e0e0e0;
            word-break: break-word;
            font-size: 0.8rem;
            min-width: 50px;
        }
        th {
            background-color: #f0f4f7;
            color: #444;
            font-weight: 600;
            position: sticky;
            top: 0;
            z-index: 1;
        }
        thead th:first-child {
            z-index: 2;
        }
        td {
            background-color: #fff;
        }
        .row-number-header {
            font-family: Arial, sans-serif;
            font-weight: bold;
            width: 25px;
            cursor: pointer;
        }
        .featuredItem-text {
            color: #d9534f;
            font-weight: bold;
        }
        .re-gacha-cell {
            line-height: 1.2;
        }
        .path-cell {
            background-color: #e6ffe6 !important;
        }
        .path-cell-milestone {
            background-color: #c8e6c9 !important; /* 少し濃いめの緑 */
        }
        .g-ten-pull-highlight {
            background-color: #fffacd;
        }
        a {
            color: inherit;
            text-decoration: none;
        }
        #gachaIdSelector { width: 150px; }
        #guaranteedRollsInput { width: 75px; }
        #featuredStockInput { width: 75px; }
    </style>
</head>
<body>

<div class="container">
    <h1>イベントガチャロールズ</h1>
    <div class="input-group">
        <div class="controls">
            <div class="row">
                <div class="control-group-left">
                    <div class="input-item" id="seedLinkContainer">
                        <a id="showSeedInputLink" href="#">SEED入力</a>
                    </div>
                    <div class="input-item" id="guaranteedControl">
                        <label for="guaranteedRollsInput">next guaranteed</label>
                        <select id="guaranteedRollsInput"></select>
                    </div>
                    <div id="lastRollDisplay" class="input-item-display-only">
                        </div>
                </div>
                <div class="control-group-right">
                    <div class="input-item">
                        <label for="featuredCompleteCheckbox">コンプ済み</label>
                        <input type="checkbox" id="featuredCompleteCheckbox">
                    </div>
                    <div class="input-item" id="stockControl">
                        <label for="featuredStockInput">目玉残数</label>
                        <select id="featuredStockInput"></select>
                    </div>
                    <a id="copySeedLink" href="#">Copy SEED</a>
                </div>
            </div>
            <div class="row hidden-control" id="seedRow">
                <div class="input-item-seed">
                    <label for="seedInput">SEED</label>
                    <div class="seed-input-group">
                        <input type="number" id="seedInput" value="123456789">
                        <button id="executeButton">更新</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div id="result-container">
        <div id="output"></div>
        <div id="result-table-container"></div>
    </div>
    <button id="toggleSeedDisplayButton" style="margin-top: 10px;">SEED表示</button>
    <button id="toggleProcessDisplayButton" style="margin-top: 10px;">計算過程を表示</button>
    <div id="process-display-container" style="margin-top: 15px; padding: 10px; border: 1px solid #ccc; border-radius: 5px; background-color: #f9f9f9; display: none;"></div>
</div>

<script>
    // --- グローバル変数 ---
    // これらの変数はスクリプト全体で使われるため、ここで宣言しています。
    let pathNotComplete = []; // コンプしていないとき用の進行経路
    let pathComplete = []; // コンプ済み用の進行経路
    let xorshiftArray = []; // Xorshift32アルゴリズムで生成された乱数（シード値）を格納する配列
    let moduloArray = []; // 乱数を10000で割った余り。排出率の判定に使う。
    
    // --- URLパラメータの読み込み ---
    function xorshift32(seed) { // Xorshift32というアルゴリズムで、予測可能な乱数列を生成する関数
        let x = seed; // 元になるシード値
        x ^= x << 13; // ビット演算で値をかき混ぜる
        x ^= x >>> 17; // さらにビット演算でかき混ぜる
        x ^= x << 15; // さらにビット演算でかき混ぜる
        return x >>> 0; // 32ビットの符号なし整数として結果を返す
    }
    
    // --- マスターデータ ---
    // ガチャやアイテムの基本的な情報を定義しています。
    const gachaMaster = { // ガチャごとの設定
        '34': {
            name: '(旧)ハロウィン', // ガチャ名
            featuredItemRate: 600, // 目玉アイテムの排出率 (0.01%単位)
            featuredItemStock: 5, // 目玉アイテムの在庫数
            guaranteedCycle: 30,
            uberGuaranteedFlag: false,
            legendGuaranteedFlag: false,
            rarityRates: { '0': 2000, '1': 5000, '2': 3000, '3': 0, '4': 0 },
            pool: [0, 2, 3, 4, 5, 10, 11, 12, 14]
        },
        '42': {
            name: '1.1億DL記念',
            featuredItemRate: 500,
            featuredItemStock: 5,
            guaranteedCycle: 30,
            uberGuaranteedFlag: false,
            legendGuaranteedFlag: false,
            rarityRates: { '0': 1000, '1': 5000, '2': 3000, '3': 1000, '4': 0 },
            pool: [0, 2, 3, 4, 5, 10, 11, 12, 14, 375, 381, 689]
        },
        '44': {
            name: 'ハロウィン',
            featuredItemRate: 500,
            featuredItemStock: 8,
            guaranteedCycle: 30,
            uberGuaranteedFlag: false,
            legendGuaranteedFlag: false,
            rarityRates: { '0': 2000, '1': 4900, '2': 3000, '3': 0, '4': 100 },
            pool: [0, 2, 3, 4, 5, 10, 11, 12, 14, 18]
        },
        '45': {
            name: 'にゃんこレンジャー',
            featuredItemRate: 500,
            featuredItemStock: 0,
            guaranteedCycle: 30,
            uberGuaranteedFlag: true,
            legendGuaranteedFlag: false,
            rarityRates: { '0': 0, '1': 7000, '2': 2300, '3': 500, '4': 200 },
            pool: [0,2,3,4,5,11,12,14,197,184,375,726,831]
        }
    };

    const itemMaster = {
        0: { name: "スピダ", rarity: 1 },
        2: { name: "ネコボン", rarity: 2 },
        3: { name: "ニャンピュ", rarity: 1 },
        4: { name: "おかめ", rarity: 2 },
        5: { name: "スニャ", rarity: 2 },
        10: { name: "5千XP", rarity: 0 },
        11: { name: "1万XP", rarity: 1 },
        12: { name: "3万XP", rarity: 1 },
        14: { name: "10万XP", rarity: 2 },
        18: { name: "200万XP", rarity: 4 },
        197: { name: "100万XP", rarity: 4 },
        184: { name: "ミスターニンジャ", rarity: 3 },
        375: { name: "記念ネコ", rarity: 3 },
        381: { name: "ねこ農家", rarity: 3 },
        689: { name: "石の上にも10年ネコ", rarity: 3 },
        726: { name: "ネコメダル王", rarity: 3 },
        831: { name: "スカーフにゃんこ", rarity: 3 }
    };
    
    const itemNameMap = Object.fromEntries(
        Object.entries(itemMaster).map(([id, { name }]) => [name, parseInt(id, 10)])
    );
    
    function setupGachaRarityItems() {
        for (const gachaId in gachaMaster) {
            const gacha = gachaMaster[gachaId];
            if (gacha && gacha.pool) {
                const pool = gacha.pool;
                const rarityItems = { '0': [], '1': [], '2': [], '3': [], '4': [] };

                for (const itemId of pool) {
                    const item = itemMaster[itemId];
                    if (item && rarityItems[item.rarity] !== undefined) {
                        rarityItems[item.rarity].push(itemId);
                    }
                }

                for (const rarity in rarityItems) {
                    rarityItems[rarity].sort((a, b) => a - b);
                }

                gacha.rarityItems = rarityItems;
            }
        }
    }

    const seedInput = document.getElementById('seedInput');
    const guaranteedRollsInput = document.getElementById('guaranteedRollsInput');
    const featuredStockInput = document.getElementById('featuredStockInput');
    const executeButton = document.getElementById('executeButton');
    const featuredCompleteCheckbox = document.getElementById('featuredCompleteCheckbox');
    const output = document.getElementById('output');
    const guaranteedControl = document.getElementById('guaranteedControl');
    const stockControl = document.getElementById('stockControl');
    const seedRow = document.getElementById('seedRow');
    const seedLinkContainer = document.getElementById('seedLinkContainer');
    const showSeedInputLink = document.getElementById('showSeedInputLink');
    const copySeedLink = document.getElementById('copySeedLink');
    const toggleSeedDisplayButton = document.getElementById('toggleSeedDisplayButton');
    const toggleProcessDisplayButton = document.getElementById('toggleProcessDisplayButton');
    const processDisplayContainer = document.getElementById('process-display-container');

    const resultTableContainer = document.getElementById('result-table-container');
    let forceReGachaMode = false;


    setupGachaRarityItems();

    function populateFeaturedStockInput(gachaId, preferredValue = 'none') {
        const gacha = gachaMaster[gachaId];
        if (!gacha) return;
        const stock = gacha.featuredItemStock;

        featuredStockInput.innerHTML = '';

        const unsetOption = document.createElement('option');
        unsetOption.value = 'none';
        unsetOption.textContent = '-';
        featuredStockInput.appendChild(unsetOption);

        for (let i = 1; i <= stock; i++) {
            const option = document.createElement('option');
            option.value = i;
            option.textContent = i;
            featuredStockInput.appendChild(option);
        }

        if (preferredValue && preferredValue !== 'none' && featuredStockInput.querySelector(`option[value="${preferredValue}"]`)) {
            featuredStockInput.value = preferredValue;
        } else {
            featuredStockInput.value = 'none';
        }
    }

    executeButton.addEventListener('click', () => {
        runSimulationAndDisplay({
            hideSeedInput: true,
            uiOverrides: { seed: seedInput.value }
        });
    });

    guaranteedRollsInput.addEventListener('change', () => {
        runSimulationAndDisplay({ uiOverrides: { guaranteedRolls: guaranteedRollsInput.value } });
    });

    featuredStockInput.addEventListener('change', () => {
        runSimulationAndDisplay({ uiOverrides: { featuredStock: featuredStockInput.value } });
    });

    featuredCompleteCheckbox.addEventListener('change', () => {
        runSimulationAndDisplay({
            hideSeedInput: true,
            uiOverrides: { isComplete: featuredCompleteCheckbox.checked }
        });
    });

    copySeedLink.addEventListener('click', (event) => {
        event.preventDefault();

        const currentParams = new URLSearchParams(window.location.search);
        const seedToCopy = currentParams.get('seed');
        if (!seedToCopy) return;

        if (!navigator.clipboard) {
            alert('お使いのブラウザはクリップボードAPIをサポートしていません。');
            return;
        }

        navigator.clipboard.writeText(seedToCopy).then(() => {
            const originalText = copySeedLink.textContent;
            copySeedLink.textContent = 'Copied!';
            setTimeout(() => {
                copySeedLink.textContent = originalText;
            }, 1500);
        }).catch(err => {
            console.error('クリップボードへのコピーに失敗しました: ', err);
            alert('クリップボードへのコピーに失敗しました。');
        });
    });

    toggleSeedDisplayButton.addEventListener('click', () => {
        const currentParams = new URLSearchParams(window.location.search);
        const currentDisplaySeed = currentParams.get('displaySeed') || '0';
        const newDisplaySeed = currentDisplaySeed === '0' ? '1' : '0';
        runSimulationAndDisplay({ uiOverrides: { displaySeed: newDisplaySeed } });
    });

    toggleProcessDisplayButton.addEventListener('click', () => {
        const currentParams = new URLSearchParams(window.location.search);
        const currentDisplayProcess = currentParams.get('displayProcess') || '0';
        const newDisplayProcess = currentDisplayProcess === '0' ? '1' : '0';
        runSimulationAndDisplay({ uiOverrides: { displayProcess: newDisplayProcess } });
    });

    function generateUrlQuery(params) {
        const currentUrlParams = new URLSearchParams(window.location.search);
        const urlGachaId = currentUrlParams.get('gacha');
        const currentGachaId = params.gachaId || urlGachaId || '45';

        let query = `?gacha=${currentGachaId}`;
        if (params.seed !== undefined) query += `&seed=${params.seed}`;
        if (params.ng !== undefined && params.ng !== 'none') query += `&ng=${params.ng}`;
        if (params.fs !== undefined && params.fs !== 'none' && params.fs !== Infinity) query += `&fs=${params.fs}`;
        if (params.lr !== undefined && params.lr !== -1 && params.lr !== null) query += `&lr=${params.lr}`;
        if (params.comp) query += `&comp=true`;
        if (params.tx) query += `&tx=${params.tx}`;
        if (params.roll !== undefined && params.roll !== 100) query += `&roll=${params.roll}`;
        if (params.displaySeed === '1') query += '&displaySeed=1';
        if (params.displayProcess === '1') query += '&displayProcess=1';
        return query;
    }

    function displayCalculationProcess(gacha, initialSeed, isFeaturedComplete, thresholds, tableRows, guaranteedRollsValue) {
        let processHtml = '<h3>計算過程</h3>';

        const getRarityFromRoll = (roll) => {
            if (roll < thresholds['0']) return { id: 0, name: 'ノーマル' };
            if (roll < thresholds['1']) return { id: 1, name: 'レア' };
            if (roll < thresholds['2']) return { id: 2, name: '激レア' };
            if (roll < thresholds['3']) return { id: 3, name: '超激レア' };
            return { id: 4, name: '伝説レア' };
        };

        const getItemFromPool = (seed, rarityId) => {
            const pool = gacha.rarityItems[rarityId];
            if (!pool || pool.length === 0) return { id: -1, name: '---' };
            const itemIndex = seed % pool.length;
            const itemId = pool[itemIndex];
            return { id: itemId, name: itemMaster[itemId]?.name || '不明' };
        };
        
        const getReRollItem = (seed, rarityId, originalItemId) => {
            const pool = gacha.rarityItems[rarityId];
            if (!pool || pool.length < 2) return { id: -1, name: '---' };
            const reRollPool = pool.filter(id => id !== originalItemId);
            const itemIndex = seed % reRollPool.length;
            const itemId = reRollPool[itemIndex];
            return { id: itemId, name: itemMaster[itemId]?.name || '不明' };
        };


        if (isFeaturedComplete) {
            processHtml += '<h4>ルートの計算</h4>';
            let routeSeed = initialSeed;
            for (let i = 1; i <= 10; i++) {
                const seed1 = xorshift32(routeSeed);
                const rarityRoll = seed1 % 10000;
                const rarity = getRarityFromRoll(rarityRoll);
                const seed2 = xorshift32(seed1);
                const item = getItemFromPool(seed2, rarity.id);
                
                let detail = `Roll${i}) ${seed1} % 10000 = ${rarityRoll} / ${rarity.name} / ${seed2} % ${gacha.rarityItems[rarity.id]?.length || 0} = ${seed2 % (gacha.rarityItems[rarity.id]?.length || 1)} / ${item.name}`;
                
                routeSeed = seed2;

                if (rarity.id === 1 && gacha.rarityItems[1]?.length >= 2) {
                    const seed3 = xorshift32(seed2);
                    const reRollItem = getReRollItem(seed3, 1, item.id);
                    detail += ` / (再抽選の場合) ${seed3} % ${gacha.rarityItems[1].length - 1} = ${seed3 % (gacha.rarityItems[1].length - 1)} / ${reRollItem.name}`;
                }
                processHtml += `<p>${detail}</p>`;
            }

            processHtml += '<h4>各セルの計算</h4>';
            let seedA_next = xorshift32(initialSeed);
            let seedB_next = xorshift32(xorshift32(initialSeed));

            for (let i = 1; i <= 5; i++) {
                let seedA = seedA_next;
                let seedB = seedB_next;

                const sA1 = seedA;
                const rRollA = sA1 % 10000;
                const rarityA = getRarityFromRoll(rRollA);
                const sA2 = xorshift32(sA1);
                const itemA = getItemFromPool(sA2, rarityA.id);
                processHtml += `<p>A${i}) ${sA1} % 10000 = ${rRollA} / ${rarityA.name} / ${sA2} % ${gacha.rarityItems[rarityA.id]?.length || 0} = ${sA2 % (gacha.rarityItems[rarityA.id]?.length || 1)} / ${itemA.name}</p>`;
                seedA_next = xorshift32(sA2);

                const uberRate = gacha.uberGuaranteedFlag ? gacha.rarityRates['3'] : 0;
                const legendRate = gacha.legendGuaranteedFlag ? gacha.rarityRates['4'] : 0;
                const totalGuaranteedRate = uberRate + legendRate;
                if (totalGuaranteedRate > 0) {
                    const rRollAG = sA1 % totalGuaranteedRate;
                    const rarityAG = rRollAG < uberRate ? {id: 3, name: '超激レア'} : {id: 4, name: '伝説レア'};
                    const itemAG = getItemFromPool(sA2, rarityAG.id);
                    processHtml += `<p>AG${i}) ${sA1} % ${totalGuaranteedRate} = ${rRollAG} / ${rarityAG.name} / ${sA2} % ${gacha.rarityItems[rarityAG.id]?.length || 0} = ${sA2 % (gacha.rarityItems[rarityAG.id]?.length || 1)} / ${itemAG.name}</p>`;
                }

                const sB1 = seedB;
                const rRollB = sB1 % 10000;
                const rarityB = getRarityFromRoll(rRollB);
                const sB2 = xorshift32(sB1);
                const itemB = getItemFromPool(sB2, rarityB.id);
                processHtml += `<p>B${i}) ${sB1} % 10000 = ${rRollB} / ${rarityB.name} / ${sB2} % ${gacha.rarityItems[rarityB.id]?.length || 0} = ${sB2 % (gacha.rarityItems[rarityB.id]?.length || 1)} / ${itemB.name}</p>`;
                seedB_next = xorshift32(sB2);
                
                 if (totalGuaranteedRate > 0) {
                    const rRollBG = sB1 % totalGuaranteedRate;
                    const rarityBG = rRollBG < uberRate ? {id: 3, name: '超激レア'} : {id: 4, name: '伝説レア'};
                    const itemBG = getItemFromPool(sB2, rarityBG.id);
                    processHtml += `<p>BG${i}) ${sB1} % ${totalGuaranteedRate} = ${rRollBG} / ${rarityBG.name} / ${sB2} % ${gacha.rarityItems[rarityBG.id]?.length || 0} = ${sB2 % (gacha.rarityItems[rarityBG.id]?.length || 1)} / ${itemBG.name}</p>`;
                }
            }

        } else {
            processHtml += '<h4>ルートの計算</h4>';
            let routeSeed = initialSeed;
            for (let i = 1; i <= 10; i++) {
                const seed1 = xorshift32(routeSeed);
                const featuredRoll = seed1 % 10000;
                const isFeatured = featuredRoll < gacha.featuredItemRate;
                let detail = `Roll${i}) ${seed1} % 10000 = ${featuredRoll} / ${isFeatured ? '目玉' : '通常'}`;

                if (isFeatured) {
                    routeSeed = seed1;
                } else {
                    const seed2 = xorshift32(seed1);
                    const rarityRoll = seed2 % 10000;
                    const rarity = getRarityFromRoll(rarityRoll);
                    const seed3 = xorshift32(seed2);
                    const item = getItemFromPool(seed3, rarity.id);
                    detail += ` / ${seed2} % 10000 = ${rarityRoll} / ${rarity.name} / ${seed3} % ${gacha.rarityItems[rarity.id]?.length || 0} = ${seed3 % (gacha.rarityItems[rarity.id]?.length || 1)} / ${item.name}`;
                    routeSeed = seed3;
                     if (rarity.id === 1 && gacha.rarityItems[1]?.length >= 2) {
                        const seed4 = xorshift32(seed3);
                        const reRollItem = getReRollItem(seed4, 1, item.id);
                        detail += ` / (再抽選の場合) ${seed4} % ${gacha.rarityItems[1].length - 1} = ${seed4 % (gacha.rarityItems[1].length - 1)} / ${reRollItem.name}`;
                    }
                }
                processHtml += `<p>${detail}</p>`;
            }

            processHtml += '<h4>各セルの計算</h4>';
            let seedA_next = xorshift32(initialSeed);
            let seedB_next = xorshift32(xorshift32(initialSeed));
            let seedC_next = xorshift32(xorshift32(xorshift32(initialSeed)));

            for (let i = 1; i <= 5; i++) {
                let seedA = seedA_next;
                let seedB = seedB_next;
                let seedC = seedC_next;

                const sA1 = seedA;
                const fRollA = sA1 % 10000;
                const isFeaturedA = fRollA < gacha.featuredItemRate;
                let detailA = `A${i}) ${sA1} % 10000 = ${fRollA} / ${isFeaturedA ? '目玉' : '通常'}`;
                if (isFeaturedA) {
                    seedA_next = xorshift32(sA1);
                } else {
                    const sA2 = xorshift32(sA1);
                    const rRollA = sA2 % 10000;
                    const rarityA = getRarityFromRoll(rRollA);
                    const sA3 = xorshift32(sA2);
                    const itemA = getItemFromPool(sA3, rarityA.id);
                    detailA += ` / ${sA2} % 10000 = ${rRollA} / ${rarityA.name} / ${sA3} % ${gacha.rarityItems[rarityA.id]?.length || 0} = ${sA3 % (gacha.rarityItems[rarityA.id]?.length || 1)} / ${itemA.name}`;
                    seedA_next = xorshift32(sA3);
                }
                processHtml += `<p>${detailA}</p>`;
                
                const sB1 = seedB;
                const fRollB = sB1 % 10000;
                const isFeaturedB = fRollB < gacha.featuredItemRate;
                let detailB = `B${i}) ${sB1} % 10000 = ${fRollB} / ${isFeaturedB ? '目玉' : '通常'}`;
                if (isFeaturedB) {
                    seedB_next = xorshift32(sB1);
                } else {
                    const sB2 = xorshift32(sB1);
                    const rRollB = sB2 % 10000;
                    const rarityB = getRarityFromRoll(rRollB);
                    const sB3 = xorshift32(sB2);
                    const itemB = getItemFromPool(sB3, rarityB.id);
                    detailB += ` / ${sB2} % 10000 = ${rRollB} / ${rarityB.name} / ${sB3} % ${gacha.rarityItems[rarityB.id]?.length || 0} = ${sB3 % (gacha.rarityItems[rarityB.id]?.length || 1)} / ${itemB.name}`;
                    seedB_next = xorshift32(sB3);
                }
                processHtml += `<p>${detailB}</p>`;

                const sC1 = seedC;
                const fRollC = sC1 % 10000;
                const isFeaturedC = fRollC < gacha.featuredItemRate;
                let detailC = `C${i}) ${sC1} % 10000 = ${fRollC} / ${isFeaturedC ? '目玉' : '通常'}`;
                if (isFeaturedC) {
                    seedC_next = xorshift32(sC1);
                } else {
                    const sC2 = xorshift32(sC1);
                    const rRollC = sC2 % 10000;
                    const rarityC = getRarityFromRoll(rRollC);
                    const sC3 = xorshift32(sC2);
                    const itemC = getItemFromPool(sC3, rarityC.id);
                    detailC += ` / ${sC2} % 10000 = ${rRollC} / ${rarityC.name} / ${sC3} % ${gacha.rarityItems[rarityC.id]?.length || 0} = ${sC3 % (gacha.rarityItems[rarityC.id]?.length || 1)} / ${itemC.name}`;
                    seedC_next = xorshift32(sC3);
                }
                processHtml += `<p>${detailC}</p>`;
            }

            processHtml += '<h4>G（10連）の計算</h4>';
            let gSeed = initialSeed;
            let gGuaranteedRoll = parseInt(guaranteedRollsValue, 10);
            let gFeaturedStock = gacha.featuredItemStock;

            let featuredHitSeeds = [];
            let tempSeed = gSeed;
            for(let i=0; i<10; i++){
                const s = xorshift32(tempSeed);
                featuredHitSeeds.push(s);
                tempSeed = s;
            }

            let featuredSlots = new Set();
            let seedForGOffset = 0;
            for(let i=0; i<10; i++){
                if(i + 1 === gGuaranteedRoll) continue;
                const featuredRoll = featuredHitSeeds[seedForGOffset] % 10000;
                if(featuredRoll < gacha.featuredItemRate){
                    featuredSlots.add(i);
                }
                processHtml += `<p>G-目玉判定${i+1}) ${featuredHitSeeds[seedForGOffset]} % 10000 = ${featuredRoll} / ${featuredRoll < gacha.featuredItemRate ? "目玉候補" : "通常"}</p>`;
                seedForGOffset++;
            }
            if(!isNaN(gGuaranteedRoll) && gGuaranteedRoll > 0 && gGuaranteedRoll <= 10){
                 featuredSlots.add(gGuaranteedRoll - 1);
            }


            let gItemSeed = gSeed;
            for(let i=0; i<seedForGOffset; i++) gItemSeed = xorshift32(gItemSeed);

            for (let i = 0; i < 10; i++) {
                if (featuredSlots.has(i) && gFeaturedStock > 0) {
                    processHtml += `<p>G${i + 1}) 目玉 ${i + 1 === gGuaranteedRoll ? "(確定)" : ""}</p>`;
                    gFeaturedStock--;
                } else {
                    const seed2 = xorshift32(gItemSeed);
                    const rarityRoll = seed2 % 10000;
                    const rarity = getRarityFromRoll(rarityRoll);
                    const seed3 = xorshift32(seed2);
                    const item = getItemFromPool(seed3, rarity.id);
                    processHtml += `<p>G${i + 1}) ${seed2} % 10000 = ${rarityRoll} / ${rarity.name} / ${seed3} % ${gacha.rarityItems[rarity.id]?.length || 0} = ${seed3 % (gacha.rarityItems[rarity.id]?.length || 1)} / ${item.name}</p>`;
                    gItemSeed = xorshift32(seed3);
                }
            }
        }

        processDisplayContainer.innerHTML = processHtml;
    }

    function runSimulationAndDisplay(options = {}) {
        const { hideSeedInput = false, uiOverrides = {} } = options;

        const params = new URLSearchParams(window.location.search);
        const urlSeed = params.get('seed');
        const urlGuaranteed = params.get('ng');
        const urlFeaturedStock = params.get('fs');
        const urlLastRoll = params.get('lr');
        const urlComp = params.get('comp');
        const urlGachaId = params.get('gacha');
        const urlTx = params.get('tx');
        const urlRoll = params.get('roll');
        const urlDisplaySeed = params.get('displaySeed');
        const urlDisplayProcess = params.get('displayProcess');

        const seedValueStr = uiOverrides.seed !== undefined ? uiOverrides.seed : (urlSeed || seedInput.value);
        let isFeaturedComplete = uiOverrides.isComplete !== undefined ? uiOverrides.isComplete : (urlComp === 'true');
        const guaranteedRollsValue = uiOverrides.guaranteedRolls !== undefined ? uiOverrides.guaranteedRolls : (urlGuaranteed || 'none');
        const featuredStockValue = uiOverrides.featuredStock !== undefined ? uiOverrides.featuredStock : (urlFeaturedStock || 'none');
        const displaySeedValue = uiOverrides.displaySeed !== undefined ? uiOverrides.displaySeed : (urlDisplaySeed || '0');
        const displayProcessValue = uiOverrides.displayProcess !== undefined ? uiOverrides.displayProcess : (urlDisplayProcess || '0');

        const tableRows = parseInt(urlRoll, 10) || 100;
        seedInput.value = seedValueStr;
        featuredCompleteCheckbox.checked = isFeaturedComplete;

        const selectedGachaId = urlGachaId || '45';
        const seedValue = parseInt(seedInput.value, 10);
        
        let lastRollItemId = null;
        if (urlLastRoll && !isNaN(parseInt(urlLastRoll, 10))) {
            lastRollItemId = parseInt(urlLastRoll, 10);
        }

        populateFeaturedStockInput(selectedGachaId, featuredStockValue);
        const featuredStockLimitStr = featuredStockInput.value;
        const featuredStockLimit = featuredStockLimitStr === 'none' ? Infinity : parseInt(featuredStockLimitStr, 10);

        if (isNaN(seedValue)) {
            output.textContent = '有効な数値を入力してください。';
            return;
        }

        const gacha = gachaMaster[selectedGachaId];
        if (!gacha) {
            output.textContent = '無効なガチャIDです。';
            return;
        }
        
        const featuredCompleteControl = document.getElementById('featuredCompleteCheckbox').parentElement;
        if (gacha.featuredItemStock === 0) {
            isFeaturedComplete = true;
            featuredCompleteCheckbox.checked = true;
            featuredCompleteControl.classList.add('hidden-control');
        } else {
            featuredCompleteControl.classList.remove('hidden-control');
        }

        const rates = gacha.rarityRates;
        const thresholds = {
            '0': rates['0'], '1': rates['0'] + rates['1'], '2': rates['0'] + rates['1'] + rates['2'],
            '3': rates['0'] + rates['1'] + rates['2'] + rates['3'], '4': 10000
        };

        if (displaySeedValue === '0') {
            const requiredSeeds = Math.max(1000, tableRows * 4);
            xorshiftArray = [];
            moduloArray = [];
            let currentSeed = seedValue;
            for (let i = 0; i < requiredSeeds; i++) {
                currentSeed = xorshift32(currentSeed);
                xorshiftArray.push(currentSeed);
                moduloArray.push(currentSeed % 10000);
            }

            const items = new Array(requiredSeeds).fill(-1);
            const rarities = new Array(requiredSeeds).fill(-1);
            const reGachaItemIds = new Array(requiredSeeds).fill(-1);
            const isfeaturedItemCell = new Array(requiredSeeds).fill(false);

            for (let i = 0; i < requiredSeeds; i++) {
                let hitSeedIndex, raritySeedIndex, itemSeedIndex, reGachaSeedIndexOffset;
                if (isFeaturedComplete) {
                    hitSeedIndex = -1; raritySeedIndex = i; itemSeedIndex = i + 1; reGachaSeedIndexOffset = 2;
                } else {
                    hitSeedIndex = i; raritySeedIndex = i + 1; itemSeedIndex = i + 2; reGachaSeedIndexOffset = 3;
                }
                if (itemSeedIndex >= xorshiftArray.length) continue;
                isfeaturedItemCell[i] = !isFeaturedComplete && (moduloArray[hitSeedIndex] < gacha.featuredItemRate);
                if (isfeaturedItemCell[i]) continue;
                
                let rarityId;
                if (moduloArray[raritySeedIndex] < thresholds['0']) { rarityId = 0; }
                else if (moduloArray[raritySeedIndex] < thresholds['1']) { rarityId = 1; }
                else if (moduloArray[raritySeedIndex] < thresholds['2']) { rarityId = 2; }
                else if (moduloArray[raritySeedIndex] < thresholds['3']) { rarityId = 3; }
                else { rarityId = 4; }
                rarities[i] = rarityId;

                const itemInfo = gacha.rarityItems[rarityId];
                const itemCounts = itemInfo.length;
                if (itemCounts > 0) {
                    const itemOffset = xorshiftArray[itemSeedIndex] % itemCounts;
                    items[i] = itemInfo[itemOffset];
                }

                if (rarityId === 1 && itemCounts >= 2) {
                    const reGachaSeedIndex = i + reGachaSeedIndexOffset;
                    if (reGachaSeedIndex < xorshiftArray.length) {
                        const originalItemNoList = [...itemInfo];
                        const itemIndex = originalItemNoList.indexOf(items[i]);
                        if (itemIndex > -1) originalItemNoList.splice(itemIndex, 1);
                        if (originalItemNoList.length > 0) {
                            reGachaItemIds[i] = originalItemNoList[xorshiftArray[reGachaSeedIndex] % originalItemNoList.length];
                        }
                    }
                }
            }

            let currentPath;
            const reRolledIndicesOnPath = new Set();
            const lastItemIdsOnPath = [];
            const visualToDataMap = new Map();
            let lastActualItemId = lastRollItemId !== null ? lastRollItemId : -1;
            const canReRollRarity1 = gacha.rarityItems[1] && gacha.rarityItems[1].length >= 2;

            if (isFeaturedComplete) {
                pathComplete = []; currentPath = pathComplete; let dataIndex = 0;
                for (let r = 0; r < tableRows; r++) {
                    for (let c = 0; c < 2; c++) {
                        if (dataIndex >= requiredSeeds) break;
                        const visualIndex = r * 3 + c;
                        lastItemIdsOnPath.push(lastActualItemId);
                        currentPath.push(visualIndex);
                        visualToDataMap.set(visualIndex, dataIndex);
                        const isReRoll = canReRollRarity1 && rarities[dataIndex] === 1 && lastActualItemId === items[dataIndex];
                        if (isReRoll) {
                            reRolledIndicesOnPath.add(visualIndex);
                            lastActualItemId = reGachaItemIds[dataIndex];
                            dataIndex += 3;
                        } else {
                            lastActualItemId = items[dataIndex];
                            dataIndex += 2;
                        }
                    }
                    if (dataIndex >= requiredSeeds) break;
                }
            } else {
                pathNotComplete = []; currentPath = pathNotComplete; let dataIndex = 0;
                while (dataIndex < requiredSeeds) {
                    lastItemIdsOnPath.push(lastActualItemId);
                    const visualIndex = dataIndex;
                    currentPath.push(visualIndex);
                    const isReRoll = canReRollRarity1 && rarities[dataIndex] === 1 && lastActualItemId === items[dataIndex];
                    if (isfeaturedItemCell[dataIndex]) { dataIndex += 1; }
                    else if (isReRoll) {
                        reRolledIndicesOnPath.add(visualIndex);
                        lastActualItemId = reGachaItemIds[dataIndex];
                        dataIndex += 4;
                    } else {
                        lastActualItemId = items[dataIndex];
                        dataIndex += 3;
                    }
                }
            }

            const reGachaItems = new Array(requiredSeeds).fill("---");
            for (let i = 0; i < requiredSeeds; i++) {
                if (reGachaItemIds[i] !== -1 && itemMaster[reGachaItemIds[i]]) {
                    reGachaItems[i] = itemMaster[reGachaItemIds[i]].name;
                }
            }

            const tenPullResults = new Array(10).fill(null);
            const tenPullRarities = new Array(10).fill(-1);
            const isFeaturedSlot = new Array(10).fill(false);
            let seedOffsetForG = 0;
            const firstGuaranteedRollsForG = parseInt(guaranteedRollsValue, 10) || 30;
            const isGuaranteedInTenPull = firstGuaranteedRollsForG > 0 && firstGuaranteedRollsForG <= 10;
            const guaranteedSlotIndex = isGuaranteedInTenPull ? firstGuaranteedRollsForG - 1 : -1;
            
            if (!isFeaturedComplete) {
                const lotteryHitSlots = [];
                let hitCheckSeedOffset = 0;
                for (let i = 0; i < 10; i++) {
                    if (i === guaranteedSlotIndex) continue;
                    if (moduloArray[hitCheckSeedOffset] < gacha.featuredItemRate) lotteryHitSlots.push(i);
                    hitCheckSeedOffset++;
                }

                let featuredItemsDrawnCount = 0;
                for (const slotIndex of lotteryHitSlots) {
                    if (featuredItemsDrawnCount < featuredStockLimit) { isFeaturedSlot[slotIndex] = true; featuredItemsDrawnCount++; }
                }
                if (guaranteedSlotIndex !== -1 && featuredItemsDrawnCount < featuredStockLimit && !isFeaturedSlot[guaranteedSlotIndex]) {
                    isFeaturedSlot[guaranteedSlotIndex] = true;
                }
                seedOffsetForG = hitCheckSeedOffset;
            }

            let prevItemIdForG = lastRollItemId !== null ? lastRollItemId : -1;
            for (let i = 0; i < 10; i++) {
                if (isFeaturedSlot[i]) {
                    tenPullResults[i] = (i === guaranteedSlotIndex) ? '目玉(確定)' : '目玉';
                    continue;
                }
                const raritySeedIndex = seedOffsetForG; const itemSeedIndex = seedOffsetForG + 1; const reGachaSeedIndex = seedOffsetForG + 2;
                
                let rarityId;
                if (moduloArray[raritySeedIndex] < thresholds['0']) { rarityId = 0; }
                else if (moduloArray[raritySeedIndex] < thresholds['1']) { rarityId = 1; }
                else if (moduloArray[raritySeedIndex] < thresholds['2']) { rarityId = 2; }
                else if (moduloArray[raritySeedIndex] < thresholds['3']) { rarityId = 3; }
                else { rarityId = 4; }
                if (i === 9) tenPullRarities[i] = rarityId;

                const itemInfo = gacha.rarityItems[rarityId];
                let itemName = "---"; let currentItemId = -1;
                if (itemInfo.length > 0) {
                    currentItemId = itemInfo[xorshiftArray[itemSeedIndex] % itemInfo.length];
                    itemName = itemMaster[currentItemId] ? itemMaster[currentItemId].name : "不明";
                }
                
                let displayItemName = itemName; let seedsForThisRoll = 2;
                if (rarityId === 1 && itemInfo.length >= 2 && prevItemIdForG !== -1 && prevItemIdForG === currentItemId) {
                    if (reGachaSeedIndex < xorshiftArray.length) {
                        const originalItemNoList = [...itemInfo];
                        const itemIndex = originalItemNoList.indexOf(currentItemId);
                        if (itemIndex > -1) originalItemNoList.splice(itemIndex, 1);
                        if (originalItemNoList.length > 0) {
                            const reGachaItemId = originalItemNoList[xorshiftArray[reGachaSeedIndex] % originalItemNoList.length];
                            displayItemName = `${itemName}<br>${itemMaster[reGachaItemId].name}`;
                            prevItemIdForG = reGachaItemId;
                            seedsForThisRoll++;
                        } else { prevItemIdForG = currentItemId; }
                    } else { prevItemIdForG = currentItemId; }
                } else { prevItemIdForG = currentItemId; }
                
                tenPullResults[i] = displayItemName;
                seedOffsetForG += seedsForThisRoll;
            }

            const expectedFeaturedItemsArray = [];
            const initialGuaranteedRollsForG = parseInt(guaranteedRollsValue, 10);
            for (let start = 1; start <= 10; start++) {
                 if (currentPath[start] === undefined || isFeaturedComplete) {
                    expectedFeaturedItemsArray[start] = isFeaturedComplete ? 0 : "---"; continue;
                 }
                const featuredSlotsBefore = new Set();
                for (let i = 0; i < start; i++) {
                    const pIndex = currentPath[i]; const rollNumber = i + 1;
                    if (isfeaturedItemCell[pIndex]) featuredSlotsBefore.add(pIndex);
                    if (!isNaN(initialGuaranteedRollsForG) && rollNumber >= initialGuaranteedRollsForG && (rollNumber - initialGuaranteedRollsForG) % gacha.guaranteedCycle === 0) {
                         featuredSlots.add(pIndex); 
                     }
                }
                const stockAfterSingle = Math.max(0, featuredStockLimit - featuredSlots.size);
                let guaranteedRollsForThisTenPull = 'none';
                if (!isNaN(initialGuaranteedRollsForG)) {
                    let nextG = initialGuaranteedRollsForG - start;
                    while (nextG <= 0) { nextG += gacha.guaranteedCycle; }
                    guaranteedRollsForThisTenPull = nextG;
                }
                const isGuaranteedInThisTenPull = guaranteedRollsForThisTenPull !== 'none' && guaranteedRollsForThisTenPull > 0 && guaranteedRollsForThisTenPull <= 10;
                const guaranteedSlotIndexInThisTenPull = isGuaranteedInThisTenPull ? guaranteedRollsForThisTenPull - 1 : -1;
                const lotteryHitSlots = [];
                let hitCheckSeedOffset = 0;
                for (let i = 0; i < 10; i++) {
                    if (i === guaranteedSlotIndexInThisTenPull) continue;
                    const seedIndex = currentPath[start] + hitCheckSeedOffset;
                    if (seedIndex < moduloArray.length && moduloArray[seedIndex] < gacha.featuredItemRate) lotteryHitSlots.push(i);
                    hitCheckSeedOffset++;
                }
                let featuredItemsDrawnInThisTenPull = 0;
                const finalFeaturedSlotsInThisTenPull = new Array(10).fill(false);
                for (const slotIndex of lotteryHitSlots) {
                    if (featuredItemsDrawnInThisTenPull < stockAfterSingle) { finalFeaturedSlotsInThisTenPull[slotIndex] = true; featuredItemsDrawnInThisTenPull++; }
                }
                if (guaranteedSlotIndexInThisTenPull !== -1 && featuredItemsDrawnInThisTenPull < stockAfterSingle && !finalFeaturedSlotsInThisTenPull[guaranteedSlotIndexInThisTenPull]) {
                    finalFeaturedSlotsInThisTenPull[guaranteedSlotIndexInThisTenPull] = true;
                }
                expectedFeaturedItemsArray[start] = finalFeaturedSlotsInThisTenPull.filter(Boolean).length;
            }

            createAndDisplayTableOriginal(items, rarities, isfeaturedItemCell, currentPath, tenPullResults, reGachaItems, selectedGachaId, expectedFeaturedItemsArray, guaranteedRollsValue, featuredStockLimit, reRolledIndicesOnPath, visualToDataMap, canReRollRarity1, lastItemIdsOnPath, tableRows, reGachaItemIds, displaySeedValue, seedValue);

        } else {
            createAndDisplayTableSeedView(gacha, tableRows, seedValue, isFeaturedComplete, thresholds);
        }

        const shouldHaveTx = urlTx && !hideSeedInput;
        const newUrlQuery = generateUrlQuery({
            seed: seedValue, ng: guaranteedRollsValue, fs: featuredStockValue, lr: urlLastRoll,
            comp: isFeaturedComplete, gachaId: selectedGachaId, tx: shouldHaveTx ? urlTx : undefined,
            roll: tableRows, displaySeed: displaySeedValue, displayProcess: displayProcessValue
        });
        const newUrl = `${window.location.pathname}${newUrlQuery}`;
        window.history.replaceState({ path: newUrl }, '', newUrl);

        if (displayProcessValue === '1') {
            processDisplayContainer.style.display = 'block';
            displayCalculationProcess(gacha, seedValue, isFeaturedComplete, thresholds, tableRows, guaranteedRollsValue);
        } else {
            processDisplayContainer.style.display = 'none';
            processDisplayContainer.innerHTML = '';
        }

        const showSeedLinkUrl = generateUrlQuery({
            seed: seedValue, ng: guaranteedRollsValue, fs: featuredStockValue, lr: urlLastRoll,
            comp: isFeaturedComplete, gachaId: selectedGachaId, tx: '1', roll: tableRows, displaySeed: displaySeedValue, displayProcess: displayProcessValue
        });
        showSeedInputLink.href = showSeedLinkUrl;

        const populateGuaranteedRolls = (max, currentVal) => {
            const currentMax = guaranteedRollsInput.dataset.max || 0;
            if (currentMax == max && guaranteedRollsInput.options.length > 1 && (currentVal === 'none' || guaranteedRollsInput.querySelector(`option[value="${currentVal}"]`))) {
                guaranteedRollsInput.value = currentVal; return;
            }
            guaranteedRollsInput.innerHTML = '';
            const unsetOption = document.createElement('option');
            unsetOption.value = 'none'; unsetOption.textContent = '未設定'; guaranteedRollsInput.appendChild(unsetOption);
            for (let i = 1; i <= max; i++) {
                const option = document.createElement('option'); option.value = i; option.textContent = i; guaranteedRollsInput.appendChild(option);
            }
            guaranteedRollsInput.dataset.max = max;
            if (guaranteedRollsInput.querySelector(`option[value="${currentVal}"]`)) {
                guaranteedRollsInput.value = currentVal;
            } else {
                guaranteedRollsInput.value = 'none';
            }
        };

        if (isFeaturedComplete) {
            stockControl.classList.add('hidden-control');
            if (gacha.uberGuaranteedFlag || gacha.legendGuaranteedFlag) {
                guaranteedControl.classList.remove('hidden-control');
                populateGuaranteedRolls(10, guaranteedRollsValue);
            } else {
                guaranteedControl.classList.add('hidden-control');
                guaranteedRollsInput.value = 'none';
            }
        } else {
            guaranteedControl.classList.remove('hidden-control');
            stockControl.classList.remove('hidden-control');
            populateGuaranteedRolls(gacha.guaranteedCycle || 30, guaranteedRollsValue);
        }

        if (!shouldHaveTx) {
            seedRow.classList.add('hidden-control');
            seedLinkContainer.classList.remove('hidden-control');
        } else {
            seedRow.classList.remove('hidden-control');
            seedLinkContainer.classList.add('hidden-control');
        }

        const lastRollDisplay = document.getElementById('lastRollDisplay');
        if (lastRollItemId !== null && itemMaster[lastRollItemId]) {
            lastRollDisplay.textContent = `LastRoll: ${itemMaster[lastRollItemId].name}`;
        } else {
            lastRollDisplay.textContent = '';
        }
    }

    function toggleReGachaMode() {
        forceReGachaMode = !forceReGachaMode;
        runSimulationAndDisplay();
    }

    function createAndDisplayTableSeedView(gacha, tableRows, initialSeed, isFeaturedComplete, thresholds) {
        let table = '<table>';
        let header1 = '<tr><th class="row-number-header" rowspan="2">❐</th>';
        let header2 = '<tr>';
        
        if (isFeaturedComplete) {
            header1 += '<th colspan="3">A</th><th rowspan="2">AG</th><th colspan="3">B</th><th rowspan="2">BG</th>';
            header2 += '<th>S1</th><th>S2</th><th>Item</th>';
            header2 += '<th>S1</th><th>S2</th><th>Item</th>';
        } else {
            const mainHeaders = ['A', 'B', 'C'];
            mainHeaders.forEach(h => { header1 += `<th colspan="4">${h}</th>`; });
            header1 += `<th rowspan="2">G</th>`;
            mainHeaders.forEach(() => {
                header2 += `<th>S1</th><th>S2</th><th>S3</th><th>Item</th>`;
            });
        }

        header1 += '</tr>';
        header2 += '</tr>';
        table += `<thead>${header1}${header2}</thead><tbody>`;

        const mainHeaders = isFeaturedComplete ? ['A', 'B'] : ['A', 'B', 'C'];
        let columnStartSeeds = mainHeaders.map((_, i) => {
            let seed = initialSeed;
            for(let j = 0; j <= i; j++) seed = xorshift32(seed);
            return seed;
        });

        for (let r = 0; r < tableRows; r++) {
            let rowHtml = `<tr><td>${r + 1}</td>`;
            let nextColumnStartSeeds = [];

            if (isFeaturedComplete) {
                const simResultA = simulateCellForSeedView(columnStartSeeds[0], -1, gacha, true, thresholds);
                nextColumnStartSeeds.push(simResultA.nextSeed);
                simResultA.seeds.forEach(s => rowHtml += `<td>${s}</td>`);
                rowHtml += `<td>${simResultA.itemContent}</td>`;
                rowHtml += `<td>${simResultA.guaranteedItemContent}</td>`;

                const simResultB = simulateCellForSeedView(columnStartSeeds[1], -1, gacha, true, thresholds);
                nextColumnStartSeeds.push(simResultB.nextSeed);
                simResultB.seeds.forEach(s => rowHtml += `<td>${s}</td>`);
                rowHtml += `<td>${simResultB.itemContent}</td>`;
                rowHtml += `<td>${simResultB.guaranteedItemContent}</td>`;

            } else {
                 columnStartSeeds.forEach((startSeed) => {
                    const simResult = simulateCellForSeedView(startSeed, -1, gacha, false, thresholds);
                    nextColumnStartSeeds.push(simResult.nextSeed);

                    simResult.seeds.forEach(s => rowHtml += `<td>${s}</td>`);
                    
                    const requiredPadding = 3 - simResult.seeds.length;
                    for(let i = 0; i < requiredPadding; i++) rowHtml += '<td></td>';

                    rowHtml += `<td>${simResult.itemContent}</td>`;
                });
                rowHtml += `<td></td>`;
            }
            
            columnStartSeeds = nextColumnStartSeeds;
            rowHtml += '</tr>';
            table += rowHtml;
        }

        table += '</tbody></table>';
        resultTableContainer.innerHTML = table;
        
        const rowHeaderCell = document.querySelector('th.row-number-header');
        if (rowHeaderCell) { rowHeaderCell.textContent = '❐'; }
    }
    
    function simulateCellForSeedView(startSeed, lastItemId, gacha, isFeaturedComplete, thresholds) {
        let currentSeed = startSeed;
        const seeds = [];
        let itemId = -1;
        let itemContent = '---';
        let guaranteedItemContent = '';
        let isReRoll = false;
        let isFeatured = false;

        const pushSeed = (seed) => {
            seeds.push(seed);
            return xorshift32(seed);
        };
        
        if (isFeaturedComplete) {
            const s1 = currentSeed;
            currentSeed = pushSeed(currentSeed);
            const s2 = currentSeed;
            currentSeed = pushSeed(currentSeed);

            let rarityId;
            if (s1 % 10000 < thresholds['0']) { rarityId = 0; }
            else if (s1 % 10000 < thresholds['1']) { rarityId = 1; }
            else if (s1 % 10000 < thresholds['2']) { rarityId = 2; }
            else if (s1 % 10000 < thresholds['3']) { rarityId = 3; }
            else { rarityId = 4; }
            
            const itemPool = gacha.rarityItems[rarityId];
            if (itemPool && itemPool.length > 0) {
                itemId = itemPool[s2 % itemPool.length];
            }

            if (gacha.uberGuaranteedFlag || gacha.legendGuaranteedFlag) {
                const uberRate = gacha.uberGuaranteedFlag ? gacha.rarityRates['3'] : 0;
                const legendRate = gacha.legendGuaranteedFlag ? gacha.rarityRates['4'] : 0;
                const totalGuaranteedRate = uberRate + legendRate;
                if (totalGuaranteedRate > 0) {
                    const rarityRoll = s1 % totalGuaranteedRate;
                    const guaranteedRarityId = (rarityRoll < uberRate) ? 3 : 4;
                    const guaranteedItemPool = gacha.rarityItems[guaranteedRarityId];
                    if (guaranteedItemPool && guaranteedItemPool.length > 0) {
                        const guaranteedItemId = guaranteedItemPool[s2 % guaranteedItemPool.length];
                        const itemName = itemMaster[guaranteedItemId] ? itemMaster[guaranteedItemId].name : "不明";
                        guaranteedItemContent = `<span class="featuredItem-text">${itemName}</span>`;
                    }
                }
            }

        } else {
            const s1 = currentSeed;
            currentSeed = pushSeed(currentSeed);

            if (s1 % 10000 < gacha.featuredItemRate) {
                isFeatured = true;
                itemContent = `<span class="featuredItem-text">目玉</span>`;
            } else {
                const s2 = currentSeed;
                currentSeed = pushSeed(currentSeed);
                const s3 = currentSeed;
                currentSeed = pushSeed(currentSeed);
                
                let rarityId;
                if (s2 % 10000 < thresholds['0']) { rarityId = 0; }
                else if (s2 % 10000 < thresholds['1']) { rarityId = 1; }
                else if (s2 % 10000 < thresholds['2']) { rarityId = 2; }
                else if (s2 % 10000 < thresholds['3']) { rarityId = 3; }
                else { rarityId = 4; }

                const itemPool = gacha.rarityItems[rarityId];
                if (itemPool && itemPool.length > 0) {
                    itemId = itemPool[s3 % itemPool.length];
                }
            }
        }
        
        if (itemId !== -1) {
            const name = itemMaster[itemId] ? itemMaster[itemId].name : "不明";
            const rarity = itemMaster[itemId] ? itemMaster[itemId].rarity : -1;
            if (rarity === 3 || rarity === 4) {
                 itemContent = `<span class="featuredItem-text">${name}</span>`;
            } else {
                itemContent = name;
            }
        }
        
        return { seeds, itemContent, itemId, nextSeed: currentSeed, isReRoll, isFeatured, guaranteedItemContent };
    }


    function createAndDisplayTableOriginal(items, rarities, isfeaturedItemCell, path, tenPullResults, reGachaItems, gachaId, expectedFeaturedItemsArray, currentGuaranteedRolls, initialStockForUrl, reRolledIndicesOnPath, visualToDataMap, canReRollRarity1, lastItemIdsOnPath, tableRows, reGachaItemIds, displaySeed, initialSeed) {
        const gacha = gachaMaster[gachaId];
        const isFeaturedComplete = featuredCompleteCheckbox.checked;
        const initialGuaranteedRolls = parseInt(currentGuaranteedRolls, 10);

        const getGuaranteedUber = (dataIndex) => {
            if ((!gacha.uberGuaranteedFlag && !gacha.legendGuaranteedFlag) || !isFeaturedComplete || dataIndex === undefined || dataIndex + 1 >= xorshiftArray.length) return null;
            const uberRate = gacha.rarityRates['3'];
            const legendRate = gacha.rarityRates['4'];
            const hasUbers = gacha.rarityItems['3'] && gacha.rarityItems['3'].length > 0;
            const hasLegends = gacha.rarityItems['4'] && gacha.rarityItems['4'].length > 0;
            const effectiveUberRate = hasUbers ? uberRate : 0;
            const effectiveLegendRate = hasLegends ? legendRate : 0;
            const totalRate = effectiveUberRate + effectiveLegendRate;
            if (totalRate === 0) return null;
            const rarityRoll = xorshiftArray[dataIndex] % totalRate;
            let rarityId = (rarityRoll < effectiveUberRate) ? 3 : 4;
            let itemPool = gacha.rarityItems[rarityId];
            if (!itemPool || itemPool.length === 0) return null;
            const itemRoll = xorshiftArray[dataIndex + 1] % itemPool.length;
            const itemId = itemPool[itemRoll];
            return itemMaster[itemId] ? itemMaster[itemId].name : "不明";
        };

        const pathSet = new Set(path);
        let table;

        if (isFeaturedComplete) {

            const thresholds = {
                '0': gacha.rarityRates['0'], '1': gacha.rarityRates['0'] + gacha.rarityRates['1'],
                '2': gacha.rarityRates['0'] + gacha.rarityRates['1'] + gacha.rarityRates['2'],
                '3': gacha.rarityRates['0'] + gacha.rarityRates['1'] + gacha.rarityRates['2'] + gacha.rarityRates['3'],
                '4': 10000
            };

            table = '<table><thead><tr><th class="row-number-header">❐</th><th>A</th><th>AG</th><th>B</th><th>BG</th></tr></thead><tbody>';
            
            let seedA = xorshift32(initialSeed);
            let seedB = xorshift32(xorshift32(initialSeed));
            let lastItemIdA = -1;
            let lastItemIdB = -1;

            for (let r = 0; r < tableRows; r++) {
                const sA1 = seedA;
                const sA2 = xorshift32(sA1);
                
                const rarityRollA = sA1 % 10000;
                let rarityIdA;
                if (rarityRollA < thresholds['0']) { rarityIdA = 0; }
                else if (rarityRollA < thresholds['1']) { rarityIdA = 1; }
                else if (rarityRollA < thresholds['2']) { rarityIdA = 2; }
                else if (rarityRollA < thresholds['3']) { rarityIdA = 3; }
                else { rarityIdA = 4; }
                
                const itemPoolA = gacha.rarityItems[rarityIdA];
                let itemIdA = -1;
                let itemContentA = '---';
                let nextSeedA = sA2;

                if (itemPoolA && itemPoolA.length > 0) {
                    itemIdA = itemPoolA[sA2 % itemPoolA.length];

                }

                if(itemIdA !== -1) itemContentA = itemMaster[itemIdA]?.name || '不明';


                let guaranteedItemContentA = '';
                if (gacha.uberGuaranteedFlag || gacha.legendGuaranteedFlag) {
                    const uberRate = gacha.uberGuaranteedFlag ? gacha.rarityRates['3'] : 0;
                    const legendRate = gacha.legendGuaranteedFlag ? gacha.rarityRates['4'] : 0;
                    const totalGuaranteedRate = uberRate + legendRate;
                    if (totalGuaranteedRate > 0) {
                        const rarityRollAG = sA1 % totalGuaranteedRate;
                        const guaranteedRarityIdA = (rarityRollAG < uberRate) ? 3 : 4;
                        const guaranteedItemPoolA = gacha.rarityItems[guaranteedRarityIdA];
                        if (guaranteedItemPoolA && guaranteedItemPoolA.length > 0) {
                            const guaranteedItemIdA = guaranteedItemPoolA[sA2 % guaranteedItemPoolA.length];
                            guaranteedItemContentA = `<span class="featuredItem-text">${itemMaster[guaranteedItemIdA]?.name || "不明"}</span>`;
                        }
                    }
                }
                seedA = nextSeedA;


                const sB1 = seedB;
                const sB2 = xorshift32(sB1);

                const rarityRollB = sB1 % 10000;
                let rarityIdB;
                if (rarityRollB < thresholds['0']) { rarityIdB = 0; }
                else if (rarityRollB < thresholds['1']) { rarityIdB = 1; }
                else if (rarityRollB < thresholds['2']) { rarityIdB = 2; }
                else if (rarityRollB < thresholds['3']) { rarityIdB = 3; }
                else { rarityIdB = 4; }

                const itemPoolB = gacha.rarityItems[rarityIdB];
                let itemIdB = -1;
                let itemContentB = '---';
                let nextSeedB = sB2;

                if (itemPoolB && itemPoolB.length > 0) {
                    itemIdB = itemPoolB[sB2 % itemPoolB.length];

                }

                if(itemIdB !== -1) itemContentB = itemMaster[itemIdB]?.name || '不明';

                let guaranteedItemContentB = '';
                 if (gacha.uberGuaranteedFlag || gacha.legendGuaranteedFlag) {
                    const uberRate = gacha.uberGuaranteedFlag ? gacha.rarityRates['3'] : 0;
                    const legendRate = gacha.legendGuaranteedFlag ? gacha.rarityRates['4'] : 0;
                    const totalGuaranteedRate = uberRate + legendRate;
                    if (totalGuaranteedRate > 0) {
                        const rarityRollBG = sB1 % totalGuaranteedRate;
                        const guaranteedRarityIdB = (rarityRollBG < uberRate) ? 3 : 4;
                        const guaranteedItemPoolB = gacha.rarityItems[guaranteedRarityIdB];
                        if (guaranteedItemPoolB && guaranteedItemPoolB.length > 0) {
                            const guaranteedItemIdB = guaranteedItemPoolB[sB2 % guaranteedItemPoolB.length];
                            guaranteedItemContentB = `<span class="featuredItem-text">${itemMaster[guaranteedItemIdB]?.name || "不明"}</span>`;
                        }
                    }
                }
                seedB = nextSeedB;

                table += `<tr><td>${r + 1}</td><td>${itemContentA}</td><td>${guaranteedItemContentA}</td><td>${itemContentB}</td><td>${guaranteedItemContentB}</td></tr>`;
            }
        } else {
            table = '<table><thead><tr><th class="row-number-header">❐</th><th>A</th><th>B</th><th>C</th><th>G</th></tr></thead><tbody>';
            for (let r = 0; r < tableRows; r++) {
                table += `<tr><td>${r + 1}</td>`;
                for (let c = 0; c < 3; c++) {
                    const index = r * 3 + c;
                    let cellContent = getItemCellContent(index, index, {isFeaturedComplete, reRolledIndicesOnPath, items, reGachaItems, path, gachaId, displaySeed, initialGuaranteedRolls, canReRollRarity1, reGachaItemIds, xorshiftArray, itemMaster, itemNameMap, generateUrlQuery, lastItemIdsOnPath, gacha, isfeaturedItemCell, initialStockForUrl});
                    table += `<td class="re-gacha-cell ${path.includes(index) ? 'path-cell' : ''}">${cellContent}</td>`;
                }
                let gCellContent = (r < 10) ? (tenPullResults[r] || '') : (r < 20 ? expectedFeaturedItemsArray[r - 9] : '');
                 if (gCellContent && gCellContent.toString().includes('目玉')) {
                    gCellContent = `<span class="featuredItem-text">${gCellContent}</span>`;
                }
                table += `<td class="re-gacha-cell ${r < 10 ? 'g-ten-pull-highlight' : ''}">${gCellContent}</td>`;
                table += '</tr>';
            }
        }
        table += '</tbody></table>';
        resultTableContainer.innerHTML = table;

        const rowHeaderCell = document.querySelector('th.row-number-header');
        if(rowHeaderCell) {
            rowHeaderCell.textContent = forceReGachaMode ? '☑' : '❐';
            rowHeaderCell.addEventListener('click', toggleReGachaMode);
        }
    }
    
    function getItemCellContent(dataIndex, visualIndex, context) {
        const { isFeaturedComplete, reRolledIndicesOnPath, items, reGachaItems, path, gachaId, displaySeed, initialGuaranteedRolls, canReRollRarity1, reGachaItemIds, xorshiftArray, itemMaster, itemNameMap, generateUrlQuery, lastItemIdsOnPath, gacha, isfeaturedItemCell, initialStockForUrl } = context;
        if(dataIndex === undefined) return "---";

        const isOnPath = path.includes(visualIndex);
        const showReGacha = (forceReGachaMode && reGachaItems[dataIndex] !== "---") || reRolledIndicesOnPath.has(visualIndex);

        let nextGuaranteedParam = 'none';
        let stockParam = 'none';
        let compParam = isFeaturedComplete;
        let lrParam = -1;
        
        if (isOnPath) {
            const pathPosition = path.indexOf(visualIndex);
            const currentSlotNumber = pathPosition + 1;
            const guaranteedCycle = gacha.guaranteedCycle || 30;

            if (!isNaN(initialGuaranteedRolls)) {
                let nextGuaranteed = initialGuaranteedRolls - currentSlotNumber;
                while(nextGuaranteed <= 0) { nextGuaranteed += guaranteedCycle; }
                nextGuaranteedParam = nextGuaranteed;
            }
            
            if (!isFeaturedComplete) {
                const featuredSlots = new Set();
                for (let i = 0; i <= pathPosition; i++) { 
                     const rollNum = i + 1;
                     if (isfeaturedItemCell[path[i]] || (!isNaN(initialGuaranteedRolls) && rollNum >= initialGuaranteedRolls && (rollNum - initialGuaranteedRolls) % guaranteedCycle === 0)) {
                         featuredSlots.add(path[i]); 
                     }
                }
                const stockAfterThisRoll = Math.max(0, initialStockForUrl - featuredSlots.size);
                stockParam = (stockAfterThisRoll === Infinity) ? 'none' : stockAfterThisRoll;
                compParam = stockAfterThisRoll === 0;
            }
        }

        if (isfeaturedItemCell && isfeaturedItemCell[dataIndex]) {
            const nextIndex = dataIndex + 1;
            const nextRollAddress = `${String.fromCharCode('A'.charCodeAt(0) + (nextIndex % 3))}${Math.floor(nextIndex / 3) + 1}`;
            if (isOnPath) lrParam = lastItemIdsOnPath[path.indexOf(visualIndex)];
            const linkParams = { seed: xorshiftArray[dataIndex], gachaId, ng: nextGuaranteedParam, fs: stockParam, comp: compParam, lr: lrParam, displaySeed };
            return `<a href="${generateUrlQuery(linkParams)}" class="featuredItem-text">${nextRollAddress})目玉</a>`;
        }

        if (showReGacha) {
            const nextIndex = dataIndex + (isFeaturedComplete ? 3 : 4);
            const nextRollAddress = `${String.fromCharCode('A'.charCodeAt(0) + (nextIndex % 3))}${Math.floor(nextIndex / 3) + 1}`;
            const reGachaItemName = reGachaItems[dataIndex];
            const reGachaItemId = itemNameMap[reGachaItemName];
            const originalItemName = itemMaster[items[dataIndex]] ? itemMaster[items[dataIndex]].name : "不明";
            const originalItemId = items[dataIndex];
            
            lrParam = reGachaItemId;
            const reGachaLinkParams = { seed: xorshiftArray[nextIndex - 1], lr: lrParam, gachaId, ng: nextGuaranteedParam, fs: stockParam, comp: compParam, displaySeed };
            const originalItemLinkParams = { seed: xorshiftArray[nextIndex - 2], lr: originalItemId, gachaId, ng: nextGuaranteedParam, fs: stockParam, comp: compParam, displaySeed };

            const originalItemContent = `<a href="${generateUrlQuery(originalItemLinkParams)}">${originalItemName}</a>`;
            const reGachaLink = `<a href="${generateUrlQuery(reGachaLinkParams)}">${nextRollAddress})${reGachaItemName}</a>`;
            return `${originalItemContent}<br>${reGachaLink}`;
        }

        const currentItemId = items[dataIndex];
        if (itemMaster[currentItemId]) {
            lrParam = currentItemId;
            const nextIndex = dataIndex + (isFeaturedComplete ? 2 : 3);
            const linkParams = { seed: xorshiftArray[nextIndex - 1], lr: lrParam, gachaId, ng: nextGuaranteedParam, fs: stockParam, comp: compParam, displaySeed };
            
            const nextRollAddress = `${String.fromCharCode('A'.charCodeAt(0) + (nextIndex % 3))}${Math.floor(nextIndex / 3) + 1}`;
            let cellContent = `<a href="${generateUrlQuery(linkParams)}">${nextRollAddress})${itemMaster[currentItemId].name}</a>`;
            if (itemMaster[currentItemId].rarity === 3) {
                cellContent = `<span class="featuredItem-text">${cellContent}</span>`;
            }
            return cellContent;
        }
        return '---';
    }
    runSimulationAndDisplay();
</script>
</body>
</html>