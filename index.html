<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>イベントガチャロールズ</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.2;
            padding: 5px;
            max-width: 1200px;
            margin: 0 auto;
            background-color: #f4f7f9;
            color: #333;
            font-size: 9px;
        }
        .container {
            background: #fff;
            padding: 5px;
            border-radius: 12px;
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.1);
        }
        h1 {
            color: #004085;
            font-size: 0.9rem;
            border-bottom: 1px solid #e9ecef;
            padding-bottom: 3px;
            margin-top: 0;
            text-align: center;
        }
        .controls {
            display: flex;
            flex-direction: column;
            gap: 5px;
            margin-bottom: 10px;
            padding: 4px;
            background-color: #f9fbfd;
            border-radius: 4px;
        }
        .row {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
            gap: 5px;
            align-items: center;
        }
        .control-group-left, .control-group-right {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        .input-item {
            flex: 0 1 auto;
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 3px;
        }
        .input-item-display-only {
            flex: 0 1 auto;
            display: flex;
            align-items: center;
            font-size: 0.7rem;
            color: #555;
            padding: 0 5px;
        }
        .input-item-seed {
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 3px;
        }
        .seed-input-group {
            display: flex;
            align-items: center;
            gap: 5px;
            flex: 1 1 200px;
        }
        label {
            font-weight: 600;
            color: #555;
        }
        input[type="number"],
        select {
            padding: 3px;
            border: 1px solid #ccc;
            border-radius: 3px;
            font-size: 0.8rem;
            width: 100%;
            box-sizing: border-box;
            transition: border-color 0.3s;
        }
        input[type="number"]:focus,
        select:focus {
            outline: none;
            border-color: #007bff;
        }
        button {
            flex-shrink: 0;
            width: auto;
            padding: 5px 10px;
            background-color: #007bff;
            color: #fff;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.8rem;
            font-weight: bold;
            transition: background-color 0.3s ease, transform 0.2s ease;
        }
        .hidden-control {
            display: none !important;
        }
        #showSeedInputLink {
            color: #007bff;
            text-decoration: underline;
            cursor: pointer;
            padding: 0 5px;
        }
        #copySeedLink {
            color: #007bff;
            text-decoration: underline;
            cursor: pointer;
            white-space: nowrap;
        }

        button:hover {
            background-color: #0056b3;
            transform: translateY(-2px);
        }
        #result-container {
            margin-top: 15px;
        }
        #result-table-container {
            overflow-x: auto;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
        }
        table {
            width: 100%;
            border-collapse: collapse;
        }
        th, td {
            padding: 3px;
            text-align: center;
            border: 1px solid #e0e0e0;
            word-break: break-word;
            font-size: 0.8rem;
            min-width: 25px;
        }
        th {
            background-color: #f0f4f7;
            color: #444;
            font-weight: 600;
            position: sticky;
            top: 0;
            z-index: 1;
        }
        thead th:first-child {
            z-index: 2;
        }
        td {
            background-color: #fff;
        }
        .row-number-header {
            font-family: Arial, sans-serif;
            font-weight: bold;
            width: 25px;
            cursor: pointer;
        }
        .col-no {
            width: 25px;
        }
        .featuredItem-text {
            color: #d9534f;
            font-weight: bold;
        }
        #result-table-container td a {
            color: inherit;
            text-decoration: none;
        }

        /* ハイライト用CSS */
        .highlight-roll { background-color: #e0f7ff !important; } /* 単発 (青) */
        .highlight-roll-10 { background-color: #a0eaff !important; }
        .highlight-roll-10pull { background-color: #ffffe0 !important; } /* 10連 (黄) */
        .highlight-roll-10pull-10 { background-color: #FFF39B !important; }
        .highlight-roll-overlap { background-color: #dfffb0 !important; } /* 重複 (緑) */
        .highlight-roll-overlap-10 { background-color: #a0eda0 !important; }
        
        #calculation-details {
            font-family: monospace;
            font-size: 11px;
            line-height: 1.4;
            margin-top: 15px;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
            background: #f9f9f9;
        }
        #calculation-details h2 {
            font-size: 1.1rem;
            margin-top: 20px;
            margin-bottom: 5px;
            border-bottom: 1px solid #ccc;
            padding-bottom: 3px;
        }
        #toggleDetailsBtn {
            background-color: #6c757d;
        }
        #toggleDetailsBtn:hover {
            background-color: #5a6268;
        }
        #details-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
        }
        .scroll-buttons {
            display: flex; /* This will be toggled by JS */
            gap: 10px;
        }
        .scroll-buttons button {
            font-size: 0.75rem;
            background-color: #28a745;
        }
        .scroll-buttons button:hover {
            background-color: #218838;
        }
    </style>
</head>
<body>

<div class="container">
    <h1>イベントガチャロールズ</h1>
    <div class="input-group">
        <div class="controls">
            <div class="row">
                <div class="control-group-left">
                    <div class="input-item" id="seedLinkContainer">
                        <a id="showSeedInputLink" href="#">SEED入力</a>
                    </div>
                    <div class="input-item" id="guaranteedControl">
                        <label for="guaranteedRollsInput">next guaranteed</label>
                        <select id="guaranteedRollsInput"></select>
                    </div>
                    <div class="input-item" id="legendDisplay" style="font-size: 0.7rem;">
                        <span style="background-color: #e0f7ff; padding: 2px 5px; border-radius: 3px; margin-left: 10px;">単発ルート</span>
                        <span style="background-color: #ffffe0; padding: 2px 5px; border-radius: 3px; margin-left: 5px;">10連ルート</span>
                        <span style="background-color: #dfffb0; padding: 2px 5px; border-radius: 3px; margin-left: 5px;">共通ルート</span>
                    </div>
                    <div id="lastRollDisplay" class="input-item-display-only">
                        </div>
                </div>
                <div class="control-group-right">
                    <div class="input-item">
                        <label for="featuredCompleteCheckbox">コンプ済み</label>
                        <input type="checkbox" id="featuredCompleteCheckbox">
                    </div>
                    <div class="input-item" id="stockControl">
                        <label for="featuredStockInput">目玉残数</label>
                        <select id="featuredStockInput"></select>
                    </div>
                    <a id="copySeedLink" href="#">Copy SEED</a>
                </div>
            </div>
            <div class="row hidden-control" id="seedRow">
                <div class="input-item-seed">
                    <label for="seedInput">SEED</label>
                    <div class="seed-input-group">
                        <input type="number" id="seedInput" value="123456789">
                        <button id="executeButton">更新</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div id="result-container">
        <div id="output"></div>
        <div id="result-table-container"></div>
        <div id="details-controls" style="display: none; margin-top: 10px; align-items: center; gap: 10px;">
            <button id="toggleDetailsBtn">計算過程を表示</button>
            <div class="scroll-buttons" style="display: none;">
                <button id="scrollToSingle">単発ルートへ</button>
                <button id="scrollToMulti">10連ルートへ</button>
            </div>
        </div>
        <div id="calculation-details" style="display:none;"></div>
    </div>
</div>

<script>
    // --- マスターデータ ---
    const gachaMaster = {
        '34': { name: '(旧)ハロウィン', featuredItemRate: 600, featuredItemStock: 5, guaranteedCycle: 30, uberGuaranteedFlag: false, legendGuaranteedFlag: false, rarityRates: { '0': 2000, '1': 5000, '2': 3000, '3': 0, '4': 0 }, pool: [0, 2, 3, 4, 5, 10, 11, 12, 14] },
        '42': { name: '1.1億DL記念', featuredItemRate: 500, featuredItemStock: 5, guaranteedCycle: 30, uberGuaranteedFlag: false, legendGuaranteedFlag: false, rarityRates: { '0': 1000, '1': 5000, '2': 3000, '3': 1000, '4': 0 }, pool: [0, 2, 3, 4, 5, 10, 11, 12, 14, 375, 381, 689] },
        '44': { name: 'ハロウィン', featuredItemRate: 500, featuredItemStock: 8, guaranteedCycle: 30, uberGuaranteedFlag: false, legendGuaranteedFlag: false, rarityRates: { '0': 2000, '1': 4900, '2': 3000, '3': 0, '4': 100 }, pool: [0, 2, 3, 4, 5, 10, 11, 12, 14, 18] },
        '45': { name: 'にゃんこレンジャー', featuredItemRate: 0, featuredItemStock: 0, guaranteedCycle: 10, uberGuaranteedFlag: true, legendGuaranteedFlag: false, rarityRates: { '0': 0, '1': 7000, '2': 2300, '3': 500, '4': 200 }, pool: [0,2,3,4,5,11,12,14,197,184,375,726,831] }
    };
    const itemMaster = {
        0: { name: "スピダ", rarity: 1 }, 2: { name: "ネコボン", rarity: 2 }, 3: { name: "ニャンピュ", rarity: 1 }, 4: { name: "おかめ", rarity: 2 }, 5: { name: "スニャ", rarity: 2 },
        10: { name: "5千XP", rarity: 0 }, 11: { name: "1万XP", rarity: 1 }, 12: { name: "3万XP", rarity: 1 }, 14: { name: "10万XP", rarity: 2 }, 18: { name: "200万XP", rarity: 4 },
        197: { name: "100万XP", rarity: 4 }, 184: { name: "ミスターニンジャ", rarity: 3 }, 375: { name: "記念ネコ", rarity: 3 }, 381: { name: "ねこ農家", rarity: 3 },
        689: { name: "石の上にも10年ネコ", rarity: 3 }, 726: { name: "ネコメダル王", rarity: 3 }, 831: { name: "スカーフにゃんこ", rarity: 3 }
    };

    const DEFAULT_PARAMS = {
        gacha: '45',
        seed: '123456789',
        ng: 'none',
        fs: 'none',
        lr: null,
        comp: false,
        tx: false,
        roll: 100,
        displaySeed: '0'
    };

    function generateUrlQuery(p) {
        const query = new URLSearchParams();
        for (const key in p) {
            if (key === 'displaySeed' && p[key] === DEFAULT_PARAMS.displaySeed) continue;
            if (p[key] !== null && p[key] !== undefined) query.set(key, p[key]);
        }
        return '?' + query.toString();
    }
    
    function xorshift32(seed) {
        let x = seed;
        x ^= x << 13; x ^= x >>> 17; x ^= x << 15;
        return x >>> 0;
    }
    function setupGachaRarityItems() {
        for (const gachaId in gachaMaster) {
            const gacha = gachaMaster[gachaId];
            if (gacha && gacha.pool) {
                gacha.rarityItems = { '0': [], '1': [], '2': [], '3': [], '4': [] };
                for (const itemId of gacha.pool) {
                    const item = itemMaster[itemId];
                    if (item && gacha.rarityItems[item.rarity] !== undefined) {
                        gacha.rarityItems[item.rarity].push(itemId);
                    }
                }
                for (const rarity in gacha.rarityItems) gacha.rarityItems[rarity].sort((a, b) => a - b);
            }
        }
    }

    function addClassToLastCell(cellHtml, className) {
        if (!className) return cellHtml;
        const lastTdIndex = cellHtml.lastIndexOf('<td');
        if (lastTdIndex === -1) return cellHtml;
        return cellHtml.substring(0, lastTdIndex) + cellHtml.substring(lastTdIndex).replace(/<td/, `<td class="${className}"`);
    }

    // --- コンプ済み・一括計算ロジック ---
    function createAndDisplayCompletedSeedView(initialSeed, gacha, tableRows, thresholds, initialLastRollId, displaySeed, params, initialNg) {
        // 1. シードの生成 (十分な量を確保)
        const SEED = [initialSeed];
        // 各セルで最大3〜4シード消費、G列なども考慮して多めに生成
        const maxSeedsNeeded = tableRows * 4 * 2 + 1000; 
        for (let i = 1; i < maxSeedsNeeded; i++) {
            SEED[i] = xorshift32(SEED[i - 1]);
        }

        const getRarityFromRoll = (roll) => {
            if (roll < thresholds['0']) return { id: 0, name: 'ノーマル' };
            if (roll < thresholds['1']) return { id: 1, name: 'レア' };
            if (roll < thresholds['2']) return { id: 2, name: '激レア' };
            if (roll < thresholds['3']) return { id: 3, name: '超激レア' };
            return { id: 4, name: '伝説レア' };
        };

        const getAddressString = (n) => {
            if (n <= 0) return '';
            const zeroBasedIndex = n - 1;
            const col_char = String.fromCharCode('A'.charCodeAt(0) + (zeroBasedIndex % 2));
            const row_num = Math.floor(zeroBasedIndex / 2) + 1;
            return `${row_num}${col_char}`;
        };

        // 2. 全ノードの事前計算 (No.1 から No.Max まで)
        const Nodes = [];
        const maxNodeIndex = tableRows * 2 + 100; // 表に必要な分 + 余白
        
        // ... (ノード計算ロジックは前コードと同一) ...
        for (let i = 1; i <= maxNodeIndex; i++) {
            const node = {
                index: i,
                address: getAddressString(i),
                seed1: SEED[i],
                seed2: SEED[i+1],
                seed3: SEED[i+2],
                seed4: SEED[i+3],
                seed5: SEED[i+4],
                seed6: SEED[i+5] // 予備
            };

            // (レアリティ判定)
            const roll1 = node.seed1 % 10000;
            const rarityRes = getRarityFromRoll(roll1);
            node.rarity = rarityRes;
            node.rarityId = rarityRes.id;

            // (確定枠レアリティ判定)
            const uberRate = gacha.uberGuaranteedFlag ? (gacha.rarityRates['3'] || 0) : 0;
            const legendRate = gacha.legendGuaranteedFlag ? (gacha.rarityRates['4'] || 0) : 0;
            const gDivisor = uberRate + legendRate;
            if (gDivisor > 0) {
                const gRoll = node.seed1 % gDivisor;
                node.rarityGId = (gRoll < uberRate) ? '3' : '4';
                node.rarityGName = (node.rarityGId === '3') ? '超激レア' : '伝説レア';
                node.gRoll = gRoll;
                node.gDivisor = gDivisor;
            } else {
                node.rarityGId = null; node.rarityGName = '-'; node.gRoll = 0; node.gDivisor = 0;
            }

            // (スロット, ID, 名称)
            const pool = gacha.rarityItems[node.rarityId] || [];
            node.poolSize = pool.length;
            if (pool.length > 0) {
                node.slot = node.seed2 % pool.length;
                node.itemId = pool[node.slot];
                node.itemName = itemMaster[node.itemId]?.name || '---';
            } else {
                node.slot = 0; node.itemId = -1; node.itemName = '---';
            }

            // (確定枠スロット)
            const poolG = node.rarityGId ? (gacha.rarityItems[node.rarityGId] || []) : [];
            node.poolGSize = poolG.length;
            if (poolG.length > 0) {
                node.slotG = node.seed2 % poolG.length;
                node.itemGId = poolG[node.slotG];
                node.itemGName = itemMaster[node.itemGId]?.name || '---';
            } else {
                node.slotG = 0; node.itemGId = -1; node.itemGName = '---';
            }

            // (レア被り判定) - 静的計算 (パス依存ではない)
            const prevNode = (i > 1) ? Nodes[i - 2] : null;
            const prevPrevNode = (i > 2) ? Nodes[i - 3] : null;
            
            const prevItemId = prevNode ? prevNode.itemId : -1;
            const prevPrevReRollItemId = prevPrevNode ? prevPrevNode.reRollItemId : -1;

            const isRare = (node.rarityId === 1);
            const matchPrev = (node.itemId !== -1 && node.itemId === prevItemId);
            const matchPrevPrevReRoll = (node.itemId !== -1 && node.itemId === prevPrevReRollItemId);

            node.reRollFlag = isRare && (matchPrev || matchPrevPrevReRoll);
            node.useSeeds = node.reRollFlag ? 3 : 2;

            // (再抽選スロット判定)
            if (node.reRollFlag || forceRerollMode && isRare) {
                const actualReRollPool = pool.filter(id => id !== node.itemId);
                if (actualReRollPool.length > 0) {
                    node.reRollSlot = node.seed3 % actualReRollPool.length;
                    node.reRollItemId = actualReRollPool[node.reRollSlot];
                    node.reRollItemName = itemMaster[node.reRollItemId]?.name || '---';
                } else {
                     node.reRollSlot = '-'; node.reRollItemId = -1; node.reRollItemName = '---';
                }
            } else {
                node.reRollSlot = '-';
                node.reRollItemId = -1;
                node.reRollItemName = '---';
            }

            // (再抽選後の遷移先番地)
            const nextIdx = i + 3;
            node.reRollNextAddress = getAddressString(nextIdx);

            Nodes.push(node);
        }


        // 3. ハイライトパスの計算 (前コードと同一)
        const ngVal = parseInt(initialNg, 10);
        const hasGuaranteed = !isNaN(ngVal);
        const highlightMap = new Map();
        
        // ... (Highlight Map generation logic: singlePath, tenPullPath, highlightMap の生成) ...
        
        // ＜単発ルート＞ (Highlight Map 生成用)
        let currentNo = 1;
        let currentLastItemId = initialLastRollId;
        const singlePath = [];
        for (let roll = 1; roll <= tableRows * 2; roll++) {
            if (currentNo > maxNodeIndex) break;
            const nodeIndex = currentNo - 1;
            const node = Nodes[nodeIndex];
            
            const isGuaranteedRoll = hasGuaranteed && (roll >= ngVal) && ((roll - ngVal) % 10 === 0);
            
            if (isGuaranteedRoll) {
                const addressKey = node.address + 'G';
                let cls = 'highlight-roll';
                if (!hasGuaranteed && roll % 10 === 0) cls = 'highlight-roll-10';
                
                singlePath.push({ address: addressKey, roll: roll, type: 'single', dynamicReRoll: false, nodeIndex: currentNo });
                
                currentNo += 2;
                currentLastItemId = node.itemGId;
            } else {
                const addressKey = node.address;
                const pool = gacha.rarityItems[node.rarityId] || [];
                const isRare = (node.rarityId === 1);
                const match = (node.itemId !== -1 && node.itemId === currentLastItemId);
                const canReRoll = isRare && pool.length > 1;
                const dynamicReRoll = canReRoll && match;
                
                let cls = 'highlight-roll';
                if (!hasGuaranteed && roll % 10 === 0) cls = 'highlight-roll-10';
                
                singlePath.push({ address: addressKey, roll: roll, type: 'single', dynamicReRoll: dynamicReRoll, nodeIndex: currentNo });

                if (dynamicReRoll) {
                    currentNo += 3;
                    // 再抽選アイテムを取得 (nodeデータには静的再抽選が入っているため、それを流用)
                    currentLastItemId = node.reRollItemId; 
                } else {
                    currentNo += 2;
                    currentLastItemId = node.itemId;
                }
            }
        }

        // ＜10連ルート＞ (Highlight Map 生成用)
        let tenPullPath = [];
        if (hasGuaranteed) {
            let tCurrentNo = 1;
            let tCurrentLastItemId = initialLastRollId;
            
            for (let roll = 1; roll <= tableRows * 2; roll++) {
                const isGuaranteedRoll = (roll >= ngVal) && ((roll - ngVal) % 10 === 0);
                
                if ((roll - 1) % 10 === 0) {
                    tCurrentNo++; // サイクルの最初の1SEED (rarityG用) を消費
                }

                if (isGuaranteedRoll) {
                    const targetNode = Nodes[tCurrentNo - 2]; // ★★★ 1つ前のノードを参照する
                    if (targetNode) {
                        const addressKey = targetNode.address + 'G';
                        tenPullPath.push({ address: addressKey, roll: roll, type: 'ten', nodeIndex: tCurrentNo - 1 });
                    }
                    tCurrentNo += 1; // スロット判定分の1シード消費
                } else {
                    const node = Nodes[tCurrentNo - 1];
                    if (!node) break;
                    
                    const addressKey = node.address;
                    
                    const pool = gacha.rarityItems[node.rarityId] || [];
                    const isRare = (node.rarityId === 1);
                    const match = (node.itemId !== -1 && node.itemId === tCurrentLastItemId);
                    const canReRoll = isRare && pool.length > 1;
                    const dynamicReRoll = canReRoll && match;

                    tenPullPath.push({ address: addressKey, roll: roll, type: 'ten', dynamicReRoll: dynamicReRoll, nodeIndex: tCurrentNo });

                    if (dynamicReRoll) {
                        tCurrentNo += 3;
                        tCurrentLastItemId = node.reRollItemId;
                    } else {
                        tCurrentNo += 2;
                        tCurrentLastItemId = node.itemId;
                    }
                }
            }
        }
        
        // ハイライトマップの作成 (前コードと同一)
        singlePath.forEach(p => {
            let cls = 'highlight-roll';
            const tenP = tenPullPath.find(tp => tp.address === p.address);
            if (tenP) {
                cls = (tenP.roll % 10 === 0) ? 'highlight-roll-overlap-10' : 'highlight-roll-overlap';
            } else {
                cls = (!hasGuaranteed && p.roll % 10 === 0) ? 'highlight-roll-10' : 'highlight-roll';
            }
            highlightMap.set(p.address, cls);
        });
        tenPullPath.forEach(p => {
            if (!highlightMap.has(p.address)) {
                let cls = (p.roll % 10 === 0) ? 'highlight-roll-10pull-10' : 'highlight-roll-10pull';
                highlightMap.set(p.address, cls);
            }
        });
        // --- ハイライトパスの計算 終了 ---


        // 4. 計算詳細ログのHTML生成
        let detailsHtml = '';
        detailsHtml += '<h2>＜ノード計算詳細 (No.1～)＞</h2>';
        detailsHtml += '<p style="margin-top: -10px; font-size: 10px;">（このデータは、特定のSEED INDEXからの計算結果を示します。実際のルートではレア被りにより消費SEED数が異なります）</p>';

        // --- ノード計算ログ ---
        Nodes.forEach(node => {
            let lines = [];
            lines.push(`(番地) address[${node.index}]=${node.address}`);
            
            lines.push(`(レアリティ判定) rarity[${node.index}]=S1(${node.seed1})%10000=${node.seed1%10000}→${node.rarity.name}`);
            
            lines.push(`(確定枠レアリティ判定) rarityG[${node.index}]=S1(${node.seed1})%${node.gDivisor}=${node.gRoll}→${node.rarityGName}`);
            
            lines.push(`(スロット,ID,名称判定) slot[${node.index}]=S2(${node.seed2})%${node.poolSize}=${node.slot},ItemID[${node.index}]=${node.itemId},ItemName[${node.index}]=${node.itemName}`);

            if (node.rarityGId === '3') {
                lines.push(`(超激レア確定枠スロット,ID,名称判定) slotGu[${node.index}]=S2(${node.seed2})%${node.poolGSize}=${node.slotG},GuID[${node.index}]=${node.itemGId},GuName[${node.index}]=${node.itemGName}`);
            } else if (node.rarityGId === '4') {
                lines.push(`(伝説レア確定枠スロット,ID,名称判定) slotGl[${node.index}]=S2(${node.seed2})%${node.poolGSize}=${node.slotG},GlID[${node.index}]=${node.itemGId},GlName[${node.index}]=${node.itemGName}`);
            } else {
                lines.push(`(確定枠なし)`);
            }

            lines.push(`(レア被り判定,消費SEED数) ReRollFlag[${node.index}]=${node.reRollFlag},useSeeds[${node.index}]=${node.useSeeds}`);
            
            if (node.reRollFlag || (forceRerollMode && node.rarityId === 1 && node.poolSize > 1)) {
                 lines.push(`(再抽選スロット判定) ReRollSlot[${node.index}]=S3(${node.seed3})%(${node.poolSize-1})=${node.reRollSlot},ReRollItemID[${node.index}]=${node.reRollItemId},ReRollItemName[${node.index}]=${node.reRollItemName}`);
                 lines.push(`(再抽選後の遷移先番地) ReRollNextAddress[${node.index}]=${node.reRollNextAddress}`);
            }

            detailsHtml += `<strong>No.${node.index}</strong><br>` + lines.join('<br>') + '<br><br>';
        });
        // --- ノード計算ログ 終了 ---


        // --- ルート追跡ログ ---
        // A. 単発ルート
        let singleRouteLog = '<h2>＜単発ルート＞</h2>';
        singleRouteLog += '<p style="margin-top: -10px; font-size: 10px;"></p>';
        
        let singleSeedIndex = 1;
        let singleLastItemId = initialLastRollId;
        let prevAddressNo = 0;
        let prevUsedSeeds = 1;

        for (let roll = 1; roll <= tableRows * 2; roll++) {
            if (singleSeedIndex > maxNodeIndex || roll > 300) break; // 300回まで追跡
            const nodeIndex = singleSeedIndex; // 通し番号 (No.)
            const node = Nodes[nodeIndex - 1];
            if (!node) break;

            const isGuaranteedRoll = hasGuaranteed && (roll >= ngVal) && ((roll - ngVal) % 10 === 0);
            const addressKey = node.address + (isGuaranteedRoll ? 'G' : '');

            let useSeeds = 2;
            let logContent = '';

            logContent += `<strong>Roll${roll}${isGuaranteedRoll ? '(guaranteed)' : ''}</strong><br>`;
            logContent += `(ハイライトするセル番地) address[${prevAddressNo}+${prevUsedSeeds}]=${addressKey}(${nodeIndex})<br>`;
            
            if (isGuaranteedRoll) {
                useSeeds = 2;
                logContent += `(消費SEED数(確定枠の場合は固定)) ${useSeeds}<br><br>`;
                singleLastItemId = node.itemGId;
            } else {
                const pool = gacha.rarityItems[node.rarityId] || [];
                const isRare = (node.rarityId === 1);
                const match = (node.itemId !== -1 && node.itemId === singleLastItemId);
                const canReRoll = isRare && pool.length > 1;
                const dynamicReRoll = canReRoll && match;

                useSeeds = dynamicReRoll ? 3 : 2;
                
                logContent += `(レア被り有無) ReRollFlag[${nodeIndex}]=${dynamicReRoll ? 'True' : 'False'}<br>`;
                logContent += `(消費SEED数)useSeeds[${nodeIndex}]=${useSeeds}<br><br>`;
                
                singleLastItemId = dynamicReRoll ? node.reRollItemId : node.itemId;
            }
            
            singleRouteLog += logContent;
            prevAddressNo = nodeIndex;
            prevUsedSeeds = useSeeds;
            singleSeedIndex += useSeeds;
        }

        // B. 10連ルート
        let tenPullRouteLog = '<h2>＜10連ルート＞</h2>';
        tenPullRouteLog += '<p style="margin-top: -10px; font-size: 10px;"></p>';
        
        let tenSeedCounter = 1;
        let tenLastItemId = initialLastRollId;
        let tenPrevAddressNo = 0;
        let tenPrevUsedSeeds = 1;
        
        if (hasGuaranteed) {
            for (let roll = 1; roll <= tableRows * 2; roll++) {
                if (tenSeedCounter > maxNodeIndex || roll > 300) break; // 300回まで追跡
                
                const isCycleStart = (roll - 1) % 10 === 0;
                const isGuaranteedRoll = (roll >= ngVal) && ((roll - ngVal) % 10 === 0);
                
                if (isCycleStart) {
                    const node1 = Nodes[tenSeedCounter - 1];
                    if (node1) {
                        tenPullRouteLog += `<strong>${Math.floor((roll - 1) / 10) + 1}サイクル目</strong><br>`;
                        tenPullRouteLog += `(確定枠レアリティ判定(初めの１SEEDを消費)) rarityG[${node1.index}](${node1.seed1})→${node1.rarityGName}<br><br>`;
                        tenPrevAddressNo = tenSeedCounter;
                        tenPrevUsedSeeds = 1;
                    }
                    tenSeedCounter++;
                    if (tenSeedCounter > maxNodeIndex) break;
                }

                const currentRollNodeIndex = tenSeedCounter;
                const currentRollNode = Nodes[currentRollNodeIndex - 1];
                if (!currentRollNode) break;

                let logContent = '';
                logContent += `<strong>Roll${roll}</strong>${isCycleStart ? '（先ほどのSEED消費の続きから）' : ''}<br>`;
                
                if (isGuaranteedRoll) {
                    const guaranteedNode = Nodes[currentRollNodeIndex - 2]; // 1つ前のノード
                    const addressKeyG = guaranteedNode.address + 'G';

                    logContent += `(ハイライトするセル番地（確定枠は1つ前のノード(${guaranteedNode.index})を参照）) address[${tenPrevAddressNo}+${tenPrevUsedSeeds}]=${addressKeyG}(${guaranteedNode.index})<br>`;
                    logContent += `(消費SEED数(確定枠のスロット判定)) 1<br><br>`;

                    tenPrevAddressNo = currentRollNodeIndex;
                    tenPrevUsedSeeds = 1;
                    tenSeedCounter += 1;
                } else {
                    const addressKey = currentRollNode.address;
                    
                    const pool = gacha.rarityItems[currentRollNode.rarityId] || [];
                    const isRare = (currentRollNode.rarityId === 1);
                    const match = (currentRollNode.itemId !== -1 && currentRollNode.itemId === tenLastItemId);
                    const canReRoll = isRare && pool.length > 1;
                    const dynamicReRoll = canReRoll && match;

                    const useSeeds = dynamicReRoll ? 3 : 2;

                    logContent += `(ハイライトするセル番地) address[${tenPrevAddressNo}+${tenPrevUsedSeeds}]=${addressKey}(${currentRollNodeIndex})<br>`;
                    logContent += `(レア被り有無) ReRollFlag[${currentRollNodeIndex}]=${dynamicReRoll ? 'True' : 'False'}<br>`;
                    logContent += `(消費SEED数)useSeeds[${currentRollNodeIndex}]=${useSeeds}<br><br>`;

                    tenPrevAddressNo = currentRollNodeIndex;
                    tenPrevUsedSeeds = useSeeds;
                    tenSeedCounter += useSeeds;
                    tenLastItemId = dynamicReRoll ? currentRollNode.reRollItemId : currentRollNode.itemId;
                }
                
                tenPullRouteLog += logContent;
            }
        }
        // --- ルート追跡ログ 終了 ---
        
        detailsHtml += singleRouteLog;
        if (hasGuaranteed) detailsHtml += tenPullRouteLog;


        // 5. 表の生成 (前コードと同一)
        let table = '<table style="table-layout: fixed;"><thead>';
        table += `<tr><th id="forceRerollToggle" class="col-no" style="cursor: pointer;">${forceRerollMode ? '☑' : '□'}</th><th>A</th><th>AG</th><th>B</th><th>BG</th></tr>`;
        table += '</thead><tbody>';

        for (let r = 1; r <= tableRows; r++) {
            const nodeIdxA = (r - 1) * 2 + 1;
            const nodeIdxB = (r - 1) * 2 + 2;
            const nodeA = Nodes[nodeIdxA - 1];
            const nodeB = Nodes[nodeIdxB - 1];

            if (!nodeA || !nodeB) break;

            table += `<tr><td class="col-no">${r}</td>`;

            // Cell A
            let htmlA = '';
            if (nodeA.itemId !== -1) {
                const href = generateItemLink(nodeA.seed2, nodeA.itemId, initialNg, r, true);
                let name = `<a href="${href}">${nodeA.itemName}</a>`;
                if (itemMaster[nodeA.itemId]?.rarity >= 3) name = `<span class="featuredItem-text">${name}</span>`;
                htmlA += name;
                
                if (nodeA.reRollFlag || (forceRerollMode && nodeA.rarityId === 1 && nodeA.poolSize > 1)) {
                     const hrefRe = generateItemLink(nodeA.seed3, nodeA.reRollItemId, initialNg, r, true);
                     let nameRe = `<a href="${hrefRe}">${nodeA.reRollItemName}</a>`;
                     if (itemMaster[nodeA.reRollItemId]?.rarity >= 3) nameRe = `<span class="featuredItem-text">${nameRe}</span>`;
                     htmlA += `<br>${nodeA.reRollNextAddress})${nameRe}`;
                }
            } else {
                htmlA = '---';
            }
            let cellA = `<td>${htmlA}</td>`;
            if (highlightMap.has(nodeA.address)) {
                cellA = addClassToLastCell(cellA, highlightMap.get(nodeA.address));
            }
            table += cellA;

            // Cell AG
            let htmlAG = '';
            if (nodeA.itemGId !== -1) {
                const hrefG = generateItemLink(nodeA.seed2, nodeA.itemGId, initialNg, r, true);
                let nameG = `<a href="${hrefG}">${nodeA.itemGName}</a>`;
                 if (itemMaster[nodeA.itemGId]?.rarity >= 3) nameG = `<span class="featuredItem-text">${nameG}</span>`;
                htmlAG = nameG;
            } else {
                htmlAG = '---';
            }
            let cellAG = `<td>${htmlAG}</td>`;
            if (highlightMap.has(nodeA.address + 'G')) {
                cellAG = addClassToLastCell(cellAG, highlightMap.get(nodeA.address + 'G'));
            }
            table += cellAG;

            // Cell B
            let htmlB = '';
            if (nodeB.itemId !== -1) {
                const href = generateItemLink(nodeB.seed2, nodeB.itemId, initialNg, r, true);
                let name = `<a href="${href}">${nodeB.itemName}</a>`;
                if (itemMaster[nodeB.itemId]?.rarity >= 3) name = `<span class="featuredItem-text">${name}</span>`;
                htmlB += name;
                
                if (nodeB.reRollFlag || (forceRerollMode && nodeB.rarityId === 1 && nodeB.poolSize > 1)) {
                     const hrefRe = generateItemLink(nodeB.seed3, nodeB.reRollItemId, initialNg, r, true);
                     let nameRe = `<a href="${hrefRe}">${nodeB.reRollItemName}</a>`;
                     if (itemMaster[nodeB.reRollItemId]?.rarity >= 3) nameRe = `<span class="featuredItem-text">${nameRe}</span>`;
                     htmlB += `<br>${nodeB.reRollNextAddress})${nameRe}`;
                }
            } else {
                htmlB = '---';
            }
            let cellB = `<td>${htmlB}</td>`;
            if (highlightMap.has(nodeB.address)) {
                cellB = addClassToLastCell(cellB, highlightMap.get(nodeB.address));
            }
            table += cellB;

            // Cell BG
            let htmlBG = '';
            if (nodeB.itemGId !== -1) {
                const hrefG = generateItemLink(nodeB.seed2, nodeB.itemGId, initialNg, r, true);
                let nameG = `<a href="${hrefG}">${nodeB.itemGName}</a>`;
                if (itemMaster[nodeB.itemGId]?.rarity >= 3) nameG = `<span class="featuredItem-text">${nameG}</span>`;
                htmlBG = nameG;
            } else {
                htmlBG = '---';
            }
            let cellBG = `<td>${htmlBG}</td>`;
            if (highlightMap.has(nodeB.address + 'G')) {
                cellBG = addClassToLastCell(cellBG, highlightMap.get(nodeB.address + 'G'));
            }
            table += cellBG;

            table += '</tr>';
        }
        table += '</tbody></table>';

        document.getElementById('result-table-container').innerHTML = table;
        
        // 詳細ログのセット
        const detailsDiv = document.getElementById('calculation-details');
        detailsDiv.innerHTML = detailsHtml;
        
        // ボタンの表示制御
        const detailsControls = document.getElementById('details-controls');
        const toggleBtn = document.getElementById('toggleDetailsBtn');
        const scrollButtons = detailsControls.querySelector('.scroll-buttons');
        
        detailsControls.style.display = 'flex'; // 親コンテナを表示

        toggleBtn.onclick = () => {
            if (detailsDiv.style.display === 'none') {
                detailsDiv.style.display = 'block';
                scrollButtons.style.display = 'flex'; // スクロールボタンを表示
                toggleBtn.textContent = '計算過程を非表示';
            } else {
                detailsDiv.style.display = 'none';
                scrollButtons.style.display = 'none'; // スクロールボタンを非表示
                toggleBtn.textContent = '計算過程を表示';
            }
        };
    }
    // --- ▲ コンプ済みロジック終了 ▲ ---

    // --- 未コンプガチャのロジック (変更なし、関数シグネチャ調整のみ) ---
    function calculateUncompletedCell(startSeedIndex, lastItemId, gacha, SEED, getRarityFromRoll, getAddressString, forceRerollMode, displaySeed, params) {
        if (startSeedIndex + 4 >= SEED.length) return { html: '<td colspan="5"></td>', newItemId: -1 };
        const s1 = SEED[startSeedIndex];
        const featuredFlag = (s1 % 10000) < gacha.featuredItemRate;
        let finalItemId;
        let html;
        let sub5;

        if (featuredFlag) {
            finalItemId = -2;
            const nextSeedIndex = startSeedIndex + 1;
            const href = generateItemLink(s1, -2, params.get('ng'), 0, false); // Link uses s1 as next seed
            sub5 = `${getAddressString(nextSeedIndex)})<span class="featuredItem-text"><a href="${href}">目玉</a></span>`;
            if (displaySeed === '1') {
                const sub1 = `(S${startSeedIndex})${s1}<br>${s1 % 10000}<br>${featuredFlag}`;
                html = `<td>${sub1}</td><td>---</td><td>---</td><td>---</td><td>${sub5}</td>`;
            }
        } else {
            const s2 = SEED[startSeedIndex + 1];
            const s3 = SEED[startSeedIndex + 2];
            const rarityResult = getRarityFromRoll(s2 % 10000);
            const rarityId = rarityResult.id;
            const pool = gacha.rarityItems[rarityId] || [];
            let regularItemId = -1;
            let regularSlot = null;
            let regularItemName = '---';
            if (pool.length > 0) {
                regularSlot = s3 % pool.length;
                regularItemId = pool[regularSlot];
                regularItemName = itemMaster[regularItemId]?.name || '---';
            }
            finalItemId = regularItemId;
            const canReRoll = rarityId === 1 && pool.length >= 2;
            const reRollFlag = canReRoll && regularItemId !== -1 && regularItemId === lastItemId;
            
            let reRollLine = '';
            let reRollItemNameForDisplay = null;
            let reRollSeed = null;
            let reRollItemId;

            if (reRollFlag) {
                const s_reroll_idx = startSeedIndex + 3;
                reRollSeed = SEED[s_reroll_idx];
                const reRollPool = pool.filter(id => id !== lastItemId);
                if (reRollPool.length > 0) {
                    const reRollSlot = reRollSeed % reRollPool.length;
                    reRollItemId = reRollPool[reRollSlot];
                    reRollItemNameForDisplay = itemMaster[reRollItemId]?.name || '---';
                    finalItemId = reRollItemId;
                }
            } else if (forceRerollMode && canReRoll) {
                const reRollPool = pool.filter(id => id !== regularItemId);
                if (reRollPool.length > 0) {
                    const s_reroll_idx = startSeedIndex + 3;
                    reRollSeed = SEED[s_reroll_idx];
                    const reRollSlot = reRollSeed % reRollPool.length;
                    reRollItemId = reRollPool[reRollSlot];
                    reRollItemNameForDisplay = itemMaster[reRollItemId]?.name || '---';
                }
            }

            let styledRegularName = regularItemName;
            if (regularItemId !== -1) {
                const href = generateItemLink(s3, regularItemId, params.get('ng'), 0, false);
                let nameWithLink = `<a href="${href}">${regularItemName}</a>`;
                if (itemMaster[regularItemId]?.rarity >= 3) {
                    styledRegularName = `<span class="featuredItem-text">${nameWithLink}</span>`;
                } else {
                    styledRegularName = nameWithLink;
                }
            }
            const regularLine = styledRegularName;

            if (reRollItemNameForDisplay) {
                const href = generateItemLink(reRollSeed, reRollItemId, params.get('ng'), 0, false);
                let styledRerollName = `<a href="${href}">${reRollItemNameForDisplay}</a>`;
                if (reRollItemId && itemMaster[reRollItemId]?.rarity >= 3) {
                    styledRerollName = `<span class="featuredItem-text">${styledRerollName}</span>`;
                }
                reRollLine = `<br>${getAddressString(startSeedIndex + 4)})${styledRerollName}`;
            }
            
            sub5 = regularLine + reRollLine;

            if (displaySeed === '1') {
                const sub1 = `(S${startSeedIndex})${s1}<br>${s1 % 10000}<br>${featuredFlag}`;
                const sub2 = `(S${startSeedIndex + 1})${s2}<br>${s2 % 10000}<br>${rarityResult.name || ''}`;
                const sub3 = `(S${startSeedIndex + 2})${s3}<br>${pool.length || 1}<br>${regularSlot ?? ''}`;
                let sub4 = '---';
                if (reRollFlag || (forceRerollMode && canReRoll)) {
                    const s_reroll_idx = startSeedIndex + 3;
                    const s_reroll = SEED[s_reroll_idx];
                    const reRollPool = pool.filter(id => id !== (reRollFlag ? lastItemId : regularItemId));
                    if (reRollPool.length > 0) {
                        const reRollSlot = s_reroll % reRollPool.length;
                        sub4 = `(S${s_reroll_idx})${s_reroll}<br>${reRollPool.length}<br>${reRollSlot}`;
                    }
                }
                html = `<td>${sub1}</td><td>${sub2}</td><td>${sub3}</td><td>${sub4}</td><td>${sub5}</td>`;
            }
        }
        if (displaySeed === '0') {
            html = `<td>${sub5}</td>`;
        }
        return { html, newItemId: finalItemId };
    }

    function createAndDisplayUncompletedSeedView(initialSeed, gacha, tableRows, thresholds, initialLastRollId, displaySeed, params) {
        // 未コンプ時は既存ロジックでテーブル生成
        const SEED = [initialSeed];
        for (let i = 1; i < tableRows * 15 + 20; i++) SEED[i] = xorshift32(SEED[i - 1]);
        
        const getRarityFromRoll = (roll) => {
            if (roll < thresholds['0']) return { id: 0, name: 'ノーマル' };
            if (roll < thresholds['1']) return { id: 1, name: 'レア' };
            if (roll < thresholds['2']) return { id: 2, name: '激レア' };
            if (roll < thresholds['3']) return { id: 3, name: '超激レア' };
            return { id: 4, name: '伝説レア' };
        };
        const getAddressString = (n) => {
            if (n <= 0) return '';
            const zeroBasedIndex = n - 1;
            const col_char = String.fromCharCode('A'.charCodeAt(0) + (zeroBasedIndex % 3));
            const row_num = Math.floor(zeroBasedIndex / 3) + 1;
            return `${row_num}${col_char}`;
        };
        
        let table = '<table style="table-layout: fixed;"><thead>';
        let header1 = `<tr><th rowspan="${displaySeed === '1' ? 2 : 1}" id="forceRerollToggle" class="col-no" style="cursor: pointer;">${forceRerollMode ? '☑' : '□'}</th>`;
        let header2 = '<tr>';
        if (displaySeed === '1') {
            header1 += '<th colspan="5">A</th><th colspan="5">B</th><th colspan="5">C</th><th colspan="5">G</th>';
            const subHeaders = ['S1<br>Featured', 'S2<br>Rarity', 'S3<br>Slot', 'S4<br>ReRoll', 'Item<br>Next'];
            for(let i=0; i<4; i++) header2 += subHeaders.map(h => `<th>${h}</th>`).join('');
        } else {
            header1 += '<th>A</th><th>B</th><th>C</th><th>G</th>';
        }
        header1 += '</tr>';
        if (displaySeed === '1') { header2 += '</tr>'; table += header1 + header2; } else { table += header1; }
        table += '</thead><tbody>';
        
        let lastItemA = initialLastRollId;
        let lastItemB = initialLastRollId;
        let lastItemC = initialLastRollId;
        
        for (let r = 0; r < tableRows; r++) {
            table += `<tr><td class="col-no">${r + 1}</td>`;
            const cellA = calculateUncompletedCell(r * 3 + 1, lastItemA, gacha, SEED, getRarityFromRoll, getAddressString, forceRerollMode, displaySeed, params);
            lastItemA = cellA.newItemId;
            table += cellA.html;
            const cellB = calculateUncompletedCell(r * 3 + 2, lastItemB, gacha, SEED, getRarityFromRoll, getAddressString, forceRerollMode, displaySeed, params);
            lastItemB = cellB.newItemId;
            table += cellB.html;
            const cellC = calculateUncompletedCell(r * 3 + 3, lastItemC, gacha, SEED, getRarityFromRoll, getAddressString, forceRerollMode, displaySeed, params);
            lastItemC = cellC.newItemId;
            table += cellC.html;
            
            if (r < 10) {
                 table += displaySeed === '1' ? '<td colspan="5">---</td>' : '<td>---</td>';
            } else {
                 table += displaySeed === '1' ? '<td colspan="5"></td>' : '<td></td>';
            }
            table += '</tr>';
        }
        table += '</tbody></table>';
        document.getElementById('result-table-container').innerHTML = table;
        document.getElementById('toggleDetailsBtn').style.display = 'none';
        document.getElementById('calculation-details').style.display = 'none';
    }

    // --- ディスパッチャー & メイン ---
    let activeGachaId;
    let forceRerollMode = false;

    function runSimulationAndDisplay(options = {}) {
        const { hideSeedInput = false, uiOverrides = {} } = options;
        const params = new URLSearchParams(window.location.search);
        const latestGachaId = Object.keys(gachaMaster).reduce((a, b) => parseInt(a) > parseInt(b) ? a : b);
        
        // パラメータの正規化とDefaults
        const p = {};
        ['gacha', 'seed', 'ng', 'fs', 'lr', 'comp', 'tx', 'roll', 'displaySeed'].forEach(k => {
            p[k] = params.get(k);
        });
        if (!p.gacha || !gachaMaster[p.gacha]) p.gacha = latestGachaId;
        if (!p.seed) p.seed = DEFAULT_PARAMS.seed;
        if (!p.roll) p.roll = DEFAULT_PARAMS.roll;
        if (!p.ng) p.ng = DEFAULT_PARAMS.ng;
        if (p.tx === 'true') p.tx = '1'; else if (p.tx === 'false') p.tx = '0';
        if (!p.tx && DEFAULT_PARAMS.tx) p.tx = '1';
        if (p.comp === '1') p.comp = 'true'; else if (p.comp === '0') p.comp = 'false';
        
        // UI Override
        if (uiOverrides.seed !== undefined) p.seed = uiOverrides.seed;
        if (uiOverrides.guaranteedRolls !== undefined) p.ng = uiOverrides.guaranteedRolls;
        if (uiOverrides.featuredStock !== undefined) p.fs = uiOverrides.featuredStock;
        if (uiOverrides.isComplete !== undefined) p.comp = uiOverrides.isComplete ? 'true' : 'false';
        
        activeGachaId = p.gacha;
        const gacha = gachaMaster[p.gacha];
        
        // UI更新
        document.getElementById('seedInput').value = p.seed;
        const isComplete = (p.comp === 'true');
        document.getElementById('featuredCompleteCheckbox').checked = isComplete;
        
        if (gacha.featuredItemStock === 0) {
            document.getElementById('featuredCompleteCheckbox').checked = true;
            document.getElementById('featuredCompleteCheckbox').parentElement.classList.add('hidden-control');
        } else {
            document.getElementById('featuredCompleteCheckbox').parentElement.classList.remove('hidden-control');
        }
        
        const isComp = document.getElementById('featuredCompleteCheckbox').checked;
        const stockControl = document.getElementById('stockControl');
        const guaranteedControl = document.getElementById('guaranteedControl');
        const legendDisplay = document.getElementById('legendDisplay');

        populateFeaturedStockInput(p.gacha, p.fs);

        if (isComp) {
            stockControl.classList.add('hidden-control');
            if (gacha.uberGuaranteedFlag || gacha.legendGuaranteedFlag) {
                guaranteedControl.classList.remove('hidden-control');
                legendDisplay.classList.remove('hidden-control');
                populateGuaranteedRolls(10, p.ng);
            } else {
                guaranteedControl.classList.add('hidden-control');
                legendDisplay.classList.add('hidden-control');
            }
        } else {
            stockControl.classList.remove('hidden-control');
            guaranteedControl.classList.remove('hidden-control');
            legendDisplay.classList.remove('hidden-control');
            populateGuaranteedRolls(gacha.guaranteedCycle || 30, p.ng);
        }

        const lastRollDisplay = document.getElementById('lastRollDisplay');
        if (p.lr && itemMaster[p.lr]) {
            lastRollDisplay.textContent = `LastRoll: ${itemMaster[p.lr].name}`;
        } else {
            lastRollDisplay.textContent = '';
        }

        // URL更新
        const newParams = {
            gacha: p.gacha, seed: p.seed, ng: p.ng, fs: p.fs, lr: p.lr,
            comp: isComp ? 'true' : 'false',
            tx: (p.tx === '1' || !hideSeedInput) ? '1' : '0',
            roll: p.roll, displaySeed: p.displaySeed
        };
        const newQuery = generateUrlQuery(newParams);
        window.history.replaceState({ path: newQuery }, '', `${window.location.pathname}${newQuery}`);

        // シード入力リンク更新
        const linkP = {...newParams}; linkP.tx = '1';
        document.getElementById('showSeedInputLink').href = generateUrlQuery(linkP);
        if (newParams.tx === '1') {
             document.getElementById('seedRow').classList.remove('hidden-control');
             document.getElementById('seedLinkContainer').classList.add('hidden-control');
        } else {
             document.getElementById('seedRow').classList.add('hidden-control');
             document.getElementById('seedLinkContainer').classList.remove('hidden-control');
        }

        // 計算実行
        const seedValue = parseInt(p.seed, 10);
        const lastRollId = p.lr ? parseInt(p.lr, 10) : null;
        const rows = parseInt(p.roll, 10);
        const thresholds = {
            '0': gacha.rarityRates['0'],
            '1': gacha.rarityRates['0'] + gacha.rarityRates['1'],
            '2': gacha.rarityRates['0'] + gacha.rarityRates['1'] + gacha.rarityRates['2'],
            '3': gacha.rarityRates['0'] + gacha.rarityRates['1'] + gacha.rarityRates['2'] + gacha.rarityRates['3'],
            '4': 10000
        };

        if (isComp) {
            createAndDisplayCompletedSeedView(seedValue, gacha, rows, thresholds, lastRollId, p.displaySeed, new URLSearchParams(newQuery), p.ng);
        } else {
            createAndDisplayUncompletedSeedView(seedValue, gacha, rows, thresholds, lastRollId, p.displaySeed, new URLSearchParams(newQuery));
        }
    }

    function populateGuaranteedRolls(max, currentVal) {
        const input = document.getElementById('guaranteedRollsInput');
        input.innerHTML = '';
        const unsetOption = document.createElement('option');
        unsetOption.value = 'none'; unsetOption.textContent = '未設定'; input.appendChild(unsetOption);
        for (let i = 1; i <= max; i++) {
            const option = document.createElement('option'); option.value = i; option.textContent = i; input.appendChild(option);
        }
        if (currentVal && input.querySelector(`option[value="${currentVal}"]`)) {
            input.value = currentVal;
        } else {
            input.value = 'none';
        }
    }
    function populateFeaturedStockInput(gachaId, preferredValue) {
        const gacha = gachaMaster[gachaId];
        const input = document.getElementById('featuredStockInput');
        if (!gacha) return;
        input.innerHTML = '';
        const unsetOption = document.createElement('option');
        unsetOption.value = 'none'; unsetOption.textContent = '-'; input.appendChild(unsetOption);
        for (let i = 1; i <= gacha.featuredItemStock; i++) {
            const option = document.createElement('option'); option.value = i; option.textContent = i; input.appendChild(option);
        }
        if (preferredValue && preferredValue !== 'none' && input.querySelector(`option[value="${preferredValue}"]`)) {
            input.value = preferredValue;
        } else {
            input.value = 'none';
        }
    }

    function generateItemLink(newSeed, newItemId, initialInputNg, rollNumberInSequence, isCompleted) {
        const currentParams = new URLSearchParams(window.location.search);
        const paramsForQuery = {};
        for (const [key, value] of currentParams.entries()) paramsForQuery[key] = value;
        if (!paramsForQuery.gacha) paramsForQuery.gacha = activeGachaId;

        paramsForQuery.seed = newSeed;
        if (newItemId !== undefined) paramsForQuery.lr = newItemId;

        const initialInputNgInt = parseInt(initialInputNg, 10);
        if (initialInputNg !== 'none' && !isNaN(initialInputNgInt) && rollNumberInSequence) {
            if (isCompleted) {
                const rollInCycle = (rollNumberInSequence - 1) % 10;
                let ngValue = initialInputNgInt - 1 - rollInCycle;
                if (ngValue <= 0) ngValue += 10;
                paramsForQuery.ng = ngValue.toString();
            } else {
                const periodicity = 30;
                let ngValue = (initialInputNgInt - (rollNumberInSequence % periodicity) + periodicity) % periodicity;
                if (ngValue === 0) ngValue = periodicity;
                paramsForQuery.ng = ngValue.toString();
            }
        } else {
            paramsForQuery.ng = 'none';
        }
        return generateUrlQuery(paramsForQuery);
    }

    document.addEventListener('DOMContentLoaded', () => {
        setupGachaRarityItems();
        document.getElementById('executeButton').addEventListener('click', () => runSimulationAndDisplay({ hideSeedInput: true, uiOverrides: { seed: document.getElementById('seedInput').value } }));
        document.getElementById('guaranteedRollsInput').addEventListener('change', (e) => runSimulationAndDisplay({ uiOverrides: { guaranteedRolls: e.target.value } }));
        document.getElementById('featuredStockInput').addEventListener('change', (e) => runSimulationAndDisplay({ uiOverrides: { featuredStock: e.target.value } }));
        document.getElementById('featuredCompleteCheckbox').addEventListener('change', () => runSimulationAndDisplay({ uiOverrides: { isComplete: document.getElementById('featuredCompleteCheckbox').checked } }));
        document.getElementById('copySeedLink').addEventListener('click', (event) => {
            event.preventDefault();
            const seedToCopy = new URLSearchParams(window.location.search).get('seed');
            if (seedToCopy && navigator.clipboard) {
                navigator.clipboard.writeText(seedToCopy).then(() => {
                    const originalText = event.target.textContent;
                    event.target.textContent = 'Copied!';
                    setTimeout(() => { event.target.textContent = originalText; }, 1500);
                });
            }
        });
        document.getElementById('result-table-container').addEventListener('click', (event) => {
            if (event.target.id === 'forceRerollToggle') {
                forceRerollMode = !forceRerollMode;
                runSimulationAndDisplay();
            }
        });

        document.getElementById('scrollToSingle').addEventListener('click', () => {
            const h2s = document.querySelectorAll('#calculation-details h2');
            for (const h2 of h2s) {
                if (h2.textContent.includes('＜単発ルート＞')) {
                    h2.scrollIntoView({ behavior: 'smooth' });
                    break;
                }
            }
        });

        document.getElementById('scrollToMulti').addEventListener('click', () => {
            const h2s = document.querySelectorAll('#calculation-details h2');
            for (const h2 of h2s) {
                if (h2.textContent.includes('＜10連ルート＞')) {
                    h2.scrollIntoView({ behavior: 'smooth' });
                    break;
                }
            }
        });

        runSimulationAndDisplay();
    });
</script>
</body>
</html>