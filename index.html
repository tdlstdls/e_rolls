<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>イベントガチャロールズ</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.2;
            padding: 5px;
            max-width: 1200px;
            margin: 0 auto;
            background-color: #f4f7f9;
            color: #333;
            font-size: 9px;
        }
        .container {
            background: #fff;
            padding: 5px;
            border-radius: 12px;
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.1);
        }
        h1 {
            color: #004085;
            font-size: 0.9rem;
            border-bottom: 1px solid #e9ecef;
            padding-bottom: 3px;
            margin-top: 0;
            text-align: center;
        }
        .controls {
            display: flex;
            flex-direction: column;
            gap: 5px;
            margin-bottom: 10px;
            padding: 4px;
            background-color: #f9fbfd;
            border-radius: 4px;
        }
        .row {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
            gap: 5px;
            align-items: center;
        }
        .control-group-left, .control-group-right {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        .input-item {
            flex: 0 1 auto;
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 3px;
        }
        .input-item-display-only {
            flex: 0 1 auto;
            display: flex;
            align-items: center;
            font-size: 0.7rem;
            color: #555;
            padding: 0 5px;
        }
        .input-item-seed {
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 3px;
        }
        .seed-input-group {
            display: flex;
            align-items: center;
            gap: 5px;
            flex: 1 1 200px;
        }
        label {
            font-weight: 600;
            color: #555;
        }
        input[type="number"],
        select {
            padding: 3px;
            border: 1px solid #ccc;
            border-radius: 3px;
            font-size: 0.8rem;
            width: 100%;
            box-sizing: border-box;
            transition: border-color 0.3s;
        }
        input[type="number"]:focus,
        select:focus {
            outline: none;
            border-color: #007bff;
        }
        button {
            flex-shrink: 0;
            width: auto;
            padding: 5px 10px;
            background-color: #007bff;
            color: #fff;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.8rem;
            font-weight: bold;
            transition: background-color 0.3s ease, transform 0.2s ease;
        }
        .hidden-control {
            display: none !important;
        }
        #showSeedInputLink {
            color: #007bff;
            text-decoration: underline;
            cursor: pointer;
            padding: 0 5px;
        }
        #copySeedLink {
            color: #007bff;
            text-decoration: underline;
            cursor: pointer;
            white-space: nowrap;
        }

        button:hover {
            background-color: #0056b3;
            transform: translateY(-2px);
        }
        #result-container {
            margin-top: 15px;
        }
        #result-table-container {
            overflow-x: auto;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
        }
        table {
            width: 100%;
            border-collapse: collapse;
        }
        th, td {
            padding: 3px;
            text-align: center;
            border: 1px solid #e0e0e0;
            word-break: break-word;
            font-size: 0.8rem;
            min-width: 25px;
        }
        th {
            background-color: #f0f4f7;
            color: #444;
            font-weight: 600;
            position: sticky;
            top: 0;
            z-index: 1;
        }
        thead th:first-child {
            z-index: 2;
        }
        td {
            background-color: #fff;
        }
        .row-number-header {
            font-family: Arial, sans-serif;
            font-weight: bold;
            width: 25px;
            cursor: pointer;
        }
        .col-no {
            width: 25px;
        }
        
        /* アイテム装飾 */
        .featuredItem-text {
            color: #d9534f; /* 赤 */
            font-weight: bold;
        }
        .legendItem-text {
            color: #0000ff; /* 青 */
            font-weight: bold;
        }

        #result-table-container td a {
            color: inherit;
            text-decoration: none;
        }

        /* ハイライト用CSS */
        .highlight-roll { background-color: #e0f7ff !important; } /* 単発 (青) */
        .highlight-roll-10 { background-color: #a0eaff !important; }
        .highlight-roll-10pull { background-color: #ffffe0 !important; } /* 10連 (黄) */
        .highlight-roll-10pull-10 { background-color: #FFF39B !important; }
        .highlight-roll-overlap { background-color: #dfffb0 !important; } /* 重複 (緑) */
        .highlight-roll-overlap-10 { background-color: #a0eda0 !important; }
        
        #calculation-details {
            font-family: monospace;
            font-size: 11px;
            line-height: 1.4;
            margin-top: 15px;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
            background: #f9f9f9;
        }
        #calculation-details h2 {
            font-size: 1.1rem;
            margin-top: 20px;
            margin-bottom: 5px;
            border-bottom: 1px solid #ccc;
            padding-bottom: 3px;
        }
        #toggleDetailsBtn {
            background-color: #6c757d;
        }
        #toggleDetailsBtn:hover {
            background-color: #5a6268;
        }
        #details-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
        }
        .scroll-buttons {
            display: flex; /* This will be toggled by JS */
            gap: 10px;
        }
        .scroll-buttons button {
            font-size: 0.75rem;
            background-color: #28a745;
        }
        .scroll-buttons button:hover {
            background-color: #218838;
        }
    </style>
</head>
<body>

<div class="container">
    <h1>イベントガチャロールズ</h1>
    <div class="input-group">
        <div class="controls">
            <div class="row">
                <div class="control-group-left">
                    <div class="input-item" id="seedLinkContainer">
                        <a id="showSeedInputLink" href="#">SEED入力</a>
                    </div>
                    <div class="input-item" id="guaranteedControl">
                        <label for="guaranteedRollsInput">next guaranteed</label>
                        <select id="guaranteedRollsInput"></select>
                    </div>
                    <div class="input-item" id="legendDisplay" style="font-size: 0.7rem;">
                        <span style="background-color: #e0f7ff; padding: 2px 5px; border-radius: 3px; margin-left: 10px;">単発ルート</span>
                        <span style="background-color: #ffffe0; padding: 2px 5px; border-radius: 3px; margin-left: 5px;">10連ルート</span>
                        <span style="background-color: #dfffb0; padding: 2px 5px; border-radius: 3px; margin-left: 5px;">共通ルート</span>
                    </div>
                    <div id="lastRollDisplay" class="input-item-display-only">
                        </div>
                </div>
                <div class="control-group-right">
                    <div class="input-item">
                        <label for="featuredCompleteCheckbox">コンプ済み</label>
                        <input type="checkbox" id="featuredCompleteCheckbox">
                    </div>
                    <div class="input-item" id="stockControl">
                        <label for="featuredStockInput">目玉残数</label>
                        <select id="featuredStockInput"></select>
                    </div>
                    <a id="copySeedLink" href="#">Copy SEED</a>
                </div>
            </div>
            <div class="row hidden-control" id="seedRow">
                <div class="input-item-seed">
                    <label for="seedInput">SEED</label>
                    <div class="seed-input-group">
                        <input type="number" id="seedInput" value="123456789">
                        <button id="executeButton">更新</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div id="result-container">
        <div id="output"></div>
        <div id="result-table-container"></div>
        <div id="details-controls" style="display: none; margin-top: 10px; align-items: center; gap: 10px;">
            <button id="toggleDetailsBtn">計算過程を表示</button>
            <div class="scroll-buttons" style="display: none;">
                <button id="scrollToSingle">単発ルートへ</button>
                <button id="scrollToMulti">10連ルートへ</button>
            </div>
        </div>
        <div id="calculation-details" style="display:none;"></div>
    </div>
</div>

<script>
    // --- マスターデータ ---
    const gachaMaster = {
        '34': { name: '(旧)ハロウィン', featuredItemRate: 600, featuredItemStock: 5, guaranteedCycle: 30, uberGuaranteedFlag: false, legendGuaranteedFlag: false, rarityRates: { '0': 2000, '1': 5000, '2': 3000, '3': 0, '4': 0 }, pool: [0, 2, 3, 4, 5, 10, 11, 12, 14] },
        '42': { name: '1.1億DL記念', featuredItemRate: 500, featuredItemStock: 5, guaranteedCycle: 30, uberGuaranteedFlag: false, legendGuaranteedFlag: false, rarityRates: { '0': 1000, '1': 5000, '2': 3000, '3': 1000, '4': 0 }, pool: [0, 2, 3, 4, 5, 10, 11, 12, 14, 375, 381, 689] },
        '44': { name: 'ハロウィン', featuredItemRate: 500, featuredItemStock: 8, guaranteedCycle: 30, uberGuaranteedFlag: false, legendGuaranteedFlag: false, rarityRates: { '0': 2000, '1': 4900, '2': 3000, '3': 0, '4': 100 }, pool: [0, 2, 3, 4, 5, 10, 11, 12, 14, 18] },
        '45': { name: 'にゃんこレンジャー', featuredItemRate: 0, featuredItemStock: 0, guaranteedCycle: 10, uberGuaranteedFlag: true, legendGuaranteedFlag: false, rarityRates: { '0': 0, '1': 7000, '2': 2300, '3': 500, '4': 200 }, pool: [0,2,3,4,5,11,12,14,197,184,375,726,831] }
    };
    const itemMaster = {
        0: { name: "スピダ", rarity: 1 }, 2: { name: "ネコボン", rarity: 2 }, 3: { name: "ニャンピュ", rarity: 1 }, 4: { name: "おかめ", rarity: 2 }, 5: { name: "スニャ", rarity: 2 },
        10: { name: "5千XP", rarity: 0 }, 11: { name: "1万XP", rarity: 1 }, 12: { name: "3万XP", rarity: 1 }, 14: { name: "10万XP", rarity: 2 }, 18: { name: "200万XP", rarity: 4 },
        197: { name: "100万XP", rarity: 4 }, 184: { name: "ミスターニンジャ", rarity: 3 }, 375: { name: "記念ネコ", rarity: 3 }, 381: { name: "ねこ農家", rarity: 3 },
        689: { name: "石の上にも10年ネコ", rarity: 3 }, 726: { name: "ネコメダル王", rarity: 3 }, 831: { name: "スカーフにゃんこ", rarity: 3 }
    };

    const DEFAULT_PARAMS = {
        gacha: '45',
        seed: '123456789',
        ng: 'none',
        fs: 'none',
        lr: null,
        comp: false,
        tx: false,
        roll: 100,
        displaySeed: '0'
    };

    function generateUrlQuery(p) {
        const query = new URLSearchParams();
        for (const key in p) {
            if (key === 'displaySeed' && p[key] === DEFAULT_PARAMS.displaySeed) continue;
            if (p[key] !== null && p[key] !== undefined) query.set(key, p[key]);
        }
        return '?' + query.toString();
    }
    
    function xorshift32(seed) {
        let x = seed;
        x ^= x << 13; x ^= x >>> 17; x ^= x << 15;
        return x >>> 0;
    }
    function setupGachaRarityItems() {
        for (const gachaId in gachaMaster) {
            const gacha = gachaMaster[gachaId];
            if (gacha && gacha.pool) {
                gacha.rarityItems = { '0': [], '1': [], '2': [], '3': [], '4': [] };
                for (const itemId of gacha.pool) {
                    const item = itemMaster[itemId];
                    if (item && gacha.rarityItems[item.rarity] !== undefined) {
                        gacha.rarityItems[item.rarity].push(itemId);
                    }
                }
                for (const rarity in gacha.rarityItems) gacha.rarityItems[rarity].sort((a, b) => a - b);
            }
        }
    }

    function addClassToLastCell(cellHtml, className) {
        if (!className) return cellHtml;
        const lastTdIndex = cellHtml.lastIndexOf('<td');
        if (lastTdIndex === -1) return cellHtml;
        return cellHtml.substring(0, lastTdIndex) + cellHtml.substring(lastTdIndex).replace(/<td/, `<td class="${className}"`);
    }

    // --- コンプ済み・一括計算ロジック ---
    function createAndDisplayCompletedSeedView(initialSeed, gacha, tableRows, thresholds, initialLastRollId, displaySeed, params, initialNg) {
        // 1. シードの生成 (十分な量を確保)
        const SEED = [initialSeed];
        const maxSeedsNeeded = tableRows * 4 * 2 + 1000; 
        for (let i = 1; i < maxSeedsNeeded; i++) {
            SEED[i] = xorshift32(SEED[i - 1]);
        }

        const getRarityFromRoll = (roll) => {
            if (roll < thresholds['0']) return { id: 0, name: 'ノーマル' };
            if (roll < thresholds['1']) return { id: 1, name: 'レア' };
            if (roll < thresholds['2']) return { id: 2, name: '激レア' };
            if (roll < thresholds['3']) return { id: 3, name: '超激レア' };
            return { id: 4, name: '伝説レア' };
        };

        const getAddressString = (n) => {
            if (n <= 0) return '';
            const zeroBasedIndex = n - 1;
            const col_char = String.fromCharCode('A'.charCodeAt(0) + (zeroBasedIndex % 2));
            const row_num = Math.floor(zeroBasedIndex / 2) + 1;
            return `${row_num}${col_char}`;
        };

        // 2. 全ノードの事前計算
        const Nodes = [];
        const maxNodeIndex = tableRows * 2 + 100;
        
        // ログ生成用変数
        let detailsHtml = '<h2>＜ノード計算詳細 (No.1～)＞</h2>';
        detailsHtml += '<p style="margin-top: -10px; font-size: 10px;">（このデータは、特定のSEED INDEXからの計算結果を示します。実際のルートではレア被りにより消費SEED数が異なります）</p>';

        for (let i = 1; i <= maxNodeIndex; i++) {
            const node = {
                index: i,
                address: getAddressString(i),
                seed1: SEED[i],
                seed2: SEED[i+1],
                seed3: SEED[i+2]
            };

            // (レアリティ判定)
            const roll1 = node.seed1 % 10000;
            node.rarity = getRarityFromRoll(roll1);
            node.rarityId = node.rarity.id;

            // (確定枠レアリティ判定)
            const uberRate = gacha.uberGuaranteedFlag ? (gacha.rarityRates['3'] || 0) : 0;
            const legendRate = gacha.legendGuaranteedFlag ? (gacha.rarityRates['4'] || 0) : 0;
            const gDivisor = uberRate + legendRate;
            if (gDivisor > 0) {
                const gRoll = node.seed1 % gDivisor;
                node.rarityGId = (gRoll < uberRate) ? '3' : '4';
                node.rarityGName = (node.rarityGId === '3') ? '超激レア' : '伝説レア';
                node.gRoll = gRoll; node.gDivisor = gDivisor;
            } else {
                node.rarityGId = null; node.rarityGName = '-'; node.gRoll = 0; node.gDivisor = 0;
            }

            // (スロット, ID, 名称)
            const pool = gacha.rarityItems[node.rarityId] || [];
            node.poolSize = pool.length;
            if (pool.length > 0) {
                node.slot = node.seed2 % pool.length;
                node.itemId = pool[node.slot];
                node.itemName = itemMaster[node.itemId]?.name || '---';
            } else {
                node.slot = 0; node.itemId = -1; node.itemName = '---';
            }

            // (確定枠スロット)
            const poolG = node.rarityGId ? (gacha.rarityItems[node.rarityGId] || []) : [];
            node.poolGSize = poolG.length;
            if (poolG.length > 0) {
                node.slotG = node.seed2 % poolG.length;
                node.itemGId = poolG[node.slotG];
                node.itemGName = itemMaster[node.itemGId]?.name || '---';
            } else {
                node.slotG = 0; node.itemGId = -1; node.itemGName = '---';
            }

            // (静的ReRollFlag計算 - A/B列の整合性を保つため2つ前と比較)
            const prevNode = (i > 2) ? Nodes[i - 3] : null;
            const isRare = (node.rarityId === 1);
            const prevItemId = prevNode ? prevNode.itemId : -1;
            // ルート外の静的表示用ReRollFlag
            node.reRollFlag = isRare && (pool.length > 1) && (node.itemId !== -1) && (node.itemId === prevItemId);
            node.useSeeds = node.reRollFlag ? 3 : 2;

            // ★★★ 修正: ReRollFlagに関わらず、レアリティがレアでプールが複数なら常に再抽選候補を計算 ★★★
            if (isRare && pool.length > 1) {
                 const reRollPool = pool.filter(id => id !== node.itemId);
                 if (reRollPool.length > 0) {
                     node.reRollSlot = node.seed3 % reRollPool.length;
                     node.reRollItemId = reRollPool[node.reRollSlot];
                     node.reRollItemName = itemMaster[node.reRollItemId]?.name || '---';
                 } else {
                     node.reRollItemId = -1; node.reRollItemName = '---';
                 }
                 // 仮にここが再抽選だった場合の次のアドレスも計算
                 const nextIdxRe = i + 3;
                 node.reRollNextAddress = getAddressString(nextIdxRe);
            } else {
                 node.reRollItemId = -1; node.reRollItemName = '---';
                 node.reRollNextAddress = '-';
            }
            
            Nodes.push(node);

            // --- 詳細ログ生成 (No.X) ---
            let lines = [];
            lines.push(`(番地) address[${node.index}]=${node.address}`);
            lines.push(`(レアリティ判定) rarity[${node.index}]=S1(${node.seed1})%10000=${node.seed1%10000}→${node.rarity.name}`);
            lines.push(`(確定枠レアリティ判定) rarityG[${node.index}]=S1(${node.seed1})%${node.gDivisor}=${node.gRoll}→${node.rarityGName}`);
            lines.push(`(スロット,ID,名称判定) slot[${node.index}]=S2(${node.seed2})%${node.poolSize}=${node.slot},ItemID[${node.index}]=${node.itemId},ItemName[${node.index}]=${node.itemName}`);
            
            if (node.rarityGId) {
                lines.push(`(確定枠スロット,ID,名称判定) slotG[${node.index}]=S2(${node.seed2})%${node.poolGSize}=${node.slotG},GID[${node.index}]=${node.itemGId},GName[${node.index}]=${node.itemGName}`);
            } else {
                lines.push(`(確定枠なし)`);
            }

            lines.push(`(レア被り判定,消費SEED数) ReRollFlag[${node.index}]=${node.reRollFlag},useSeeds[${node.index}]=${node.useSeeds}`);
            
            // 再抽選データがあれば（静的フラグに関わらず）表示
            if (node.reRollItemId !== -1) {
                 lines.push(`(再抽選スロット判定) ReRollSlot[${node.index}]=S3(${node.seed3})%(${pool.length-1})=${node.reRollSlot},ReRollItemID[${node.index}]=${node.reRollItemId},ReRollItemName[${node.index}]=${node.reRollItemName}`);
                 lines.push(`(再抽選後の遷移先番地) ReRollNextAddress[${node.index}]=${node.reRollNextAddress}`);
            }
            detailsHtml += `<strong>No.${node.index}</strong><br>` + lines.join('<br>') + '<br><br>';
        }

        // 3. パス追跡とログ生成
        const highlightInfo = new Map(); 

        // ----------------------------
        // A. 単発ルート計算
        // ----------------------------
        let singleRouteLog = '<h2>＜単発ルート＞</h2>';
        let sIdx = 1;
        let sLastItemId = initialLastRollId || -1;
        const ngVal = parseInt(initialNg, 10);
        const hasGuaranteed = !isNaN(ngVal);

        for (let roll = 1; roll <= tableRows; roll++) {
            if (sIdx > maxNodeIndex) break;
            const node = Nodes[sIdx - 1];
            const isGuaranteedRoll = hasGuaranteed && (roll >= ngVal) && ((roll - ngVal) % 10 === 0);
            
            singleRouteLog += `<strong>Roll${roll}</strong>${isGuaranteedRoll?'(guaranteed)':''}<br>`;
            
            if (isGuaranteedRoll) {
                const addressKey = node.address + 'G';
                singleRouteLog += `(番地) address[${sIdx}]=${addressKey}(${sIdx})<br>`;
                singleRouteLog += `(当該ロール使用Seed数) 2 (固定)<br><br>`;

                const info = highlightInfo.get(addressKey) || {};
                info.single = true;
                highlightInfo.set(addressKey, info);
                
                sLastItemId = node.itemGId;
                sIdx += 2; 
            } else {
                const isRare = (node.rarityId === 1);
                const poolSize = gacha.rarityItems[1] ? gacha.rarityItems[1].length : 0;
                const isMatch = (node.itemId !== -1 && node.itemId === sLastItemId);
                const reRollFlag = isRare && isMatch && poolSize > 1;
                
                singleRouteLog += `(番地) address[${sIdx}]=${node.address}(${sIdx})<br>`;
                singleRouteLog += `(当該Rollのレアリティ) rarity[${sIdx}]=${node.rarity.name}<br>`;
                singleRouteLog += `(当該Rollの通常抽選アイテムID) Item[${sIdx}]=${node.itemId}<br>`;
                singleRouteLog += `(直前ロールアイテムID) ${sLastItemId}<br>`;
                singleRouteLog += `(レア被り判定) SingleReRollFlag[${roll}]=${reRollFlag}<br>`;
                
                singleRouteLog += `(再抽選アイテムID)<br>`;
                if (reRollFlag) {
                    singleRouteLog += `SingleReRollFlag[${roll}]=True→ ReRollItemID[${sIdx}]=${node.reRollItemId}<br>`;
                } else {
                    singleRouteLog += `SingleReRollFlag[${roll}]=False→ null<br>`;
                }
                
                singleRouteLog += `(当該Roll最終抽選アイテムID)<br>`;
                const finalId = reRollFlag ? node.reRollItemId : node.itemId;
                if (reRollFlag) {
                    singleRouteLog += `SingleReRollFlag[${roll}]=True→ SingleItemID[${roll}]=${finalId}<br>`;
                } else {
                    singleRouteLog += `SingleReRollFlag[${roll}]=False→ SingleItemID[${roll}]=${finalId}<br>`;
                }
                
                const useSeeds = reRollFlag ? 3 : 2;
                singleRouteLog += `(当該ロール使用Seed数)<br>`;
                if (reRollFlag) {
                    singleRouteLog += `SingleReRollFlag[${roll}]=True→ 3<br>`;
                } else {
                    singleRouteLog += `SingleReRollFlag[${roll}]=False→ 2<br>`;
                }
                
                const nextIdx = sIdx + useSeeds;
                const nextAddr = getAddressString(nextIdx);
                singleRouteLog += `(遷移先番地)<br>`;
                singleRouteLog += `当該ロール使用Seed数${useSeeds} → 当該番地${sIdx}+${useSeeds}＝遷移先番地${nextIdx}（${nextAddr}）<br><br>`;
                
                const info = highlightInfo.get(node.address) || {};
                info.single = true;
                info.s_reRoll = reRollFlag;
                if (reRollFlag) {
                    info.s_normalName = node.itemName;
                    info.s_reRollName = node.reRollItemName;
                    info.s_nextAddr = nextAddr;
                }
                highlightInfo.set(node.address, info);

                sLastItemId = finalId;
                sIdx += useSeeds;
            }
        }

        // ----------------------------
        // B. 10連ルート計算
        // ----------------------------
        let tenPullRouteLog = '';
        if (hasGuaranteed) {
            tenPullRouteLog += '<h2>＜10連ルート＞</h2>';
            let tIdx = 1;
            let tLastItemId = initialLastRollId || -1;

            for (let roll = 1; roll <= tableRows; roll++) {
                if (tIdx > maxNodeIndex) break;
                
                const isCycleStart = (roll - 1) % 10 === 0;
                if (isCycleStart) {
                    const nodeG = Nodes[tIdx - 1];
                    const cycleNum = Math.floor((roll - 1) / 10) + 1;
                    tenPullRouteLog += `<strong>${cycleNum}サイクル目</strong><br>`;
                    tenPullRouteLog += `(確定枠レアリティ判定(初めの１SEEDを消費)) rarityG[${tIdx}]→${nodeG.rarityGName}<br><br>`;
                    tIdx++;
                }
                
                const node = Nodes[tIdx - 1];
                const isGuaranteedRoll = (roll >= ngVal) && ((roll - ngVal) % 10 === 0);

                tenPullRouteLog += `<strong>Roll${roll}</strong><br>`;

                if (isGuaranteedRoll) {
                    const gNode = Nodes[tIdx - 2];
                    const addressKey = gNode.address + 'G';
                    
                    tenPullRouteLog += `(番地) address[${tIdx-1}]=${addressKey}(${tIdx-1})<br>`;
                    tenPullRouteLog += `(消費SEED数(確定枠スロット判定)) 1<br><br>`;
                    
                    const info = highlightInfo.get(addressKey) || {};
                    info.ten = true;
                    highlightInfo.set(addressKey, info);
                    
                    tLastItemId = gNode.itemGId;
                    tIdx += 1;
                } else {
                    const isRare = (node.rarityId === 1);
                    const poolSize = gacha.rarityItems[1] ? gacha.rarityItems[1].length : 0;
                    const isMatch = (node.itemId !== -1 && node.itemId === tLastItemId);
                    const reRollFlag = isRare && isMatch && poolSize > 1;

                    tenPullRouteLog += `(番地) address[${tIdx}]=${node.address}(${tIdx})<br>`;
                    tenPullRouteLog += `(当該Rollのレアリティ) rarity[${tIdx}]=${node.rarity.name}<br>`;
                    tenPullRouteLog += `(当該Rollの通常抽選アイテムID) Item[${tIdx}]=${node.itemId}<br>`;
                    tenPullRouteLog += `(直前ロールアイテムID) ${tLastItemId}<br>`;
                    tenPullRouteLog += `(レア被り判定) TenPullReRollFlag[${roll}]=${reRollFlag}<br>`;
                    
                    tenPullRouteLog += `(再抽選アイテムID)<br>`;
                    if (reRollFlag) {
                        tenPullRouteLog += `TenPullReRollFlag[${roll}]=True→ ReRollItemID[${tIdx}]=${node.reRollItemId}<br>`;
                    } else {
                        tenPullRouteLog += `TenPullReRollFlag[${roll}]=False→ null<br>`;
                    }
                    
                    tenPullRouteLog += `(当該Roll最終抽選アイテムID)<br>`;
                    const finalId = reRollFlag ? node.reRollItemId : node.itemId;
                    if (reRollFlag) {
                        tenPullRouteLog += `TenPullReRollFlag[${roll}]=True→ TenPullItemID[${roll}]=${finalId}<br>`;
                    } else {
                        tenPullRouteLog += `TenPullReRollFlag[${roll}]=False→ TenPullItemID[${roll}]=${finalId}<br>`;
                    }
                    
                    const useSeeds = reRollFlag ? 3 : 2;
                    tenPullRouteLog += `(当該ロール使用Seed数)<br>`;
                    if (reRollFlag) {
                        tenPullRouteLog += `TenPullReRollFlag[${roll}]=True→ 3<br>`;
                    } else {
                        tenPullRouteLog += `TenPullReRollFlag[${roll}]=False→ 2<br>`;
                    }
                    
                    const nextIdx = tIdx + useSeeds;
                    const nextAddr = getAddressString(nextIdx);
                    tenPullRouteLog += `(遷移先番地)<br>`;
                    tenPullRouteLog += `当該ロール使用Seed数${useSeeds} → 当該番地${tIdx}+${useSeeds}＝遷移先番地${nextIdx}（${nextAddr}）<br><br>`;

                    const info = highlightInfo.get(node.address) || {};
                    info.ten = true;
                    info.t_reRoll = reRollFlag;
                    if (reRollFlag) {
                        info.t_normalName = node.itemName;
                        info.t_reRollName = node.reRollItemName;
                        info.t_nextAddr = nextAddr;
                    }
                    highlightInfo.set(node.address, info);

                    tLastItemId = finalId;
                    tIdx += useSeeds;
                }
            }
        }

        detailsHtml += singleRouteLog;
        detailsHtml += tenPullRouteLog;


        // 5. 表の生成
        let table = '<table style="table-layout: fixed;"><thead>';
        table += `<tr><th id="forceRerollToggle" class="col-no" style="cursor: pointer;">${forceRerollMode ? '☑' : '□'}</th><th>A</th><th>AG</th><th>B</th><th>BG</th></tr>`;
        table += '</thead><tbody>';

        for (let r = 1; r <= tableRows; r++) {
            const nodeIdxA = (r - 1) * 2 + 1;
            const nodeIdxB = (r - 1) * 2 + 2;
            const nodeA = Nodes[nodeIdxA - 1];
            const nodeB = Nodes[nodeIdxB - 1];

            if (!nodeA || !nodeB) break;

            table += `<tr><td class="col-no">${r}</td>`;

            const renderCell = (node, suffix) => {
                const address = node.address + suffix;
                const info = highlightInfo.get(address);
                const isGuaranteed = (suffix === 'G');
                const itemId = isGuaranteed ? node.itemGId : node.itemId;
                const itemName = isGuaranteed ? node.itemGName : node.itemName;
                const itemRarity = itemMaster[itemId]?.rarity;
                
                let cellContent = '---';
                if (itemId !== -1) {
                    const href = generateItemLink(node.seed2, itemId, initialNg, r, true);
                    let nameHtml = `<a href="${href}">${itemName}</a>`;
                    
                    // 装飾クラス適用（コンプ済みG列は赤太字適用なし）
                    let cssClass = '';
                    if (!isGuaranteed) {
                        if (itemRarity === 4) cssClass = 'legendItem-text'; // 伝説：青太字
                        else if (itemRarity >= 3) cssClass = 'featuredItem-text'; // 超激：赤太字
                    }

                    if (cssClass) nameHtml = `<span class="${cssClass}">${nameHtml}</span>`;
                    
                    let showReRoll = false;
                    let rrNextAddr = '';
                    let rrName = '';
                    let normName = itemName;

                    // 1. ハイライトルート上の動的再抽選
                    if (info && !isGuaranteed) {
                        if (info.single && info.s_reRoll) {
                            showReRoll = true;
                            rrNextAddr = info.s_nextAddr;
                            rrName = info.s_reRollName;
                            normName = info.s_normalName;
                        } else if (info.ten && info.t_reRoll) {
                            showReRoll = true;
                            rrNextAddr = info.t_nextAddr;
                            rrName = info.t_reRollName;
                            normName = info.t_normalName;
                        }
                    } 
                    // 2. 非ハイライトだが静的計算で再抽選フラグが立っている場合
                    else if (!isGuaranteed && (node.reRollFlag || (forceRerollMode && node.rarityId === 1 && node.poolSize > 1))) {
                        showReRoll = true;
                        rrNextAddr = node.reRollNextAddress;
                        rrName = node.reRollItemName;
                        normName = node.itemName;
                    }

                    if (showReRoll) {
                         const hrefRe = generateItemLink(node.seed3, node.reRollItemId, initialNg, r, true);
                         let rrNameHtml = `<a href="${hrefRe}">${rrName}</a>`;
                         
                         let rrCssClass = '';
                         const rrRarity = itemMaster[node.reRollItemId]?.rarity;
                         if (rrRarity === 4) rrCssClass = 'legendItem-text';
                         else if (rrRarity >= 3) rrCssClass = 'featuredItem-text';
                         if (rrCssClass) rrNameHtml = `<span class="${rrCssClass}">${rrNameHtml}</span>`;
                         
                         const hrefNorm = generateItemLink(node.seed2, node.itemId, initialNg, r, true);
                         let normNameHtml = `<a href="${hrefNorm}">${normName}</a>`;
                         if (cssClass) normNameHtml = `<span class="${cssClass}">${normNameHtml}</span>`;

                         cellContent = `${normNameHtml}<br>${rrNextAddr})${rrNameHtml}`;
                    } else {
                         cellContent = nameHtml;
                    }
                }

                let cls = '';
                if (info) {
                    if (info.single && info.ten) cls = 'highlight-roll-overlap';
                    else if (info.single) cls = 'highlight-roll';
                    else if (info.ten) cls = 'highlight-roll-10pull';
                }
                return { html: `<td${cls ? ' class="'+cls+'"' : ''}>${cellContent}</td>` };
            };

            table += renderCell(nodeA, '').html;
            table += renderCell(nodeA, 'G').html;
            table += renderCell(nodeB, '').html;
            table += renderCell(nodeB, 'G').html;
            table += '</tr>';
        }
        table += '</tbody></table>';

        document.getElementById('result-table-container').innerHTML = table;
        
        // 詳細ログのセット
        const detailsDiv = document.getElementById('calculation-details');
        detailsDiv.innerHTML = detailsHtml;
        
        // ボタンの表示制御
        const detailsControls = document.getElementById('details-controls');
        const toggleBtn = document.getElementById('toggleDetailsBtn');
        const scrollButtons = detailsControls.querySelector('.scroll-buttons');
        
        detailsControls.style.display = 'flex';

        toggleBtn.onclick = () => {
            if (detailsDiv.style.display === 'none') {
                detailsDiv.style.display = 'block';
                scrollButtons.style.display = 'flex';
                toggleBtn.textContent = '計算過程を非表示';
            } else {
                detailsDiv.style.display = 'none';
                scrollButtons.style.display = 'none';
                toggleBtn.textContent = '計算過程を表示';
            }
        };
    }
    // --- ▲ コンプ済みロジック終了 ▲ ---

    // --- 未コンプガチャのロジック (変更なし、関数シグネチャ調整のみ) ---
    function calculateUncompletedCell(startSeedIndex, lastItemId, gacha, SEED, getRarityFromRoll, getAddressString, forceRerollMode, displaySeed, params) {
        if (startSeedIndex + 4 >= SEED.length) return { html: '<td colspan="5"></td>', newItemId: -1 };
        const s1 = SEED[startSeedIndex];
        const featuredFlag = (s1 % 10000) < gacha.featuredItemRate;
        let finalItemId;
        let html;
        let sub5;

        if (featuredFlag) {
            finalItemId = -2;
            const nextSeedIndex = startSeedIndex + 1;
            const href = generateItemLink(s1, -2, params.get('ng'), 0, false); // Link uses s1 as next seed
            sub5 = `${getAddressString(nextSeedIndex)})<span class="featuredItem-text"><a href="${href}">目玉</a></span>`;
            if (displaySeed === '1') {
                const sub1 = `(S${startSeedIndex})${s1}<br>${s1 % 10000}<br>${featuredFlag}`;
                html = `<td>${sub1}</td><td>---</td><td>---</td><td>---</td><td>${sub5}</td>`;
            }
        } else {
            const s2 = SEED[startSeedIndex + 1];
            const s3 = SEED[startSeedIndex + 2];
            const rarityResult = getRarityFromRoll(s2 % 10000);
            const rarityId = rarityResult.id;
            const pool = gacha.rarityItems[rarityId] || [];
            let regularItemId = -1;
            let regularSlot = null;
            let regularItemName = '---';
            if (pool.length > 0) {
                regularSlot = s3 % pool.length;
                regularItemId = pool[regularSlot];
                regularItemName = itemMaster[regularItemId]?.name || '---';
            }
            finalItemId = regularItemId;
            const canReRoll = rarityId === 1 && pool.length >= 2;
            const reRollFlag = canReRoll && regularItemId !== -1 && regularItemId === lastItemId;
            
            let reRollLine = '';
            let reRollItemNameForDisplay = null;
            let reRollSeed = null;
            let reRollItemId;

            if (reRollFlag) {
                const s_reroll_idx = startSeedIndex + 3;
                reRollSeed = SEED[s_reroll_idx];
                const reRollPool = pool.filter(id => id !== lastItemId);
                if (reRollPool.length > 0) {
                    const reRollSlot = reRollSeed % reRollPool.length;
                    reRollItemId = reRollPool[reRollSlot];
                    reRollItemNameForDisplay = itemMaster[reRollItemId]?.name || '---';
                    finalItemId = reRollItemId;
                }
            } else if (forceRerollMode && canReRoll) {
                const reRollPool = pool.filter(id => id !== regularItemId);
                if (reRollPool.length > 0) {
                    const s_reroll_idx = startSeedIndex + 3;
                    reRollSeed = SEED[s_reroll_idx];
                    const reRollSlot = reRollSeed % reRollPool.length;
                    reRollItemId = reRollPool[reRollSlot];
                    reRollItemNameForDisplay = itemMaster[reRollItemId]?.name || '---';
                }
            }

            let styledRegularName = regularItemName;
            if (regularItemId !== -1) {
                const href = generateItemLink(s3, regularItemId, params.get('ng'), 0, false);
                let nameWithLink = `<a href="${href}">${regularItemName}</a>`;
                if (itemMaster[regularItemId]?.rarity >= 3) {
                    styledRegularName = `<span class="featuredItem-text">${nameWithLink}</span>`;
                } else {
                    styledRegularName = nameWithLink;
                }
            }
            const regularLine = styledRegularName;

            if (reRollItemNameForDisplay) {
                const href = generateItemLink(reRollSeed, reRollItemId, params.get('ng'), 0, false);
                let styledRerollName = `<a href="${href}">${reRollItemNameForDisplay}</a>`;
                if (reRollItemId && itemMaster[reRollItemId]?.rarity >= 3) {
                    styledRerollName = `<span class="featuredItem-text">${styledRerollName}</span>`;
                }
                reRollLine = `<br>${getAddressString(startSeedIndex + 4)})${styledRerollName}`;
            }
            
            sub5 = regularLine + reRollLine;

            if (displaySeed === '1') {
                const sub1 = `(S${startSeedIndex})${s1}<br>${s1 % 10000}<br>${featuredFlag}`;
                const sub2 = `(S${startSeedIndex + 1})${s2}<br>${s2 % 10000}<br>${rarityResult.name || ''}`;
                const sub3 = `(S${startSeedIndex + 2})${s3}<br>${pool.length || 1}<br>${regularSlot ?? ''}`;
                let sub4 = '---';
                if (reRollFlag || (forceRerollMode && canReRoll)) {
                    const s_reroll_idx = startSeedIndex + 3;
                    const s_reroll = SEED[s_reroll_idx];
                    const reRollPool = pool.filter(id => id !== (reRollFlag ? lastItemId : regularItemId));
                    if (reRollPool.length > 0) {
                        const reRollSlot = s_reroll % reRollPool.length;
                        sub4 = `(S${s_reroll_idx})${s_reroll}<br>${reRollPool.length}<br>${reRollSlot}`;
                    }
                }
                html = `<td>${sub1}</td><td>${sub2}</td><td>${sub3}</td><td>${sub4}</td><td>${sub5}</td>`;
            }
        }
        if (displaySeed === '0') {
            html = `<td>${sub5}</td>`;
        }
        return { html, newItemId: finalItemId };
    }

    function createAndDisplayUncompletedSeedView(initialSeed, gacha, tableRows, thresholds, initialLastRollId, displaySeed, params) {
        // 未コンプ時は既存ロジックでテーブル生成
        const SEED = [initialSeed];
        for (let i = 1; i < tableRows * 15 + 20; i++) SEED[i] = xorshift32(SEED[i - 1]);
        
        const getRarityFromRoll = (roll) => {
            if (roll < thresholds['0']) return { id: 0, name: 'ノーマル' };
            if (roll < thresholds['1']) return { id: 1, name: 'レア' };
            if (roll < thresholds['2']) return { id: 2, name: '激レア' };
            if (roll < thresholds['3']) return { id: 3, name: '超激レア' };
            return { id: 4, name: '伝説レア' };
        };
        const getAddressString = (n) => {
            if (n <= 0) return '';
            const zeroBasedIndex = n - 1;
            const col_char = String.fromCharCode('A'.charCodeAt(0) + (zeroBasedIndex % 3));
            const row_num = Math.floor(zeroBasedIndex / 3) + 1;
            return `${row_num}${col_char}`;
        };
        
        let table = '<table style="table-layout: fixed;"><thead>';
        let header1 = `<tr><th rowspan="${displaySeed === '1' ? 2 : 1}" id="forceRerollToggle" class="col-no" style="cursor: pointer;">${forceRerollMode ? '☑' : '□'}</th>`;
        let header2 = '<tr>';
        if (displaySeed === '1') {
            header1 += '<th colspan="5">A</th><th colspan="5">B</th><th colspan="5">C</th><th colspan="5">G</th>';
            const subHeaders = ['S1<br>Featured', 'S2<br>Rarity', 'S3<br>Slot', 'S4<br>ReRoll', 'Item<br>Next'];
            for(let i=0; i<4; i++) header2 += subHeaders.map(h => `<th>${h}</th>`).join('');
        } else {
            header1 += '<th>A</th><th>B</th><th>C</th><th>G</th>';
        }
        header1 += '</tr>';
        if (displaySeed === '1') { header2 += '</tr>'; table += header1 + header2; } else { table += header1; }
        table += '</thead><tbody>';
        
        let lastItemA = initialLastRollId;
        let lastItemB = initialLastRollId;
        let lastItemC = initialLastRollId;
        
        for (let r = 0; r < tableRows; r++) {
            table += `<tr><td class="col-no">${r + 1}</td>`;
            const cellA = calculateUncompletedCell(r * 3 + 1, lastItemA, gacha, SEED, getRarityFromRoll, getAddressString, forceRerollMode, displaySeed, params);
            lastItemA = cellA.newItemId;
            table += cellA.html;
            const cellB = calculateUncompletedCell(r * 3 + 2, lastItemB, gacha, SEED, getRarityFromRoll, getAddressString, forceRerollMode, displaySeed, params);
            lastItemB = cellB.newItemId;
            table += cellB.html;
            const cellC = calculateUncompletedCell(r * 3 + 3, lastItemC, gacha, SEED, getRarityFromRoll, getAddressString, forceRerollMode, displaySeed, params);
            lastItemC = cellC.newItemId;
            table += cellC.html;
            
            if (r < 10) {
                 table += displaySeed === '1' ? '<td colspan="5">---</td>' : '<td>---</td>';
            } else {
                 table += displaySeed === '1' ? '<td colspan="5"></td>' : '<td></td>';
            }
            table += '</tr>';
        }
        table += '</tbody></table>';
        document.getElementById('result-table-container').innerHTML = table;
        document.getElementById('toggleDetailsBtn').style.display = 'none';
        document.getElementById('calculation-details').style.display = 'none';
    }

    // --- ディスパッチャー & メイン ---
    let activeGachaId;
    let forceRerollMode = false;

    function runSimulationAndDisplay(options = {}) {
        const { hideSeedInput = false, uiOverrides = {} } = options;
        const params = new URLSearchParams(window.location.search);
        const latestGachaId = Object.keys(gachaMaster).reduce((a, b) => parseInt(a) > parseInt(b) ? a : b);
        
        // パラメータの正規化とDefaults
        const p = {};
        ['gacha', 'seed', 'ng', 'fs', 'lr', 'comp', 'tx', 'roll', 'displaySeed'].forEach(k => {
            p[k] = params.get(k);
        });
        if (!p.gacha || !gachaMaster[p.gacha]) p.gacha = latestGachaId;
        if (!p.seed) p.seed = DEFAULT_PARAMS.seed;
        if (!p.roll) p.roll = DEFAULT_PARAMS.roll;
        if (!p.ng) p.ng = DEFAULT_PARAMS.ng;
        if (p.tx === 'true') p.tx = '1'; else if (p.tx === 'false') p.tx = '0';
        if (!p.tx && DEFAULT_PARAMS.tx) p.tx = '1';
        if (p.comp === '1') p.comp = 'true'; else if (p.comp === '0') p.comp = 'false';
        
        // UI Override
        if (uiOverrides.seed !== undefined) p.seed = uiOverrides.seed;
        if (uiOverrides.guaranteedRolls !== undefined) p.ng = uiOverrides.guaranteedRolls;
        if (uiOverrides.featuredStock !== undefined) p.fs = uiOverrides.featuredStock;
        if (uiOverrides.isComplete !== undefined) p.comp = uiOverrides.isComplete ? 'true' : 'false';
        
        activeGachaId = p.gacha;
        const gacha = gachaMaster[p.gacha];
        
        // UI更新
        document.getElementById('seedInput').value = p.seed;
        const isComplete = (p.comp === 'true');
        document.getElementById('featuredCompleteCheckbox').checked = isComplete;
        
        if (gacha.featuredItemStock === 0) {
            document.getElementById('featuredCompleteCheckbox').checked = true;
            document.getElementById('featuredCompleteCheckbox').parentElement.classList.add('hidden-control');
        } else {
            document.getElementById('featuredCompleteCheckbox').parentElement.classList.remove('hidden-control');
        }
        
        const isComp = document.getElementById('featuredCompleteCheckbox').checked;
        const stockControl = document.getElementById('stockControl');
        const guaranteedControl = document.getElementById('guaranteedControl');
        const legendDisplay = document.getElementById('legendDisplay');

        populateFeaturedStockInput(p.gacha, p.fs);

        if (isComp) {
            stockControl.classList.add('hidden-control');
            if (gacha.uberGuaranteedFlag || gacha.legendGuaranteedFlag) {
                guaranteedControl.classList.remove('hidden-control');
                legendDisplay.classList.remove('hidden-control');
                populateGuaranteedRolls(10, p.ng);
            } else {
                guaranteedControl.classList.add('hidden-control');
                legendDisplay.classList.add('hidden-control');
            }
        } else {
            stockControl.classList.remove('hidden-control');
            guaranteedControl.classList.remove('hidden-control');
            legendDisplay.classList.remove('hidden-control');
            populateGuaranteedRolls(gacha.guaranteedCycle || 30, p.ng);
        }

        const lastRollDisplay = document.getElementById('lastRollDisplay');
        if (p.lr && itemMaster[p.lr]) {
            lastRollDisplay.textContent = `LastRoll: ${itemMaster[p.lr].name}`;
        } else {
            lastRollDisplay.textContent = '';
        }

        // URL更新
        const newParams = {
            gacha: p.gacha, seed: p.seed, ng: p.ng, fs: p.fs, lr: p.lr,
            comp: isComp ? 'true' : 'false',
            tx: (p.tx === '1' || !hideSeedInput) ? '1' : '0',
            roll: p.roll, displaySeed: p.displaySeed
        };
        const newQuery = generateUrlQuery(newParams);
        window.history.replaceState({ path: newQuery }, '', `${window.location.pathname}${newQuery}`);

        // シード入力リンク更新
        const linkP = {...newParams}; linkP.tx = '1';
        document.getElementById('showSeedInputLink').href = generateUrlQuery(linkP);
        if (newParams.tx === '1') {
             document.getElementById('seedRow').classList.remove('hidden-control');
             document.getElementById('seedLinkContainer').classList.add('hidden-control');
        } else {
             document.getElementById('seedRow').classList.add('hidden-control');
             document.getElementById('seedLinkContainer').classList.remove('hidden-control');
        }

        // 計算実行
        const seedValue = parseInt(p.seed, 10);
        const lastRollId = p.lr ? parseInt(p.lr, 10) : null;
        const rows = parseInt(p.roll, 10);
        const thresholds = {
            '0': gacha.rarityRates['0'],
            '1': gacha.rarityRates['0'] + gacha.rarityRates['1'],
            '2': gacha.rarityRates['0'] + gacha.rarityRates['1'] + gacha.rarityRates['2'],
            '3': gacha.rarityRates['0'] + gacha.rarityRates['1'] + gacha.rarityRates['2'] + gacha.rarityRates['3'],
            '4': 10000
        };

        if (isComp) {
            createAndDisplayCompletedSeedView(seedValue, gacha, rows, thresholds, lastRollId, p.displaySeed, new URLSearchParams(newQuery), p.ng);
        } else {
            createAndDisplayUncompletedSeedView(seedValue, gacha, rows, thresholds, lastRollId, p.displaySeed, new URLSearchParams(newQuery));
        }
    }

    function populateGuaranteedRolls(max, currentVal) {
        const input = document.getElementById('guaranteedRollsInput');
        input.innerHTML = '';
        const unsetOption = document.createElement('option');
        unsetOption.value = 'none'; unsetOption.textContent = '未設定'; input.appendChild(unsetOption);
        for (let i = 1; i <= max; i++) {
            const option = document.createElement('option'); option.value = i; option.textContent = i; input.appendChild(option);
        }
        if (currentVal && input.querySelector(`option[value="${currentVal}"]`)) {
            input.value = currentVal;
        } else {
            input.value = 'none';
        }
    }
    function populateFeaturedStockInput(gachaId, preferredValue) {
        const gacha = gachaMaster[gachaId];
        const input = document.getElementById('featuredStockInput');
        if (!gacha) return;
        input.innerHTML = '';
        const unsetOption = document.createElement('option');
        unsetOption.value = 'none'; unsetOption.textContent = '-'; input.appendChild(unsetOption);
        for (let i = 1; i <= gacha.featuredItemStock; i++) {
            const option = document.createElement('option'); option.value = i; option.textContent = i; input.appendChild(option);
        }
        if (preferredValue && preferredValue !== 'none' && input.querySelector(`option[value="${preferredValue}"]`)) {
            input.value = preferredValue;
        } else {
            input.value = 'none';
        }
    }

    function generateItemLink(newSeed, newItemId, initialInputNg, rollNumberInSequence, isCompleted) {
        const currentParams = new URLSearchParams(window.location.search);
        const paramsForQuery = {};
        for (const [key, value] of currentParams.entries()) paramsForQuery[key] = value;
        if (!paramsForQuery.gacha) paramsForQuery.gacha = activeGachaId;

        paramsForQuery.seed = newSeed;
        if (newItemId !== undefined) paramsForQuery.lr = newItemId;

        const initialInputNgInt = parseInt(initialInputNg, 10);
        if (initialInputNg !== 'none' && !isNaN(initialInputNgInt) && rollNumberInSequence) {
            if (isCompleted) {
                const rollInCycle = (rollNumberInSequence - 1) % 10;
                let ngValue = initialInputNgInt - 1 - rollInCycle;
                if (ngValue <= 0) ngValue += 10;
                paramsForQuery.ng = ngValue.toString();
            } else {
                const periodicity = 30;
                let ngValue = (initialInputNgInt - (rollNumberInSequence % periodicity) + periodicity) % periodicity;
                if (ngValue === 0) ngValue = periodicity;
                paramsForQuery.ng = ngValue.toString();
            }
        } else {
            paramsForQuery.ng = 'none';
        }
        return generateUrlQuery(paramsForQuery);
    }

    document.addEventListener('DOMContentLoaded', () => {
        setupGachaRarityItems();
        document.getElementById('executeButton').addEventListener('click', () => runSimulationAndDisplay({ hideSeedInput: true, uiOverrides: { seed: document.getElementById('seedInput').value } }));
        document.getElementById('guaranteedRollsInput').addEventListener('change', (e) => runSimulationAndDisplay({ uiOverrides: { guaranteedRolls: e.target.value } }));
        document.getElementById('featuredStockInput').addEventListener('change', (e) => runSimulationAndDisplay({ uiOverrides: { featuredStock: e.target.value } }));
        document.getElementById('featuredCompleteCheckbox').addEventListener('change', () => runSimulationAndDisplay({ uiOverrides: { isComplete: document.getElementById('featuredCompleteCheckbox').checked } }));
        document.getElementById('copySeedLink').addEventListener('click', (event) => {
            event.preventDefault();
            const seedToCopy = new URLSearchParams(window.location.search).get('seed');
            if (seedToCopy && navigator.clipboard) {
                navigator.clipboard.writeText(seedToCopy).then(() => {
                    const originalText = event.target.textContent;
                    event.target.textContent = 'Copied!';
                    setTimeout(() => { event.target.textContent = originalText; }, 1500);
                });
            }
        });
        document.getElementById('result-table-container').addEventListener('click', (event) => {
            if (event.target.id === 'forceRerollToggle') {
                forceRerollMode = !forceRerollMode;
                runSimulationAndDisplay();
            }
        });

        document.getElementById('scrollToSingle').addEventListener('click', () => {
            const h2s = document.querySelectorAll('#calculation-details h2');
            for (const h2 of h2s) {
                if (h2.textContent.includes('＜単発ルート＞')) {
                    h2.scrollIntoView({ behavior: 'smooth' });
                    break;
                }
            }
        });

        document.getElementById('scrollToMulti').addEventListener('click', () => {
            const h2s = document.querySelectorAll('#calculation-details h2');
            for (const h2 of h2s) {
                if (h2.textContent.includes('＜10連ルート＞')) {
                    h2.scrollIntoView({ behavior: 'smooth' });
                    break;
                }
            }
        });

        runSimulationAndDisplay();
    });
</script>
</body>
</html>