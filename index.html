<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>イベントガチャロールズ</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.2;
            padding: 5px;
            max-width: 1200px; /* Increased width for new layout */
            margin: 0 auto;
            background-color: #f4f7f9;
            color: #333;
            font-size: 9px;
        }
        .container {
            background: #fff;
            padding: 5px;
            border-radius: 12px;
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.1);
        }
        h1 {
            color: #004085;
            font-size: 0.9rem;
            border-bottom: 1px solid #e9ecef;
            padding-bottom: 3px;
            margin-top: 0;
            text-align: center;
        }
        .controls {
            display: flex;
            flex-direction: column;
            gap: 5px;
            margin-bottom: 10px;
            padding: 4px;
            background-color: #f9fbfd;
            border-radius: 4px;
        }
        .row {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
            gap: 5px;
            align-items: center;
        }
        .control-group-left, .control-group-right {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        .input-item {
            flex: 0 1 auto;
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 3px;
        }
        .input-item-display-only {
            flex: 0 1 auto;
            display: flex;
            align-items: center;
            font-size: 0.7rem;
            color: #555;
            padding: 0 5px;
        }
        .input-item-seed {
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 3px;
        }
        .seed-input-group {
            display: flex;
            align-items: center;
            gap: 5px;
            flex: 1 1 200px;
        }
        label {
            font-weight: 600;
            color: #555;
        }
        input[type="number"],
        select {
            padding: 3px;
            border: 1px solid #ccc;
            border-radius: 3px;
            font-size: 0.8rem;
            width: 100%;
            box-sizing: border-box;
            transition: border-color 0.3s;
        }
        input[type="number"]:focus,
        select:focus {
            outline: none;
            border-color: #007bff;
        }
        button {
            flex-shrink: 0;
            width: auto;
            padding: 5px 10px;
            background-color: #007bff;
            color: #fff;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.8rem;
            font-weight: bold;
            transition: background-color 0.3s ease, transform 0.2s ease;
        }
        .hidden-control {
            display: none !important;
        }
        #showSeedInputLink {
            color: #007bff;
            text-decoration: underline;
            cursor: pointer;
            padding: 0 5px;
        }
        #copySeedLink {
            color: #007bff;
            text-decoration: underline;
            cursor: pointer;
            white-space: nowrap;
        }

        button:hover {
            background-color: #0056b3;
            transform: translateY(-2px);
        }
        #result-container {
            margin-top: 15px;
        }
        #result-table-container {
            overflow-x: auto;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
        }
        table {
            width: 100%;
            border-collapse: collapse;
        }
        th, td {
            padding: 3px;
            text-align: center;
            border: 1px solid #e0e0e0;
            word-break: break-word; /* Allow long words to break */
            font-size: 0.8rem;
            min-width: 25px; /* Halved width */
        }
        th {
            background-color: #f0f4f7;
            color: #444;
            font-weight: 600;
            position: sticky;
            top: 0;
            z-index: 1;
        }
        thead th:first-child {
            z-index: 2;
        }
        td {
            background-color: #fff;
        }
        .row-number-header {
            font-family: Arial, sans-serif;
            font-weight: bold;
            width: 25px;
            cursor: pointer;
        }
        .col-no {
            width: 25px;
        }
        .featuredItem-text {
            color: #d9534f;
            font-weight: bold;
        }

        /* --- ▼ 修正 (1): リンクのスタイルを無効化 ▼ --- */
        #result-table-container td a {
            color: inherit; /* 親要素の色を継承 */
            text-decoration: none; /* 下線を削除 */
        }
        /* --- ▲ 修正 (1) 完了 ▲ --- */

        /* --- ▼ 修正 (3): ハイライト用CSS (全色) ▼ --- */
        /* 単発ルート (緑) */
        .highlight-roll { background-color: #e0ffe0 !important; }
        .highlight-roll-10 { background-color: #a0eda0 !important; }
        /* 10連ルート (黄) */
        .highlight-roll-10pull { background-color: #ffffe0 !important; }
        .highlight-roll-10pull-10 { background-color: #f0f050 !important; }
        /* 重複ルート (黄緑) */
        .highlight-roll-overlap { background-color: #dfffb0 !important; }
        .highlight-roll-overlap-10 { background-color: #90dd40 !important; }
        /* --- ▲ 修正 (3) 完了 ▲ --- */
    </style>
</head>
<body>

<div class="container">
    <h1>イベントガチャロールズ</h1>
    <div class="input-group">
        <div class="controls">
            <div class="row">
                <div class="control-group-left">
                    <div class="input-item" id="seedLinkContainer">
                        <a id="showSeedInputLink" href="#">SEED入力</a>
                    </div>
                    <div class="input-item" id="guaranteedControl">
                        <label for="guaranteedRollsInput">next guaranteed</label>
                        <select id="guaranteedRollsInput"></select>
                    </div>
                    <div class="input-item" id="legendDisplay" style="font-size: 0.7rem;">
                        <span style="background-color: #e0ffe0; padding: 2px 5px; border-radius: 3px; margin-left: 10px;">単発ルート</span>
                        <span style="background-color: #ffffe0; padding: 2px 5px; border-radius: 3px; margin-left: 5px;">10連ルート</span>
                        <span style="background-color: #dfffb0; padding: 2px 5px; border-radius: 3px; margin-left: 5px;">共通ルート</span>
                    </div>
                    <div id="lastRollDisplay" class="input-item-display-only">
                        </div>
                </div>
                <div class="control-group-right">
                    <div class="input-item">
                        <label for="featuredCompleteCheckbox">コンプ済み</label>
                        <input type="checkbox" id="featuredCompleteCheckbox">
                    </div>
                    <div class="input-item" id="stockControl">
                        <label for="featuredStockInput">目玉残数</label>
                        <select id="featuredStockInput"></select>
                    </div>
                    <a id="copySeedLink" href="#">Copy SEED</a>
                </div>
            </div>
            <div class="row hidden-control" id="seedRow">
                <div class="input-item-seed">
                    <label for="seedInput">SEED</label>
                    <div class="seed-input-group">
                        <input type="number" id="seedInput" value="123456789">
                        <button id="executeButton">更新</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div id="result-container">
        <div id="output"></div>
        <div id="result-table-container"></div>
    </div>
</div>

<script>
    // --- マスターデータ ---
    const gachaMaster = {
        '34': { name: '(旧)ハロウィン', featuredItemRate: 600, featuredItemStock: 5, guaranteedCycle: 30, uberGuaranteedFlag: false, legendGuaranteedFlag: false, rarityRates: { '0': 2000, '1': 5000, '2': 3000, '3': 0, '4': 0 }, pool: [0, 2, 3, 4, 5, 10, 11, 12, 14] },
        '42': { name: '1.1億DL記念', featuredItemRate: 500, featuredItemStock: 5, guaranteedCycle: 30, uberGuaranteedFlag: false, legendGuaranteedFlag: false, rarityRates: { '0': 1000, '1': 5000, '2': 3000, '3': 1000, '4': 0 }, pool: [0, 2, 3, 4, 5, 10, 11, 12, 14, 375, 381, 689] },
        '44': { name: 'ハロウィン', featuredItemRate: 500, featuredItemStock: 8, guaranteedCycle: 30, uberGuaranteedFlag: false, legendGuaranteedFlag: false, rarityRates: { '0': 2000, '1': 4900, '2': 3000, '3': 0, '4': 100 }, pool: [0, 2, 3, 4, 5, 10, 11, 12, 14, 18] },
        '45': { name: 'にゃんこレンジャー', featuredItemRate: 0, featuredItemStock: 0, guaranteedCycle: 10, uberGuaranteedFlag: true, legendGuaranteedFlag: false, rarityRates: { '0': 0, '1': 7000, '2': 2300, '3': 500, '4': 200 }, pool: [0,2,3,4,5,11,12,14,197,184,375,726,831] }
    };
    const itemMaster = {
        0: { name: "スピダ", rarity: 1 }, 2: { name: "ネコボン", rarity: 2 }, 3: { name: "ニャンピュ", rarity: 1 }, 4: { name: "おかめ", rarity: 2 }, 5: { name: "スニャ", rarity: 2 },
        10: { name: "5千XP", rarity: 0 }, 11: { name: "1万XP", rarity: 1 }, 12: { name: "3万XP", rarity: 1 }, 14: { name: "10万XP", rarity: 2 }, 18: { name: "200万XP", rarity: 4 },
        197: { name: "100万XP", rarity: 4 }, 184: { name: "ミスターニンジャ", rarity: 3 }, 375: { name: "記念ネコ", rarity: 3 }, 381: { name: "ねこ農家", rarity: 3 },
        689: { name: "石の上にも10年ネコ", rarity: 3 }, 726: { name: "ネコメダル王", rarity: 3 }, 831: { name: "スカーフにゃんこ", rarity: 3 }
    };
    // --- ユーティリティ関数 ---
    function xorshift32(seed) {
        let x = seed;
        x ^= x << 13; x ^= x >>> 17; x ^= x << 15;
        return x >>> 0;
    }
    function setupGachaRarityItems() {
        for (const gachaId in gachaMaster) {
            const gacha = gachaMaster[gachaId];
            if (gacha && gacha.pool) {
                gacha.rarityItems = { '0': [], '1': [], '2': [], '3': [], '4': [] };
                for (const itemId of gacha.pool) {
                    const item = itemMaster[itemId];
                    if (item && gacha.rarityItems[item.rarity] !== undefined) {
                        gacha.rarityItems[item.rarity].push(itemId);
                    }
                }
                for (const rarity in gacha.rarityItems) gacha.rarityItems[rarity].sort((a, b) => a - b);
            }
        }
    }
    // --- ▼ 修正 (4): ハイライト計算・適用ロジック追加 ▼ ---
    /**
     * レンダリングされたセルのHTML文字列にクラスを追加します。
     * @param {string} cellHtml - 1つ以上の <td>...</td> を含むHTML文字列
     * @param {string} className - 追加するクラス名 (空の場合は何もしない)
     * @returns {string} - クラスが追加されたHTML文字列
     */
    function addClassToCell(cellHtml, className) {
        if (!className) return cellHtml;
        // <td> で始まる最初のタグにクラスを追加します (colspan対応)
        return cellHtml.replace(/<td/, `<td class="${className}"`);
    }
    /**
     * コンプ済みガチャの1ロール分のシミュレーションを行います（ハイライトパス計算用）。
     * @param {number} startSeedIndex - このロールの開始シードIndex (S1)
     * @param {number} lastItemId - 直前のロールのアイテムID (レア被り判定用)
     * @param {number[]} SEED - シード配列
     * @param {object} gacha - ガチャのマスターデータ
     * @param {function} getRarityFromRoll - レアリティ判定関数
     * @returns {{nextSeedIndex: number, newItemId: number, address: number}}
     */
    function calculateCompletedRoll(startSeedIndex, lastItemId, SEED, gacha, getRarityFromRoll) {
        // 少なくともS1, S2 が必要
        if (startSeedIndex + 1 >= SEED.length) {
            return { nextSeedIndex: startSeedIndex + 2, newItemId: -1, address: startSeedIndex, reRollFlag: false };
        }
        
        const s1 = SEED[startSeedIndex];
        const s2 = SEED[startSeedIndex + 1];
        const rarityResult = getRarityFromRoll(s1 % 10000);
        const rarityId = rarityResult.id;
        const pool = gacha.rarityItems[rarityId] || [];
        
        let regularItemId = -1;
        if (pool.length > 0) {
            regularItemId = pool[s2 % pool.length];
        }

        const canReRoll = rarityId === 1 && pool.length >= 2;
        const reRollFlag = canReRoll && regularItemId !== -1 && regularItemId === lastItemId;
        
        let finalItemId = regularItemId;
        let nextSeedIndex = startSeedIndex + 2; // s1, s2 の2シード消費

        if (reRollFlag) {
            // レア被り時、S3 が必要
            if (startSeedIndex + 2 < SEED.length) {
                const s3 = SEED[startSeedIndex + 2];
                const reRollPool = pool.filter(id => id !== lastItemId);
                if (reRollPool.length > 0) {
                    finalItemId = reRollPool[s3 % reRollPool.length];
                }
                nextSeedIndex = startSeedIndex + 3; // s1, s2, s3 の3シード消費
            }
        } else if (forceRerollMode && canReRoll) {
             // 強制再抽選モード時も、S3 を消費する
            if (startSeedIndex + 2 < SEED.length) {
                nextSeedIndex = startSeedIndex + 3; // s1, s2, s3 の3シード消費
                // finalItemId は変わらない (表示のみのため)
            }
        }

        return { nextSeedIndex: nextSeedIndex, newItemId: finalItemId, address: startSeedIndex, reRollFlag: reRollFlag };
    }
    // --- ▲ 修正 (4) 完了 ▲ ---
    // --- 表示ロジック ---
    // --- 未コンプガチャの計算と表示 ---
    function calculateUncompletedCell(startSeedIndex, lastItemId, gacha, SEED, getRarityFromRoll, getAddressString, forceRerollMode, displaySeed, params) {
        // This function calculates the result for a single cell and returns its HTML and the resulting item ID.
        // Guard against running out of seeds
        if (startSeedIndex + 4 >= SEED.length) {
            return { html: '<td colspan="5"></td>', newItemId: -1 };
        }
        const s1 = SEED[startSeedIndex];
        const featuredFlag = (s1 % 10000) < gacha.featuredItemRate;
        let finalItemId;
        let html;
        let sub5;

        if (featuredFlag) {
            finalItemId = -2; // 目玉
            const nextSeedIndex = startSeedIndex + 1;
            const href = generateItemLink(s1, -2); // 目玉は s1 が最後のSEED
            sub5 = `${getAddressString(nextSeedIndex)})<span class="featuredItem-text"><a href="${href}">目玉</a></span>`;
            if (displaySeed === '1') {
                const sub1 = `(S${startSeedIndex})${s1}<br>${s1 % 10000}<br>${featuredFlag}`;
                html = `<td>${sub1}</td><td>---</td><td>---</td><td>---</td><td>${sub5}</td>`;
            }
        } else {
            const s2 = SEED[startSeedIndex + 1];
            const s3 = SEED[startSeedIndex + 2];
            const rarityResult = getRarityFromRoll(s2 % 10000);
            const rarityId = rarityResult.id;
            const pool = gacha.rarityItems[rarityId] || [];
            let regularItemId = -1;
            let regularSlot = null;
            let regularItemName = '---';
            if (pool.length > 0) {
                regularSlot = s3 % pool.length;
                regularItemId = pool[regularSlot];
                regularItemName = itemMaster[regularItemId]?.name || '---';
            }
            finalItemId = regularItemId;
            const canReRoll = rarityId === 1 && pool.length >= 2;
            const reRollFlag = canReRoll && regularItemId !== -1 && regularItemId === lastItemId;
            
            let reRollLine = '';
            let reRollItemNameForDisplay = null;
            let reRollSeed = null;
            let reRollItemId;


            if (reRollFlag) {
                const s_reroll_idx = startSeedIndex + 3;
                reRollSeed = SEED[s_reroll_idx];
                const reRollPool = pool.filter(id => id !== lastItemId);
                if (reRollPool.length > 0) {
                    const reRollSlot = reRollSeed % reRollPool.length;
                    reRollItemId = reRollPool[reRollSlot];
                    reRollItemNameForDisplay = itemMaster[reRollItemId]?.name || '---';
                    finalItemId = reRollItemId;
                }
            } else if (forceRerollMode && canReRoll) {
                const reRollPool = pool.filter(id => id !== regularItemId);
                if (reRollPool.length > 0) {
                    const s_reroll_idx = startSeedIndex + 3;
                    reRollSeed = SEED[s_reroll_idx];
                    const reRollSlot = reRollSeed % reRollPool.length;
                    reRollItemId = reRollPool[reRollSlot];
                    reRollItemNameForDisplay = itemMaster[reRollItemId]?.name || '---';
                }
            }

            // Styling & Linking
            let styledRegularName = regularItemName;
            if (regularItemId !== -1) {
                const href = generateItemLink(s3, regularItemId); // 通常抽選は s3 が最後のSEED
                let nameWithLink = `<a href="${href}">${regularItemName}</a>`;
                if (itemMaster[regularItemId]?.rarity >= 3) {
                    styledRegularName = `<span class="featuredItem-text">${nameWithLink}</span>`;
                } else {
                    styledRegularName = nameWithLink;
                }
            }
            const regularLine = styledRegularName;

            if (reRollItemNameForDisplay) {
                const href = generateItemLink(reRollSeed, reRollItemId); // 再抽選は reRollSeed (s4) が最後のSEED
                let styledRerollName = `<a href="${href}">${reRollItemNameForDisplay}</a>`;
                if (reRollItemId && itemMaster[reRollItemId]?.rarity >= 3) {
                    styledRerollName = `<span class="featuredItem-text">${styledRerollName}</span>`;
                }
                reRollLine = `<br>${getAddressString(startSeedIndex + 4)})${styledRerollName}`;
            }
            
            sub5 = regularLine + reRollLine;

            if (displaySeed === '1') {
                const sub1 = `(S${startSeedIndex})${s1}<br>${s1 % 10000}<br>${featuredFlag}`;
                const sub2 = `(S${startSeedIndex + 1})${s2}<br>${s2 % 10000}<br>${rarityResult.name || ''}`;
                const sub3 = `(S${startSeedIndex + 2})${s3}<br>${pool.length || 1}<br>${regularSlot ?? ''}`;
                let sub4 = '---';
                if (reRollFlag || (forceRerollMode && canReRoll)) {
                    const s_reroll_idx = startSeedIndex + 3;
                    const s_reroll = SEED[s_reroll_idx];
                    const reRollPool = pool.filter(id => id !== (reRollFlag ? lastItemId : regularItemId));
                    if (reRollPool.length > 0) {
                        const reRollSlot = s_reroll % reRollPool.length;
                        sub4 = `(S${s_reroll_idx})${s_reroll}<br>${reRollPool.length}<br>${reRollSlot}`;
                    }
                }
                html = `<td>${sub1}</td><td>${sub2}</td><td>${sub3}</td><td>${sub4}</td><td>${sub5}</td>`;
            }
        }
        if (displaySeed === '0') {
            html = `<td>${sub5}</td>`;
        }
        return { html, newItemId: finalItemId };
    }
                function calculateUncompletedRoll(startSeedIndex, lastItemId, gacha, SEED, getRarityFromRoll) {
        // Guard against running out of seeds
        if (startSeedIndex + 4 >= SEED.length) {
            return { nextSeedIndex: startSeedIndex + 1, newItemId: -1, reRollFlag: false, address: startSeedIndex };
        }

        const s1 = SEED[startSeedIndex];
        const featuredFlag = (s1 % 10000) < gacha.featuredItemRate;

        if (featuredFlag) {
            // 目玉の場合
            return {
                nextSeedIndex: startSeedIndex + 1,
                newItemId: -2, // 目玉
                reRollFlag: false,
                address: startSeedIndex
            };
        } else {
            // 通常抽選
            const s2 = SEED[startSeedIndex + 1];
            const s3 = SEED[startSeedIndex + 2];
            const rarityResult = getRarityFromRoll(s2 % 10000);
            const rarityId = rarityResult.id;
            const pool = gacha.rarityItems[rarityId] || [];
            
            let regularItemId = -1;
            if (pool.length > 0) {
                regularItemId = pool[s3 % pool.length];
            }

            const canReRoll = rarityId === 1 && pool.length >= 2;
            const reRollFlag = canReRoll && regularItemId !== -1 && regularItemId === lastItemId;

            let finalItemId = regularItemId;
            let nextSeedIndex = startSeedIndex + 3; // s1, s2, s3

            if (reRollFlag) {
                if (startSeedIndex + 3 < SEED.length) {
                    const s4 = SEED[startSeedIndex + 3];
                    const reRollPool = pool.filter(id => id !== lastItemId);
                    if (reRollPool.length > 0) {
                        finalItemId = reRollPool[s4 % reRollPool.length];
                    }
                    nextSeedIndex = startSeedIndex + 4; // s1, s2, s3, s4
                }
            }
            
            return {
                nextSeedIndex: nextSeedIndex,
                newItemId: finalItemId,
                reRollFlag: reRollFlag,
                address: startSeedIndex
            };
        }
    }
                function createAndDisplayUncompletedSeedView(initialSeed, gacha, tableRows, thresholds, initialLastRollId, displaySeed, params) {
                    const SEED = [initialSeed];
                    // Each row consumes up to 4 seeds for 3 cells, plus G column seeds. Buffer generously.
                    for (let i = 1; i < tableRows * 15 + 20; i++) {
                        SEED[i] = xorshift32(SEED[i - 1]);
                    }
                    const getRarityFromRoll = (roll) => {
                        if (roll < thresholds['0']) return { id: 0, name: 'ノーマル' };
                        if (roll < thresholds['1']) return { id: 1, name: 'レア' };
                        if (roll < thresholds['2']) return { id: 2, name: '激レア' };
                        if (roll < thresholds['3']) return { id: 3, name: '超激レア' };
                        return { id: 4, name: '伝説レア' };
                    };
                    const getAddressString = (n) => {
                        if (n <= 0) return '';
                        const zeroBasedIndex = n - 1;
                        const col_char = String.fromCharCode('A'.charCodeAt(0) + (zeroBasedIndex % 3));
                        const row_num = Math.floor(zeroBasedIndex / 3) + 1;
                        return `${row_num}${col_char}`;
                    };
                    const getAddressStringForG = (n) => {
                        if (n <= 0) return '';
                        const zeroBasedIndex = n - 1;
                        const col_char = String.fromCharCode('A'.charCodeAt(0) + (zeroBasedIndex % 3));
                        const row_num = Math.floor(zeroBasedIndex / 3) + 1;
                        return `${col_char}${row_num}`;
                    };

                    let table = '<table style="table-layout: fixed;"><thead>';
                    let header1 = `<tr><th rowspan="${displaySeed === '1' ? 2 : 1}" id="forceRerollToggle" class="col-no" style="cursor: pointer;">${forceRerollMode ? '☑' : '□'}</th>`;
                    let header2 = '<tr>';
            
                    if (displaySeed === '1') {
                        header1 += '<th colspan="5">A</th><th colspan="5">B</th><th colspan="5">C</th><th colspan="5">G</th>';
                        const subHeaders = ['S1<br>Featured', 'S2<br>Rarity', 'S3<br>Slot', 'S4<br>ReRoll', 'Item<br>Next'];
                        for(let i=0; i<4; i++) header2 += subHeaders.map(h => `<th>${h}</th>`).join('');
                    } else {
                        header1 += '<th>A</th><th>B</th><th>C</th><th>G</th>';
                    }
                    header1 += '</tr>';
                    if (displaySeed === '1') {
                        header2 += '</tr>';
                        table += header1 + header2;
                    } else {
                        table += header1;
                    }
                    table += '</thead><tbody>';
                    
                    let lastItemA = initialLastRollId;
                    let lastItemB = initialLastRollId;
                    let lastItemC = initialLastRollId;
                    let lastGuaranteedItemId = initialLastRollId;

                    let gSeedCounter = 11; // G column seeds start from S11
            
                    for (let r = 0; r < tableRows; r++) {
                        table += `<tr><td class="col-no">${r + 1}</td>`;
                        
                        // Cell A, B, C
                        const cellA = calculateUncompletedCell(r * 3 + 1, lastItemA, gacha, SEED, getRarityFromRoll, getAddressString, forceRerollMode, displaySeed, params);
                        lastItemA = cellA.newItemId; // A列のIDを更新
                        table += cellA.html;
                        const cellB = calculateUncompletedCell(r * 3 + 2, lastItemB, gacha, SEED, getRarityFromRoll, getAddressString, forceRerollMode, displaySeed, params);
                        lastItemB = cellB.newItemId; // B列のIDを更新
                        table += cellB.html;
                        const cellC = calculateUncompletedCell(r * 3 + 3, lastItemC, gacha, SEED, getRarityFromRoll, getAddressString, forceRerollMode, displaySeed, params);
                        lastItemC = cellC.newItemId; // C列のIDを更新
                        table += cellC.html;

                        // G column calculation
                        const rollNumber = r + 1;
                        if (rollNumber > 10) {
                             table += `<td colspan="${displaySeed === '1' ? 5 : 1}"></td>`;
                             table += '</tr>';
                             continue;
                        }
                        
                        const s_feat_idx = rollNumber;
                        const s_feat = SEED[s_feat_idx];
                        const feat_roll = s_feat % 10000;
                        const is_featured = feat_roll < gacha.featuredItemRate;
                        
                        let g_sub5 = '---';
                        let finalItemId;
                        let g_sub1, g_sub2 = '---', g_sub3 = '---', g_sub4 = '---';

                        if (is_featured) {
                            finalItemId = -2;
                            const href = generateItemLink(s_feat, -2); // G列目玉は s_feat が最後のSEED
                            g_sub5 = `<span class="featuredItem-text"><a href="${href}">目玉</a></span>`;
                        } else {
                            const s_rarity_idx = gSeedCounter;
                            const s_slot_idx = gSeedCounter + 1;
                            const s_rarity = SEED[s_rarity_idx];
                            const rarity_roll = s_rarity % 10000;
                            const rarityResult = getRarityFromRoll(rarity_roll);
                            const s_slot = SEED[s_slot_idx];
                            const pool = gacha.rarityItems[rarityResult.id] || [];
                            const poolSize = pool.length;
                            const slot = poolSize > 0 ? s_slot % poolSize : 0;
                            const regularItemId = poolSize > 0 ? pool[slot] : -1;
                            let regularItemName = regularItemId !== -1 ? itemMaster[regularItemId]?.name : '---';
                            finalItemId = regularItemId;
                            
                            const canReRoll = rarityResult.id === 1 && poolSize >= 2;
                            const reRollFlag = canReRoll && regularItemId !== -1 && regularItemId === lastGuaranteedItemId;
                            let reRollItemName = null;
                            let reRollSeed = null;
                            let reRollItemId;


                            if (reRollFlag) {
                                const s_reroll_idx = gSeedCounter + 2;
                                reRollSeed = SEED[s_reroll_idx];
                                const reRollPool = pool.filter(id => id !== lastGuaranteedItemId);
                                const reRollPoolSize = reRollPool.length;
                                if (reRollPoolSize > 0) {
                                    const reRollSlot = reRollSeed % reRollPoolSize;
                                    reRollItemId = reRollPool[reRollSlot];
                                    reRollItemName = reRollItemId !== -1 ? itemMaster[reRollItemId]?.name : '---';
                                    finalItemId = reRollItemId;
                                }
                            }
                            
                            gSeedCounter += 2 + (reRollFlag ? 1 : 0);

                            let styledRegularName = regularItemName;
                            if(regularItemId !== -1) {
                                const href = generateItemLink(s_slot, regularItemId); // G列通常は s_slot が最後のSEED
                                let nameWithLink = `<a href="${href}">${regularItemName}</a>`;
                                if(itemMaster[regularItemId]?.rarity >= 3) {
                                    styledRegularName = `<span class="featuredItem-text">${nameWithLink}</span>`;
                                } else {
                                    styledRegularName = nameWithLink;
                                }
                            }

                            let reRollLine = '';
                            if(reRollItemName) {
                                const href = generateItemLink(reRollSeed, reRollItemId); // G列再抽選は reRollSeed が最後のSEED
                                let styledRerollName = `<a href="${href}">${reRollItemName}</a>`;
                                if (reRollItemId && itemMaster[reRollItemId]?.rarity >= 3) {
                                    styledRerollName = `<span class="featuredItem-text">${styledRerollName}</span>`;
                                }
                                reRollLine = `<br>${styledRerollName}`;
                            }

                            const finalItemNameG = reRollItemName || regularItemName;
                            if (rollNumber < 10) {
                                g_sub5 = styledRegularName + reRollLine;
                            } else {
                                const destinationSeedIndex = is_featured ? (s_feat_idx + 1) : gSeedCounter;
                                const destinationAddress = getAddressStringForG(destinationSeedIndex);
                                const finalItemIdForStyle = Object.keys(itemMaster).find(key => itemMaster[key].name === finalItemNameG);
                                const finalHref = generateItemLink(reRollSeed || s_slot, finalItemIdForStyle);
                                let finalStyledName = `<a href="${finalHref}">${finalItemNameG}</a>`;
                                if(finalItemIdForStyle && itemMaster[finalItemIdForStyle]?.rarity >= 3) {
                                     finalStyledName = `<span class="featuredItem-text">${finalStyledName}</span>`;
                                }
                                g_sub5 = `${destinationAddress})${finalStyledName}`;
                            }

                            if (displaySeed === '1') {
                                g_sub2 = `(S${s_rarity_idx})${s_rarity}<br>${rarity_roll}<br>${rarityResult.name}`;
                                g_sub3 = `(S${s_slot_idx})${s_slot}<br>${poolSize}<br>${slot}`;
                                if (reRollFlag) {
                                    const s_reroll_idx = gSeedCounter - 1;
                                    const s_reroll = SEED[s_reroll_idx];
                                    const reRollPool = pool.filter(id => id !== lastGuaranteedItemId);
                                    g_sub4 = `(S${s_reroll_idx})${s_reroll}<br>${reRollPool.length}<br>${s_reroll % reRollPool.length}`;
                                }
                            }
                        }
                        
                        if (displaySeed === '1') {
                            g_sub1 = `(S${s_feat_idx})${s_feat}<br>${feat_roll}<br>${is_featured}`;
                            table += `<td>${g_sub1}</td><td>${g_sub2}</td><td>${g_sub3}</td><td>${g_sub4}</td><td>${g_sub5}</td>`;
                        } else {
                            table += `<td>${g_sub5}</td>`;
                        }
                        lastGuaranteedItemId = finalItemId;
                        table += '</tr>';
                    }
                    table += '</tbody></table>';
                    document.getElementById('result-table-container').innerHTML = table;
                }    // --- コンプ済みガチャの計算と表示 ---
    function calculateCompletedCell(startSeedIndex, lastItemId, gacha, SEED, getRarityFromRoll, getAddressString, forceRerollMode, displaySeed, params) {
        let finalItemId = -1;
        let html;
        let sub4;

        if (startSeedIndex + 3 >= SEED.length) {
            html = (displaySeed === '1') ? '<td colspan="4"></td>' : '<td></td>';
            return { html, newItemId: -1 };
        }

        const s1 = SEED[startSeedIndex];
        const s2 = SEED[startSeedIndex + 1];
        const s3 = SEED[startSeedIndex + 2];
        const rarityResult = getRarityFromRoll(s1 % 10000);
        const rarityName = rarityResult.name;
        const rarityId = rarityResult.id;
        const pool = gacha.rarityItems[rarityId] || [];
        let regularItemId = -1;
        let regularItemName = '---';
        if (pool.length > 0) {
            const regularSlot = s2 % pool.length;
            regularItemId = pool[regularSlot];
            regularItemName = itemMaster[regularItemId]?.name || '---';
        }
        finalItemId = regularItemId;
        const canReRoll = rarityId === 1 && pool.length >= 2;
        const reRollFlag = canReRoll && regularItemId !== -1 && regularItemId === lastItemId;
        
        let reRollLine = '';
        let reRollItemNameForDisplay = null;
        let reRollItemId;


        if (reRollFlag) {
            const reRollPool = pool.filter(id => id !== lastItemId);
            if (reRollPool.length > 0) {
                reRollItemId = reRollPool[s3 % reRollPool.length];
                reRollItemNameForDisplay = itemMaster[reRollItemId]?.name || '---';
                finalItemId = reRollItemId;
            }
        } else if (forceRerollMode && canReRoll) {
            const reRollPool = pool.filter(id => id !== regularItemId);
            if (reRollPool.length > 0) {
                reRollItemId = reRollPool[s3 % reRollPool.length];
                reRollItemNameForDisplay = itemMaster[reRollItemId]?.name || '---';
            }
        }
        
        let styledRegularName = regularItemName;
        if (regularItemId !== -1) {
            const href = generateItemLink(s2, regularItemId); // 通常(再抽選前)は s2 (S_slot) が最後のSEED
            let nameWithLink = `<a href="${href}">${regularItemName}</a>`;
            if (itemMaster[regularItemId]?.rarity >= 3) {
                styledRegularName = `<span class="featuredItem-text">${nameWithLink}</span>`;
            } else {
                styledRegularName = nameWithLink;
            }
        }
        const regularLine = styledRegularName;

        if (reRollItemNameForDisplay) {
            const href = generateItemLink(s3, reRollItemId); // 再抽選は s3 (S_reroll) が最後のSEED
            let styledRerollName = `<a href="${href}">${reRollItemNameForDisplay}</a>`;
            if (reRollItemId && itemMaster[reRollItemId]?.rarity >= 3) {
                styledRerollName = `<span class="featuredItem-text">${styledRerollName}</span>`;
            }
            reRollLine = `<br>${getAddressString(startSeedIndex + 3)})${styledRerollName}`;
        }

        sub4 = regularLine + reRollLine;

        if (displaySeed === '1') {
            const sub1 = `(S${startSeedIndex})${s1}<br>${s1 % 10000}<br>${rarityName || ''}`;
            const sub2 = pool.length > 0 ? `(S${startSeedIndex + 1})${s2}<br>${pool.length}<br>${s2 % pool.length}` : '---';
            let sub3 = '---';
            if (reRollFlag || (forceRerollMode && canReRoll)) {
                const reRollPool = pool.filter(id => id !== (reRollFlag ? lastItemId : regularItemId));
                if (reRollPool.length > 0) {
                    sub3 = `(S${startSeedIndex + 2})${s3}<br>${reRollPool.length}<br>${s3 % reRollPool.length}`;
                }
            }
            html = `<td>${sub1}</td><td>${sub2}</td><td>${sub3}</td><td>${sub4}</td>`;
        } else {
            html = `<td>${sub4}</td>`;
        }
        return { html, newItemId: finalItemId };
    }
    function calculateGuaranteedCell(startSeedIndex, gacha, SEED, displaySeed, params) {
        if (!gacha.uberGuaranteedFlag && !gacha.legendGuaranteedFlag) {
            return (displaySeed === '1') ? '<td colspan="3"></td>' : '<td></td>';
        }
        const uberRate = gacha.uberGuaranteedFlag ? (gacha.rarityRates['3'] || 0) : 0;
        const legendRate = gacha.legendGuaranteedFlag ? (gacha.rarityRates['4'] || 0) : 0;
        const rarityDivisor = uberRate + legendRate;
        if (rarityDivisor === 0) {
            return (displaySeed === '1') ? '<td colspan="3">レート設定なし</td>' : '<td>レート設定なし</td>';
        }
        const s_rarity_idx = startSeedIndex;
        const s_slot_idx = startSeedIndex + 1;
        if (s_slot_idx >= SEED.length) {
            return (displaySeed === '1') ? '<td colspan="3">---</td>' : '<td>---</td>';
        }
        const s_rarity = SEED[s_rarity_idx];
        const s_slot = SEED[s_slot_idx];
        const rarityRoll = s_rarity % rarityDivisor;
        
        let rarityId, rarityName;
        if (rarityRoll < uberRate) {
            rarityId = '3';
            rarityName = '超激レア';
        } else {
            rarityId = '4';
            rarityName = '伝説レア';
        }
        const pool = gacha.rarityItems[rarityId];
        if (!pool || pool.length === 0) {
            const msg = `${rarityName}プールなし`;
            return (displaySeed === '1') ? `<td colspan="3">${msg}</td>` : `<td>${msg}</td>`;
        }
        const poolSize = pool.length;
        const slot = s_slot % poolSize;
        const itemId = pool[slot];
        
        let itemName = itemMaster[itemId]?.name || '---';
        if (itemId !== -1) {
            const href = generateItemLink(s_slot, itemId); // 確定枠は s_slot が最後のSEED
            itemName = `<a href="${href}">${itemName}</a>`; // Always link, but no special styling
        }

        if (displaySeed === '0') {
            return `<td>${itemName}</td>`;
        }

        const col1 = `(S${s_rarity_idx})${s_rarity}<br>${rarityRoll}<br>${rarityName}`;
        const col2 = `(S${s_slot_idx})${s_slot}<br>${poolSize}<br>${slot}`;
        const col3 = itemName;
        return `<td>${col1}</td><td>${col2}</td><td>${col3}</td>`;
    }
    // --- ▼ 修正 (5): ハイライトロジックの組み込み (デュアルハイライト対応) ▼ ---
    function createAndDisplayCompletedSeedView(initialSeed, gacha, tableRows, thresholds, initialLastRollId, displaySeed, params) {
        const SEED = [initialSeed];
        for (let i = 1; i < tableRows * 2 * 3 + 20; i++) {
            SEED[i] = xorshift32(SEED[i - 1]);
        }
        const getRarityFromRoll = (roll) => {
            if (roll < thresholds['0']) return { id: 0, name: 'ノーマル' };
            if (roll < thresholds['1']) return { id: 1, name: 'レア' };
            if (roll < thresholds['2']) return { id: 2, name: '激レア' };
            if (roll < thresholds['3']) return { id: 3, name: '超激レア' };
            return { id: 4, name: '伝説レア' };
        };
        const getAddressString = (n) => {
            if (n <= 0) return '';
            const zeroBasedIndex = n - 1;
            const col_char = String.fromCharCode('A'.charCodeAt(0) + (zeroBasedIndex % 2));
            const row_num = Math.floor(zeroBasedIndex / 2) + 1;
            return `${row_num}${col_char}`;
        };

        // --- ▼ 新しいハイライトパス計算ロジック ▼ ---

        function calculateGuaranteedRoll(startSeedIndex, gacha, SEED) {
            if (!gacha.uberGuaranteedFlag && !gacha.legendGuaranteedFlag) {
                return { newItemId: -1, nextSeedIndex: startSeedIndex + 2 };
            }
            const uberRate = gacha.uberGuaranteedFlag ? (gacha.rarityRates['3'] || 0) : 0;
            const legendRate = gacha.legendGuaranteedFlag ? (gacha.rarityRates['4'] || 0) : 0;
            const rarityDivisor = uberRate + legendRate;
            if (rarityDivisor === 0 || startSeedIndex + 1 >= SEED.length) {
                return { newItemId: -1, nextSeedIndex: startSeedIndex + 2 };
            }
            const s_rarity = SEED[startSeedIndex];
            const s_slot = SEED[startSeedIndex + 1];
            const rarityRoll = s_rarity % rarityDivisor;
            const rarityId = (rarityRoll < uberRate) ? '3' : '4';
            const pool = gacha.rarityItems[rarityId];
            if (!pool || pool.length === 0) {
                return { newItemId: -1, nextSeedIndex: startSeedIndex + 2 };
            }
            const slot = s_slot % pool.length;
            const itemId = pool[slot];
            return { newItemId: itemId, nextSeedIndex: startSeedIndex + 2 };
        }

        const nextGuaranteed = parseInt(document.getElementById('guaranteedRollsInput').value, 10);
        const hasGuaranteed = !isNaN(nextGuaranteed);
        
        const singleRollMap = new Map();
        const tenPullRollMap = new Map();
        const MAX_ROLLS = tableRows * 2;

        // 1. 単発ロールパス
        let currentSeedIndexSingle = 1;
        let currentLastItemIdSingle = initialLastRollId;
        let previousRollWasGuaranteedSingle = false;
        for (let i = 1; i <= MAX_ROLLS; i++) {
            if (currentSeedIndexSingle >= SEED.length) break;
            const isGuaranteedRoll = hasGuaranteed && i >= nextGuaranteed && (i - nextGuaranteed) % 10 === 0;
            if (isGuaranteedRoll) {
                singleRollMap.set(currentSeedIndexSingle, i);
                const rollData = calculateGuaranteedRoll(currentSeedIndexSingle, gacha, SEED);
                currentSeedIndexSingle = rollData.nextSeedIndex;
                currentLastItemIdSingle = rollData.newItemId;
                previousRollWasGuaranteedSingle = true;
            } else {
                const lastItemIdForCheck = previousRollWasGuaranteedSingle ? null : currentLastItemIdSingle;
                const rollData = calculateCompletedRoll(currentSeedIndexSingle, lastItemIdForCheck, SEED, gacha, getRarityFromRoll);
                singleRollMap.set(rollData.address, i);
                currentSeedIndexSingle = rollData.nextSeedIndex;
                currentLastItemIdSingle = rollData.newItemId;
                previousRollWasGuaranteedSingle = false;
            }
        }

        // 2. 10連ロールパス (シーケンシャルモデル + 周期判定)
        if (hasGuaranteed) {
            function calculateGuaranteedRollFor10Pull(slotSeedIndex, guaranteedRarityId, SEED, gacha) {
                const pool = gacha.rarityItems[guaranteedRarityId] || [];
                if (!pool || pool.length === 0 || slotSeedIndex >= SEED.length) {
                    return { newItemId: -1, nextSeedIndex: slotSeedIndex + 1 };
                }
                const s_slot = SEED[slotSeedIndex];
                const slot = s_slot % pool.length;
                const itemId = pool[slot];
                return { newItemId: itemId, nextSeedIndex: slotSeedIndex + 1 };
            }

            let seed_counter = 1; // S1から開始
            let currentLastItemId10 = initialLastRollId;
            let guaranteedRarityId = '3'; // 周期ごとに更新される
            let previousRollWasGuaranteed10 = false;

            for (let i = 1; i <= MAX_ROLLS; i++) {
                if (seed_counter >= SEED.length) break;

                if ((i - 1) % 10 === 0) {
                    const raritySeedIndex = seed_counter;
                    const uberRate = gacha.uberGuaranteedFlag ? (gacha.rarityRates['3'] || 0) : 0;
                    const legendRate = gacha.legendGuaranteedFlag ? (gacha.rarityRates['4'] || 0) : 0;
                    const rarityDivisor = uberRate + legendRate;
                    if (rarityDivisor > 0 && raritySeedIndex < SEED.length) {
                        const rarityRoll_g = SEED[raritySeedIndex] % rarityDivisor;
                        if (rarityRoll_g >= uberRate) guaranteedRarityId = '4';
                    }
                    seed_counter++;
                }

                const isGuaranteedRoll = (i >= nextGuaranteed) && ((i - nextGuaranteed) % 10 === 0);

                if (isGuaranteedRoll) {
                    const mapIndex = seed_counter - 1;
                    const rollData = calculateGuaranteedRollFor10Pull(seed_counter, guaranteedRarityId, SEED, gacha);
                    tenPullRollMap.set(mapIndex, i);
                    seed_counter = rollData.nextSeedIndex;
                    currentLastItemId10 = rollData.newItemId;
                    previousRollWasGuaranteed10 = true;
                } else {
                    const lastItemIdForCheck = previousRollWasGuaranteed10 ? null : currentLastItemId10;
                    const rollData = calculateCompletedRoll(seed_counter, lastItemIdForCheck, SEED, gacha, getRarityFromRoll);
                    tenPullRollMap.set(rollData.address, i);
                    seed_counter = rollData.nextSeedIndex;
                    currentLastItemId10 = rollData.newItemId;
                    previousRollWasGuaranteed10 = false;
                }
            }
        }
        // --- ▲ 新しいハイライトパス計算ロジック 完了 ▲ ---

        let table = '<table style="table-layout: fixed;"><thead>';
        let header1 = `<tr><th rowspan="${displaySeed === '1' ? 2 : 1}" id="forceRerollToggle" class="col-no" style="cursor: pointer;">${forceRerollMode ? '☑' : '□'}</th>`;
        let header2 = '<tr>';

        if (displaySeed === '1') {
            header1 += '<th colspan="4">A</th><th colspan="3">AG</th><th colspan="4">B</th><th colspan="3">BG</th>';
            const subHeadersA = ['S1<br>Rarity', 'S2<br>Slot', 'S3<br>ReRoll', 'Item<br>Next'];
            const subHeadersAG = ['S1<br>Guaranteed', 'S2<br>Slot', 'Item'];
            header2 += subHeadersA.map(h => `<th>${h}</th>`).join('');
            header2 += subHeadersAG.map(h => `<th>${h}</th>`).join('');
            header2 += subHeadersA.map(h => `<th>${h}</th>`).join('');
            header2 += subHeadersAG.map(h => `<th>${h}</th>`).join('');
        } else {
            header1 += '<th>A</th><th>AG</th><th>B</th><th>BG</th>';
        }
        header1 += '</tr>';
        if (displaySeed === '1') {
            header2 += '</tr>';
            table += header1 + header2;
        } else {
            table += header1;
        }
        table += '</thead><tbody>';
        
        let lastItemA = initialLastRollId;
        let lastItemB = initialLastRollId;

        for (let r = 0; r < tableRows; r++) {
            const seedIndexA = r * 2 + 1;
            const seedIndexB = r * 2 + 2;
            
            let classA = '', classAG = '', classB = '', classBG = '';

            // A列のハイライトクラス決定
            const roll_A_single = singleRollMap.get(seedIndexA);
            const roll_A_10pull = tenPullRollMap.get(seedIndexA);
            const isGuaranteed_A_single = hasGuaranteed && roll_A_single >= nextGuaranteed && (roll_A_single - nextGuaranteed) % 10 === 0;
            const isGuaranteed_A_10pull = hasGuaranteed && roll_A_10pull >= nextGuaranteed && (roll_A_10pull - nextGuaranteed) % 10 === 0;

            if (roll_A_single && roll_A_10pull) { // 共通ルート
                const is10th_single = roll_A_single % 10 === 0;
                const is10th_10pull = roll_A_10pull % 10 === 0;
                let overlap_class = 'highlight-roll-overlap'; // 通常の共通ルート色
                if (is10th_10pull) {
                    overlap_class = 'highlight-roll-10pull-10'; // 10連ルートの10n回目なら濃い黄色
                } else if (is10th_single) {
                    overlap_class = 'highlight-roll-10'; // 単発ルートの10n回目なら濃い緑色
                }
                
                if (isGuaranteed_A_single || isGuaranteed_A_10pull) {
                    classAG = overlap_class;
                } else {
                    classA = overlap_class;
                }
            } else if (roll_A_single) { // 単発ルートのみ
                if (isGuaranteed_A_single) {
                    classAG = (roll_A_single % 10 === 0) ? 'highlight-roll-10' : 'highlight-roll';
                } else {
                    classA = (roll_A_single % 10 === 0) ? 'highlight-roll-10' : 'highlight-roll';
                }
            } else if (roll_A_10pull) { // 10連ルートのみ
                if (isGuaranteed_A_10pull) {
                    classAG = (roll_A_10pull % 10 === 0) ? 'highlight-roll-10pull-10' : 'highlight-roll-10pull';
                } else {
                    classA = (roll_A_10pull % 10 === 0) ? 'highlight-roll-10pull-10' : 'highlight-roll-10pull';
                }
            }

            // B列のハイライトクラス決定
            const roll_B_single = singleRollMap.get(seedIndexB);
            const roll_B_10pull = tenPullRollMap.get(seedIndexB);
            const isGuaranteed_B_single = hasGuaranteed && roll_B_single >= nextGuaranteed && (roll_B_single - nextGuaranteed) % 10 === 0;
            const isGuaranteed_B_10pull = hasGuaranteed && roll_B_10pull >= nextGuaranteed && (roll_B_10pull - nextGuaranteed) % 10 === 0;

            if (roll_B_single && roll_B_10pull) { // 共通ルート
                const is10th_single = roll_B_single % 10 === 0;
                const is10th_10pull = roll_B_10pull % 10 === 0;
                let overlap_class = 'highlight-roll-overlap'; // 通常の共通ルート色
                if (is10th_10pull) {
                    overlap_class = 'highlight-roll-10pull-10'; // 10連ルートの10n回目なら濃い黄色
                } else if (is10th_single) {
                    overlap_class = 'highlight-roll-10'; // 単発ルートの10n回目なら濃い緑色
                }

                if (isGuaranteed_B_single || isGuaranteed_B_10pull) {
                    classBG = overlap_class;
                } else {
                    classB = overlap_class;
                }
            } else if (roll_B_single) { // 単発ルートのみ
                if (isGuaranteed_B_single) {
                    classBG = (roll_B_single % 10 === 0) ? 'highlight-roll-10' : 'highlight-roll';
                } else {
                    classB = (roll_B_single % 10 === 0) ? 'highlight-roll-10' : 'highlight-roll';
                }
            } else if (roll_B_10pull) { // 10連ルートのみ
                if (isGuaranteed_B_10pull) {
                    classBG = (roll_B_10pull % 10 === 0) ? 'highlight-roll-10pull-10' : 'highlight-roll-10pull';
                } else {
                    classB = (roll_B_10pull % 10 === 0) ? 'highlight-roll-10pull-10' : 'highlight-roll-10pull';
                }
            }

            table += `<tr><td class="col-no">${r + 1}</td>`;
            
            const cellA = calculateCompletedCell(seedIndexA, lastItemA, gacha, SEED, getRarityFromRoll, getAddressString, forceRerollMode, displaySeed, params);
            lastItemA = cellA.newItemId;
            table += addClassToCell(cellA.html, classA);
            table += addClassToCell(calculateGuaranteedCell(seedIndexA, gacha, SEED, displaySeed, params), classAG);
            
            const cellB = calculateCompletedCell(seedIndexB, lastItemB, gacha, SEED, getRarityFromRoll, getAddressString, forceRerollMode, displaySeed, params);
            lastItemB = cellB.newItemId;
            table += addClassToCell(cellB.html, classB);
            table += addClassToCell(calculateGuaranteedCell(seedIndexB, gacha, SEED, displaySeed, params), classBG);
            
            table += '</tr>';
        }
        table += '</tbody></table>';
        document.getElementById('result-table-container').innerHTML = table;
    }
    // --- ▲ 修正 (5) 完了 ▲ ---
    // --- ディスパッチャー ---
    function createAndDisplaySeedViewNew(initialSeed, gacha, tableRows, isFeaturedComplete, thresholds, initialLastRollId, displaySeed, params) {
        if (isFeaturedComplete) {
            createAndDisplayCompletedSeedView(initialSeed, gacha, tableRows, thresholds, initialLastRollId, displaySeed, params);
        } else {
            createAndDisplayUncompletedSeedView(initialSeed, gacha, tableRows, thresholds, initialLastRollId, displaySeed, params);
        }
    }
    // --- メイン関数 ---
    let activeGachaId;
    function runSimulationAndDisplay(options = {}) {
        const { hideSeedInput = false, uiOverrides = {} } = options;
        const params = new URLSearchParams(window.location.search);
        const urlSeed = params.get('seed');
        const urlGuaranteed = params.get('ng');
        const urlFeaturedStock = params.get('fs');
        const urlLastRoll = params.get('lr');
        const urlComp = params.get('comp');
        const gachaIds = Object.keys(gachaMaster);
        const latestGachaId = gachaIds.reduce((a, b) => parseInt(a) > parseInt(b) ? a : b);
        const urlGachaId = params.get('gacha') || latestGachaId;
        activeGachaId = urlGachaId;
        const urlTx = params.get('tx');
        const urlRoll = params.get('roll');
        const urlDisplaySeed = params.get('displaySeed');

        const seedValueStr = uiOverrides.seed !== undefined ? uiOverrides.seed : (urlSeed || document.getElementById('seedInput').value);
        let isFeaturedComplete = uiOverrides.isComplete !== undefined ? uiOverrides.isComplete : (urlComp === 'true');
        const displaySeedValue = uiOverrides.displaySeed !== undefined ? uiOverrides.displaySeed : (urlDisplaySeed || '0');

        document.getElementById('seedInput').value = seedValueStr;
        document.getElementById('featuredCompleteCheckbox').checked = isFeaturedComplete;
        const seedValue = parseInt(seedValueStr, 10);
        let lastRollItemId = urlLastRoll ? parseInt(urlLastRoll, 10) : null;
        if (isNaN(seedValue)) {
            document.getElementById('output').textContent = '有効な数値を入力してください。';
            return;
        }
        const gacha = gachaMaster[urlGachaId];
        if (!gacha) {
            document.getElementById('output').textContent = '無効なガチャIDです。';
            return;
        }
        const featuredCompleteControl = document.getElementById('featuredCompleteCheckbox').parentElement;
        if (gacha.featuredItemStock === 0) {
            isFeaturedComplete = true;
            document.getElementById('featuredCompleteCheckbox').checked = true;
            featuredCompleteControl.classList.add('hidden-control');
        } else {
            featuredCompleteControl.classList.remove('hidden-control');
        }
        const rates = gacha.rarityRates;
        const thresholds = {
            '0': rates['0'], '1': rates['0'] + rates['1'], '2': rates['0'] + rates['1'] + rates['2'],
            '3': rates['0'] + rates['1'] + rates['2'] + rates['3'], '4': 10000
        };
        const tableRows = parseInt(urlRoll, 10) || 100;
        
        createAndDisplaySeedViewNew(seedValue, gacha, tableRows, isFeaturedComplete, thresholds, lastRollItemId, displaySeedValue, params);
        
        updateUIAndURL(options);
    }
    // --- UI更新とイベントリスナー ---
    function updateUIAndURL(options = {}) {
        const { hideSeedInput = false, uiOverrides = {} } = options;
        const params = new URLSearchParams(window.location.search);
        const gachaIds = Object.keys(gachaMaster);
        const latestGachaId = gachaIds.reduce((a, b) => parseInt(a) > parseInt(b) ? a : b);
        const urlGachaId = params.get('gacha') || latestGachaId;
        const gacha = gachaMaster[urlGachaId];
        
        // --- ▼ 修正 (6): 'ng' の値が 'none' でも URL に反映されるように uiOverrides を考慮 ▼ ---
        const currentNG = document.getElementById('guaranteedRollsInput').value;
        const newNG = uiOverrides.guaranteedRolls !== undefined ? uiOverrides.guaranteedRolls : currentNG;
        
        const newUrlQuery = generateUrlQuery({
            gachaId: urlGachaId,
            seed: document.getElementById('seedInput').value,
            ng: newNG, // 修正
            fs: uiOverrides.featuredStock !== undefined ? uiOverrides.featuredStock : document.getElementById('featuredStockInput').value, // 修正
            lr: params.get('lr'),
            comp: document.getElementById('featuredCompleteCheckbox').checked,
            tx: params.get('tx') && !hideSeedInput ? '1' : undefined,
            roll: params.get('roll') || 100,
            displaySeed: params.get('displaySeed')
        });
        // --- ▲ 修正 (6) 完了 ▲ ---
        
        window.history.replaceState({ path: newUrlQuery }, '', `${window.location.pathname}${newUrlQuery}`);
        const seedRow = document.getElementById('seedRow');
        const seedLinkContainer = document.getElementById('seedLinkContainer');
        const showSeedInputLink = document.getElementById('showSeedInputLink');
        const stockControl = document.getElementById('stockControl');
        const guaranteedControl = document.getElementById('guaranteedControl');
        const legendDisplay = document.getElementById('legendDisplay'); // Get legend element
        
        const linkParams = Object.fromEntries(params.entries());
        linkParams.gacha = urlGachaId;
        linkParams.tx = '1';
        showSeedInputLink.href = generateUrlQuery(linkParams);

        if (params.get('tx') && !hideSeedInput) {
            seedRow.classList.remove('hidden-control');
            seedLinkContainer.classList.add('hidden-control');
        } else {
            seedRow.classList.add('hidden-control');
            seedLinkContainer.classList.remove('hidden-control');
        }
        const isFeaturedComplete = document.getElementById('featuredCompleteCheckbox').checked;
        
        populateFeaturedStockInput(urlGachaId, params.get('fs') || 'none'); // 'none' を明示

        if (isFeaturedComplete) {
            stockControl.classList.add('hidden-control');
            if (gacha.uberGuaranteedFlag || gacha.legendGuaranteedFlag) {
                guaranteedControl.classList.remove('hidden-control');
                legendDisplay.classList.remove('hidden-control'); // Show legend
                populateGuaranteedRolls(10, newNG); // 修正
            } else {
                guaranteedControl.classList.add('hidden-control');
                legendDisplay.classList.add('hidden-control'); // Hide legend
            }
        } else {
            stockControl.classList.remove('hidden-control');
            guaranteedControl.classList.remove('hidden-control');
            legendDisplay.classList.remove('hidden-control'); // Show legend
            populateGuaranteedRolls(gacha.guaranteedCycle || 30, newNG); // 修正
        }
        const lastRollDisplay = document.getElementById('lastRollDisplay');
        const lr = params.get('lr');
        if (lr && itemMaster[lr]) {
            lastRollDisplay.textContent = `LastRoll: ${itemMaster[lr].name}`;
        } else {
            lastRollDisplay.textContent = '';
        }
    }
    function generateUrlQuery(params) {
        // --- ▼ 修正 (2): gachaId と gacha の両方に対応 ▼ ---
        let query = `?gacha=${params.gachaId || params.gacha}`;
        // --- ▲ 修正 (2) 完了 ▲ ---
        if (params.seed !== undefined) query += `&seed=${params.seed}`;
        if (params.ng !== undefined && params.ng !== 'none') query += `&ng=${params.ng}`;
        if (params.fs !== undefined && params.fs !== 'none' && params.fs !== Infinity) query += `&fs=${params.fs}`;
        if (params.lr !== undefined && params.lr !== null) query += `&lr=${params.lr}`;
        if (params.comp) query += `&comp=true`;
        if (params.tx) query += `&tx=${params.tx}`;
        if (params.roll !== undefined && params.roll !== 100) query += `&roll=${params.roll}`;
        if (params.displaySeed !== undefined && params.displaySeed !== '0') query += `&displaySeed=${params.displaySeed}`;
        return query;
    }

    function generateItemLink(newSeed, newItemId) {
        const currentParams = new URLSearchParams(window.location.search);
        const paramsForQuery = {};
        // Inherit from URL
        for (const [key, value] of currentParams.entries()) {
            if (key === 'gacha') {
                paramsForQuery.gachaId = value;
            } else {
                paramsForQuery[key] = value;
            }
        }

        // If gacha is not in the URL, use the active one.
        if (!paramsForQuery.gachaId) {
            paramsForQuery.gachaId = activeGachaId;
        }

        // Override with new values for the link
        paramsForQuery.seed = newSeed;
        // Only set 'lr' if we have a new item ID. Otherwise, keep the one from the URL.
        if (newItemId !== undefined) {
            paramsForQuery.lr = newItemId;
        }

        // Call the existing centralized query builder
        return generateUrlQuery(paramsForQuery);
    }

    function populateGuaranteedRolls(max, currentVal) {
        const input = document.getElementById('guaranteedRollsInput');
        input.innerHTML = '';
        const unsetOption = document.createElement('option');
        unsetOption.value = 'none'; unsetOption.textContent = '未設定'; input.appendChild(unsetOption);
        for (let i = 1; i <= max; i++) {
            const option = document.createElement('option'); option.value = i; option.textContent = i; input.appendChild(option);
        }
        if (input.querySelector(`option[value="${currentVal}"]`)) {
            input.value = currentVal;
        } else {
            input.value = 'none';
        }
    }
    function populateFeaturedStockInput(gachaId, preferredValue = 'none') {
        const gacha = gachaMaster[gachaId];
        const input = document.getElementById('featuredStockInput');
        if (!gacha) return;
        input.innerHTML = '';
        const unsetOption = document.createElement('option');
        unsetOption.value = 'none'; unsetOption.textContent = '-'; input.appendChild(unsetOption);
        for (let i = 1; i <= gacha.featuredItemStock; i++) {
            const option = document.createElement('option'); option.value = i; option.textContent = i; input.appendChild(option);
        }
        if (preferredValue && preferredValue !== 'none' && input.querySelector(`option[value="${preferredValue}"]`)) {
            input.value = preferredValue;
        } else {
            input.value = 'none';
        }
    }
    let forceRerollMode = false;
    // --- 初期化とイベントリスナー設定 ---
    document.addEventListener('DOMContentLoaded', () => {
        setupGachaRarityItems();
        document.getElementById('executeButton').addEventListener('click', () => runSimulationAndDisplay({ hideSeedInput: true, uiOverrides: { seed: document.getElementById('seedInput').value } }));
        // --- ▼ 修正 (7): 'ng' の値が 'none' でも runSimulationAndDisplay が呼ばれるように修正 ▼ ---
        document.getElementById('guaranteedRollsInput').addEventListener('change', (e) => runSimulationAndDisplay({ uiOverrides: { guaranteedRolls: e.target.value } }));
        document.getElementById('featuredStockInput').addEventListener('change', (e) => runSimulationAndDisplay({ uiOverrides: { featuredStock: e.target.value } }));
        // --- ▲ 修正 (7) 完了 ▲ ---
        document.getElementById('featuredCompleteCheckbox').addEventListener('change', () => runSimulationAndDisplay({ uiOverrides: { isComplete: document.getElementById('featuredCompleteCheckbox').checked } }));
        document.getElementById('copySeedLink').addEventListener('click', (event) => {
            event.preventDefault();
            const seedToCopy = new URLSearchParams(window.location.search).get('seed');
            if (seedToCopy && navigator.clipboard) {
                navigator.clipboard.writeText(seedToCopy).then(() => {
                    const originalText = event.target.textContent;
                    event.target.textContent = 'Copied!';
                    setTimeout(() => { event.target.textContent = originalText; }, 1500);
                });
            }
        });
        document.getElementById('result-table-container').addEventListener('click', (event) => {
            if (event.target.id === 'forceRerollToggle') {
                forceRerollMode = !forceRerollMode;
                // The text content will be updated by the function that re-renders the table
                runSimulationAndDisplay();
            }
        });
        runSimulationAndDisplay();
    });
</script>
</body>
</html>