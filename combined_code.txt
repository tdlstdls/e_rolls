====================
FILE: index.html
====================
<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>イベントガチャロールズ</title>
    <link rel="stylesheet" href="style.css">
    <link rel="icon" href="data:,">
</head>
<body>

<div class="container">
    <h1>イベントガチャロールズ</h1>
    <div class="input-group">
        <div class="controls">
            <div class="row">
                <div class="control-group-left">
                    <div class="input-item">
                         <a id="showSeedInputLink" href="#">SEED入力</a>
                    </div>
                    <div class="input-item" id="guaranteedControl">
                        <label for="guaranteedRollsInput">next guaranteed</label>
                        <select id="guaranteedRollsInput"></select>
                    </div>
                    <div class="input-item" id="legendDisplay" style="font-size: 0.7rem;">
                        <span id="legendSingle" class="legend-box legend-single">単発ルート</span>
                        <span id="legendMulti" class="legend-box legend-multi">10連ルート</span>
                        <span id="legendCommon" class="legend-box legend-common">共通ルート</span>
                    </div>
                    <div id="lastRollDisplay" class="input-item-display-only"></div>
                </div>
                <div class="control-group-right">
                    <div class="input-item">
                        <label for="featuredCompleteCheckbox">コンプ済み</label>
                        <input type="checkbox" id="featuredCompleteCheckbox">
                    </div>
                    <div class="input-item" id="stockControl">
                        <label for="featuredStockInput">目玉残数</label>
                        <select id="featuredStockInput"></select>
                    </div>
                    <a id="copySeedLink" href="#">Copy SEED</a>
                </div>
            </div>

            <div class="row hidden-control" id="seedRow">
                <div class="input-item-seed">
                    <label for="seedInput">SEED</label>
                    <div class="seed-input-group">
                        <input type="number" id="seedInput" value="12345">
                        <button id="executeButton">更新</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="result-container">
        <div id="output"></div>
        <div id="result-table-container"></div>

        <div id="toggle-buttons-container" class="row" style="margin-top: 10px; justify-content: flex-start; gap: 10px;">
            <button id="toggleSeedBtn">SEEDを表示</button>
            <button id="toggleSimBtn">シミュレーションを表示</button>
       </div>

        <div id="sim-ui-container" style="display: none; margin-bottom: 15px;"></div>
        <div id="calculation-details" style="display:none;"></div>
    </div>
</div>

<div id="seed-popup-overlay" class="popup-overlay">
    <div class="popup-modal">
        <span class="popup-close-btn">&times;</span>
        <div id="popup-content"></div>
        <div style="margin-top: 15px; text-align: right;">
            <button id="copy-popup-content-btn">内容をコピー</button>
        </div>
    </div>
</div>

<script src="master.js"></script>
<script src="utils.js"></script>
<script src="logic-common.js"></script>
<script src="logic-completed-helpers.js"></script>
<script src="logic-completed-popup.js"></script>
<script src="logic-completed-search.js"></script>
<script src="logic-completed-highlight.js"></script>
<script src="logic-completed.js"></script>
<script src="logic-uncompleted-sim.js"></script>
<script src="logic-uncompleted.js"></script>
<script src="view-completed.js"></script>
<script src="view-uncompleted-details.js"></script>
<script src="view-uncompleted-table.js"></script>
<script src="view-uncompleted.js"></script>
<script src="view-simulation.js"></script>
<script src="main.js"></script>

</body>
</html>

====================
FILE: logic-common.js
====================
/**
 * 担当: シード配列生成、レアリティ判定、アドレス計算等の共通計算ロジック
 * 依存関係: utils.js (getItemNameSafe等の利用)
 */

// --- 共通ロジック ---

/**
 * シード配列を一括生成する
 */
function generateSeedList(initialSeed, count) {
    const seeds = [initialSeed];
    for (let i = 1; i < count; i++) {
        seeds[i] = xorshift32(seeds[i - 1]);
    }
    return seeds;
}

/**
 * ロール値と閾値からレアリティ情報を取得する
 */
function getRarityFromRoll(roll, thresholds) {
    if (roll < thresholds['0']) return { id: 0, name: 'ノーマル' };
    if (roll < thresholds['1']) return { id: 1, name: 'レア' };
    if (roll < thresholds['2']) return { id: 2, name: '激レア' };
    if (roll < thresholds['3']) return { id: 3, name: '超激レア' };
    return { id: 4, name: '伝説レア' };
}

/**
 * アドレス文字列 (1A, 1B, 2A...) を生成する
 * cols: 列数 (completed=2, uncompleted=3)
 */
function getAddressStringGeneric(n, cols) {
    if (n <= 0) return '';
    const zeroBasedIndex = n - 1;
    const col_char = String.fromCharCode('A'.charCodeAt(0) + (zeroBasedIndex % cols));
    const row_num = Math.floor(zeroBasedIndex / cols) + 1;
    return `${row_num}${col_char}`;
}

/**
 * アイテム名を取得する安全なヘルパー
 */
function getItemNameSafe(itemId) {
    if (itemId === -1 || itemId === undefined) return '---';
    return itemMaster[itemId]?.name || '---';
}

/**
 * ハイライトクラス判定ロジック
 */
function determineHighlightClass(info) {
    if (!info) return '';
    let cls = '';
    const isSingle10 = info.single && (info.singleRoll % 10 === 0);
    const isTen10 = info.ten && (info.tenRoll % 10 === 0);
    
    if (info.single && info.ten) {
        cls = (isSingle10 || isTen10) ? 'highlight-roll-overlap-dark' : 'highlight-roll-overlap';
    } else if (info.single) {
        cls = isSingle10 ? 'highlight-roll-dark' : 'highlight-roll';
    } else if (info.ten) {
        cls = isTen10 ? 'highlight-roll-10pull-dark' : 'highlight-roll-10pull';
    }
    return cls;
}

====================
FILE: logic-completed-helpers.js
====================
/**
 * 担当: コンプ済みデータの基本計算ロジック、単発/10連ルートの詳細シミュレーション
 * 特殊仕様: 10連ルートの確定枠レアリティ判定(サイクル先頭)とスロット判定(到達時点)を分離
 */

// =================================================================================
// ヘルパー関数: ノード初期化
// =================================================================================

function initializeNodes(SEED_LIST, maxNodeIndex, gacha, thresholds) {
    const Nodes = [];
    const getAddress = (n) => getAddressStringGeneric(n, 2);
    const uFlag = gacha.uberGuaranteedFlag;
    const lFlag = gacha.legendGuaranteedFlag;
    const uRate = uFlag ? (gacha.rarityRates['3'] || 500) : 0;
    const lRate = lFlag ? (gacha.rarityRates['4'] || 200) : 0;
    const gDivisor = uRate + lRate;

    for (let i = 1; i <= maxNodeIndex; i++) {
        const node = {
            index: i,
            address: getAddress(i),
            seed1: SEED_LIST[i],
            seed2: SEED_LIST[i + 1],
            seed3: SEED_LIST[i + 2],
            seed4: SEED_LIST[i + 3],
            prevSeed1: SEED_LIST[i - 1]
        };
        // 通常枠計算
        node.roll1 = node.seed1 % 10000;
        node.rarityId = getRarityFromRoll(node.roll1, thresholds).id;
        const pool = gacha.rarityItems[node.rarityId] || [];
        node.poolSize = pool.length;
        if (pool.length > 0) {
            node.slot = node.seed2 % pool.length;
            node.itemId = pool[node.slot];
            node.itemName = getItemNameSafe(node.itemId);
        } else {
            node.itemId = -1;
            node.itemName = '---';
        }
        // 確定枠基本計算 (通常時/単発用)
        node.gDivisor = gDivisor;
        if (gDivisor > 0) {
            node.gRoll = node.seed1 % gDivisor;
            node.rarityGId = (node.gRoll < uRate) ? '3' : '4';
            node.rarityGName = (node.rarityGId === '3') ? '超激レア' : '伝説レア';
            const poolG = gacha.rarityItems[node.rarityGId] || [];
            node.poolGSize = poolG.length;
            node.slotG = node.seed2 % Math.max(1, poolG.length); 
            node.itemGId = poolG[node.slotG];
            node.itemGName = getItemNameSafe(node.itemGId);
        }
        Nodes.push(node);
    }
    return Nodes;
}

/**
 * 基本的なレア被り判定
 */
function calculateRerolls(Nodes, initialLastRollId, gacha) {
    Nodes.forEach((node, i) => {
        const prevNode2 = (i >= 2) ? Nodes[i - 2] : null;
        const prevId2 = prevNode2 ? prevNode2.itemId : (initialLastRollId || -1);
        node.reRollFlag = (node.rarityId === 1 && node.poolSize > 1 && node.itemId === prevId2);
        
        const prevNode3 = (i >= 3) ? Nodes[i - 3] : null;
        const prevRerollId3 = (prevNode3 && (prevNode3.reRollFlag || prevNode3.reRerollFlag)) ? prevNode3.reRollItemId : -1;
        node.reRerollFlag = (node.rarityId === 1 && node.itemId === prevRerollId3);

        if (node.reRollFlag || node.reRerollFlag) {
            const rrPool = (gacha.rarityItems[1] || []).filter(id => id !== node.itemId);
            if (rrPool.length > 0) {
                node.reRollSlot = node.seed3 % rrPool.length;
                node.reRollItemId = rrPool[node.reRollSlot];
                node.reRollItemName = getItemNameSafe(node.reRollItemId);
            }
        }
    });
}

// =================================================================================
// 内部パス計算: 単発ルート
// =================================================================================

function calculateSingleRollRoute(Nodes, tableRows, initialNg, initialLastRollId, gacha, thresholds, SEED_LIST) {
    const singleRouteText = [];
    const rarityNames = ["ノーマル", "レア", "激レア", "超激レア", "伝説レア"];
    const gCycle = gacha.guaranteedCycle || 30;
    let sIdx = 1, sRoll = 1, sNgTracker = parseInt(initialNg, 10), sLastId = initialLastRollId;

    while (sIdx <= Nodes.length && sRoll <= tableRows) {
        const node = Nodes[sIdx - 1];
        const isG = (sNgTracker === 1);
        
        let block = `<strong>Roll ${sRoll}${isG ? '[Guar]' : ''}</strong><br>`;
        
        if (isG) {
            block += `確定枠: Seed[${sIdx}] ${node.seed1} % ${node.gDivisor} → ${node.rarityGName}<br>`;
            block += `アイテム: ${node.itemGName}<br>`;
            sLastId = node.itemGId;
            sIdx += 2;
            sNgTracker = gCycle;
        } else {
            const isMatch = (node.itemId === sLastId);
            const isRR = (node.rarityId === 1 && node.poolSize > 1 && isMatch) || node.reRerollFlag;
            block += `通常: ${rarityNames[node.rarityId]} → ${isRR ? node.reRollItemName : node.itemName}<br>`;
            sLastId = isRR ? node.reRollItemId : node.itemId;
            sIdx += isRR ? 3 : 2;
            if (sNgTracker > 1) sNgTracker--;
        }
        singleRouteText.push(block);
        sRoll++;
    }
    return singleRouteText;
}

// =================================================================================
// 内部パス計算: 10連ルート (特殊ポインタ管理)
// =================================================================================

function calculateMultiRollRoute(Nodes, tableRows, initialNg, initialLastRollId, gacha, thresholds, SEED_LIST) {
    const multiRouteText = [];
    const gCycle = gacha.guaranteedCycle || 30;
    const uRate = gacha.uberGuaranteedFlag ? (gacha.rarityRates['3'] || 500) : 0;
    const lRate = gacha.legendGuaranteedFlag ? (gacha.rarityRates['4'] || 200) : 0;
    const gDiv = uRate + lRate;
    
    let tIdx = 1, tRoll = 1, tNgTracker = parseInt(initialNg, 10), tLastId = initialLastRollId;

    while (tIdx <= Nodes.length && tRoll <= tableRows) {
        const cycleHeadIdx = tIdx;
        const cycleHeadSeed = SEED_LIST[cycleHeadIdx];
        let cycleBlock = `<strong>【サイクル】</strong>先頭Seed: Seed[${cycleHeadIdx}]<br>`;
        
        let gIndex = -1;
        if (tNgTracker > 0 && tNgTracker <= 10) {
            gIndex = tNgTracker - 1;
        }

        let gRarityId = null;
        if (gIndex !== -1 && gDiv > 0) {
            const gRoll = cycleHeadSeed % gDiv;
            gRarityId = (gRoll < uRate) ? '3' : '4';
            tIdx++; // 確定枠レアリティ判定に1消費
        }

        for (let j = 0; j < 10; j++) {
            if (tRoll > tableRows || tIdx > Nodes.length) break;
            const node = Nodes[tIdx - 1];

            if (j === gIndex) {
                const poolG = gacha.rarityItems[gRarityId] || [];
                const itemIdG = poolG[node.seed1 % Math.max(1, poolG.length)];
                cycleBlock += `R${tRoll}[G]: ${getItemNameSafe(itemIdG)}<br>`;
                tLastId = itemIdG;
                tIdx += 1; // 確定枠スロットに1消費
                tNgTracker = gCycle;
            } else {
                const isMatch = (node.itemId === tLastId);
                const isRR = (node.rarityId === 1 && node.poolSize > 1 && isMatch) || node.reRerollFlag;
                cycleBlock += `R${tRoll}: ${isRR ? node.reRollItemName : node.itemName}<br>`;
                tLastId = isRR ? node.reRollItemId : node.itemId;
                tIdx += isRR ? 3 : 2;
                if (tNgTracker > 1) tNgTracker--;
            }
            tRoll++;
        }
        multiRouteText.push(cycleBlock);
    }
    return multiRouteText;
}

====================
FILE: logic-completed-highlight.js
====================
/**
 * 担当: ハイライトマップ（単発ルート・10連ルートの経路情報）の生成
 * 10連ガチャの特殊仕様（シード消費順序、確定枠の判定位置、トラック遷移）に対応
 */

function generateHighlightMap(Nodes, tableRows, initialNg, initialLastRollId, gCycle, gacha) {
    const map = new Map();
    const uFlag = gacha.uberGuaranteedFlag;
    const lFlag = gacha.legendGuaranteedFlag;
    const uRate = uFlag ? (gacha.rarityRates['3'] || 500) : 0;
    const lRate = lFlag ? (gacha.rarityRates['4'] || 200) : 0;
    const gDiv = uRate + lRate;
    const getAddr = (n) => getAddressStringGeneric(n, 2);

    // --- 1. 単発ルートのハイライト ---
    let sIdx = 1;
    let sLastId = initialLastRollId;
    let sNgTracker = parseInt(initialNg, 10);
    if (isNaN(sNgTracker)) sNgTracker = 0;

    for (let roll = 1; roll <= tableRows && sIdx <= Nodes.length; roll++) {
        const node = Nodes[sIdx - 1];
        if (!node) break;
        
        const isG = (sNgTracker === 1) && (uFlag || lFlag);
        let addr;

        if (isG) {
            addr = node.address + 'G';
            const existing = map.get(addr) || {};
            map.set(addr, { ...existing, single: true, singleRoll: roll });
            
            sIdx += 2;
            sNgTracker = gCycle;
            sLastId = node.itemGId;
        } else {
            addr = node.address;
            const isMatch = (node.itemId !== -1 && node.itemId === sLastId);
            const isRR = (node.rarityId === 1 && node.poolSize > 1 && isMatch) || node.reRerollFlag;
            
            const existing = map.get(addr) || {};
            map.set(addr, { ...existing, single: true, singleRoll: roll });
            
            sLastId = isRR ? node.reRollItemId : node.itemId;
            sIdx += isRR ? 3 : 2;
            
            if (sNgTracker > 1) sNgTracker--;
            else if (sNgTracker === 1) sNgTracker = gCycle;
        }
    }

    // --- 2. 10連ルートのハイライト ---
    let tIdx = 1;
    let tLastId = initialLastRollId;
    let tNgTracker = parseInt(initialNg, 10);
    if (isNaN(tNgTracker)) tNgTracker = 0;
    let tRollNum = 1;

    while (tIdx <= Nodes.length && tRollNum <= tableRows) {
        const cycleStartIdx = tIdx;
        let gRollInCycle = -1;

        if (tNgTracker > 0 && tNgTracker <= 10) {
            gRollInCycle = tNgTracker - 1;
        }
        
        let ptr = cycleStartIdx;

        // 確定枠がある場合、サイクル先頭の1SEEDをレアリティ判定に消費 (Seed[1])
        if (gRollInCycle !== -1 && gDiv > 0) {
            ptr++;
        }

        // 10連開始時のトラックを判定
        let currentTrack = getAddr(ptr).includes('A') ? 'A' : 'B';

        for (let j = 0; j < 10; j++) {
            const currentRollCount = tRollNum + j;
            if (currentRollCount > tableRows || ptr > Nodes.length) break;
            
            if (j === gRollInCycle) {
                // 確定枠の処理 (例: Seed[9])
                // 仕様: 確定枠は「スロット判定」に使用しているセル（現在のptr）をハイライト
                // ただし、トラックは確定枠直前のロールの反対側に配置される（住所計算）
                const node = Nodes[ptr - 1];
                const oppositeTrack = (currentTrack === 'A' ? 'B' : 'A');
                const addr = node.address.replace(/[AB]/, oppositeTrack) + 'G';
                
                const existing = map.get(addr) || {};
                map.set(addr, { 
                    ...existing, 
                    ten: true, 
                    tenRoll: currentRollCount,
                    tenIndex: ptr
                });

                ptr += 1; // 確定枠はスロット判定で1消費
                tNgTracker = gCycle;
                // 確定枠通過後、トラックを正式に反転
                currentTrack = oppositeTrack;
            } else {
                // 通常枠の処理
                // 仕様: レアリティ判定に使用しているセル（現在のptr）をハイライト
                const node = Nodes[ptr - 1];
                const addr = node.address.replace(/[AB]/, currentTrack);
                
                const isMatch = (node.itemId !== -1 && node.itemId === tLastId);
                const isRR = (node.rarityId === 1 && node.poolSize > 1 && isMatch) || node.reRerollFlag;
                
                const existing = map.get(addr) || {};
                map.set(addr, { 
                    ...existing, 
                    ten: true, 
                    tenRoll: currentRollCount,
                    t_reRoll: isRR,
                    tenIndex: ptr
                });

                tLastId = isRR ? node.reRollItemId : node.itemId;
                ptr += isRR ? 3 : 2;
                if (tNgTracker > 1) tNgTracker--;
            }
        }
        tIdx = ptr;
        tRollNum += 10;
    }

    return map;
}

====================
FILE: logic-completed-popup.js
====================
/**
 * 担当: ポップアップ（計算詳細）内の表示HTML生成
 * 仕様: テーブルの番地に基づいた静的な計算過程を表示
 */

function generateGachaInfoHeaderHtml(thresholds, gacha, isGuaranteedColumn) {
    const names = ["ノーマル", "レア", "激レア", "超激レア", "伝説レア"];
    let html = '<h4>ガチャ情報</h4><p style="font-size: 0.8rem; background: #eee; padding: 5px;">';
    
    if (isGuaranteedColumn && (gacha.uberGuaranteedFlag || gacha.legendGuaranteedFlag)) {
        let p = [];
        if (gacha.uberGuaranteedFlag) p.push(names[3]);
        if (gacha.legendGuaranteedFlag) p.push(names[4]);
        html += "確定枠対象: " + p.join(' / ');
    } else {
        Object.keys(thresholds).forEach(id => {
            html += `${names[id]}: ${thresholds[id]}${id < 4 ? ' / ' : ''}`;
        });
    }
    return html + '</p>';
}

function generateSeedInfoHtml(node, isGuaranteedColumn, linkSeeds) {
    let html = `<h3>${node.address}${isGuaranteedColumn ? 'G' : ''} の詳細計算</h3><h4>SEED情報</h4><ul>`;
    html += `<li>対象SEED (S1): Index[${node.index}] : ${node.seed1}</li>`;
    html += `<li>直前SEED: Index[${node.index - 1}] : ${node.prevSeed1}</li>`;
    
    const cmp = (calc, link, label, idx) => {
        if (!link) return `<li>${label}: 該当なし</li>`;
        const match = (calc.toString() === link.toString());
        const s = match ? '<span style="color:green;">(一致)</span>' : `<span style="color:red;">⚠️不一致: ${link}</span>`;
        return `<li>${label}: Index[${idx}] : ${calc} ${s}</li>`;
    };

    if (isGuaranteedColumn) {
        html += cmp(node.seed2, linkSeeds.avoid, "次SEED(通常)", node.index + 1);
        html += cmp(node.seed3, linkSeeds.reroll, "次SEED(再抽選)", node.index + 2);
    } else {
        html += cmp(node.seed2, linkSeeds.normal, "次SEED(通常)", node.index + 1);
        html += cmp(node.seed3, linkSeeds.reroll, "次SEED(再抽選)", node.index + 2);
    }
    return html + '</ul>';
}

function generateNodeCalculationDetailsHtml(node, gacha, thresholds, initialLastRollId, Nodes, linkSeeds, isGuar) {
    const names = ["ノーマル", "レア", "激レア", "超激レア", "伝説レア"];
    let html = '<div class="popup-details">';
    
    html += generateGachaInfoHeaderHtml(thresholds, gacha, isGuar);
    html += generateSeedInfoHtml(node, isGuar, linkSeeds);

    if (isGuar) {
        // AG/BG列（確定枠）の静的計算
        const uRate = gacha.uberGuaranteedFlag ? (gacha.rarityRates['3'] || 500) : 0;
        const lRate = gacha.legendGuaranteedFlag ? (gacha.rarityRates['4'] || 200) : 0;
        const gDiv = uRate + lRate;

        html += '<h4>確定枠計算 (通常)</h4>';
        if (gDiv > 0) {
            const gRoll = node.seed1 % gDiv;
            const rId = (gRoll < uRate) ? '3' : '4';
            const pool = (gacha.rarityItems[rId] || []);
            const slot = node.seed2 % Math.max(1, pool.length);
            
            html += `<p>Rarity: Seed[${node.index}] ${node.seed1} % ${gDiv} = ${gRoll} → ${names[rId]}</p>`;
            html += `<p>Slot: Seed[${node.index+1}] ${node.seed2} % ${pool.length} = ${slot} → ${getItemNameSafe(pool[slot])}</p>`;
        }

        if (node.reRollFlag || node.reRerollFlag) {
            html += '<h4>確定枠計算 (再抽選経由)</h4>';
            if (gDiv > 0) {
                const gRoll_RR = node.seed2 % gDiv;
                const rId_RR = (gRoll_RR < uRate) ? '3' : '4';
                const pool_RR = (gacha.rarityItems[rId_RR] || []);
                const slot_RR = node.seed3 % Math.max(1, pool_RR.length);
                
                html += `<p>Rarity: Seed[${node.index+1}] ${node.seed2} % ${gDiv} = ${gRoll_RR} → ${names[rId_RR]}</p>`;
                html += `<p>Slot: Seed[${node.index+2}] ${node.seed3} % ${pool_RR.length} = ${slot_RR} → ${getItemNameSafe(pool_RR[slot_RR])}</p>`;
            }
        }
    } else {
        // A/B列（通常枠）の静制計算
        html += '<h4>通常計算</h4>';
        html += `<p>Rarity: Seed[${node.index}] ${node.seed1} % 10000 = ${node.roll1} → ${names[node.rarityId]}</p>`;
        html += `<p>Slot: Seed[${node.index+1}] ${node.seed2} % ${node.poolSize} = ${node.slot} → ${node.itemName}</p>`;

        const prevN2 = (node.index >= 3) ? Nodes[node.index - 3] : null;
        const prevId2 = prevN2 ? prevN2.itemId : (initialLastRollId || -1);
        const match = (node.itemId !== -1 && node.itemId === prevId2);
        
        html += '<h4>被り判定</h4>';
        html += `<div style="font-size:0.8rem; border:1px solid #ddd; padding:8px; background:#fafafa;">`;
        html += `直前アイテム: ${getItemNameSafe(prevId2)}<br>`;
        html += `一致判定: <b>${match ? '一致' : '不一致'}</b><br>`;
        html += `再抽選実行: <b>${node.reRollFlag ? '実行' : 'なし'}</b>`;
        html += `</div>`;

        if (node.reRollFlag || node.reRerollFlag) {
            html += '<h4>再抽選詳細</h4>';
            html += `<p>Slot: Seed[${node.index+2}] ${node.seed3} % ${node.poolSize-1} = ${node.reRollSlot} → ${node.reRollItemName}</p>`;
        }
    }
    return html + '</div>';
}

====================
FILE: logic-completed-search.js
====================
// =================================================================================
// 最適ルート探索（ビームサーチ）
// =================================================================================

function simulateSingleRoll(startIdx, lastId, rollNum, currentNg, gacha, Nodes, nodeInit = null) {
    const node = Nodes[startIdx - 1];
    if (!node) return null;

    const gCycle = gacha.guaranteedCycle || 30;
    const isGuar = !isNaN(currentNg) && currentNg > 0 && (gacha.uberGuaranteedFlag || gacha.legendGuaranteedFlag) && (rollNum >= currentNg) && ((rollNum - currentNg) % 10 === 0);
    
    if (isGuar && nodeInit) { // 10連内の確定
        const poolG = gacha.rarityItems[nodeInit.rarityGId] || [];
        const slotG = node.seed1 % Math.max(1, poolG.length);
        const itemIdG = poolG[slotG];
        return { itemId: itemIdG, useSeeds: 1, rarity: itemMaster[itemIdG]?.rarity || 0, nextNg: gCycle };
    } else if (isGuar) { // 単発の確定
        return { itemId: node.itemGId, useSeeds: 2, rarity: itemMaster[node.itemGId]?.rarity || 0, nextNg: gCycle };
    } else { // 通常
        const isMatch = (node.itemId !== -1 && node.itemId === lastId);
        const isRR = (node.rarityId === 1 && node.poolSize > 1 && isMatch) || node.reRerollFlag;
        let finalId = node.itemId;
        if (isRR) {
            const pool = gacha.rarityItems[node.rarityId] || [];
            const filtered = pool.filter(id => id !== node.itemId);
            if (filtered.length > 0) {
                finalId = filtered[node.seed3 % Math.max(1, filtered.length)];
            }
        }
        const nextNg = (currentNg <= 1) ? gCycle : currentNg - 1;
        return { itemId: finalId, useSeeds: isRR ? 3 : 2, rarity: itemMaster[finalId]?.rarity || 0, nextNg };
    }
}

function findBestBeamSearchResult(dp, totalTickets) {
    let best = null;
    const calculateScore = (state) => {
        let score = 0;
        for (let i = 0; i < state.layerCounts.length; i++) {
            score += state.layerCounts[i] * Math.pow(1000, state.layerCounts.length - i + 1);
        }
        return score + (state.ubers * 10) + state.legends;
    };
    for (let i = totalTickets; i >= 0; i--) {
        if (!dp[i]) continue;
        for (let state of dp[i].values()) {
            if (!best || calculateScore(state) > calculateScore(best)) {
                best = state;
            }
        }
        if (best) break;
    }
    return best;
}

function runGachaBeamSearchCorrected(Nodes, initialLastRollId, totalTickets, gacha, thresholds, initialNg, targetLayers = []) {
    let dp = new Array(totalTickets + 1).fill(null).map(() => new Map());
    dp[0].set(`1_${initialLastRollId}_${initialNg}`, {
        nodeIdx: 1, lastId: initialLastRollId, currentNg: initialNg,
        layerCounts: new Array(targetLayers.length).fill(0),
        ubers: 0, legends: 0, path: [], rollCount: 1
    });

    const calculateScore = (state) => {
        let score = 0;
        for (let i = 0; i < state.layerCounts.length; i++) {
            score += state.layerCounts[i] * Math.pow(1000, targetLayers.length - i + 1);
        }
        return score + (state.ubers * 10) + state.legends;
    };

    for (let t = 0; t < totalTickets; t++) {
        if (!dp[t]) continue;
        const states = Array.from(dp[t].values()).sort((a, b) => calculateScore(b) - calculateScore(a)).slice(0, 200);

        for (let state of states) {
            // 単発ガチャ (Single Roll)
            const resS = simulateSingleRoll(state.nodeIdx, state.lastId, state.rollCount, state.currentNg, gacha, Nodes);
            if (resS) {
                const newLayerCounts = [...state.layerCounts];
                targetLayers.forEach((ids, idx) => { if (ids.includes(resS.itemId)) newLayerCounts[idx]++; });
                const nextState = {
                    nodeIdx: state.nodeIdx + resS.useSeeds, lastId: resS.itemId, currentNg: resS.nextNg,
                    layerCounts: newLayerCounts, ubers: state.ubers + (resS.rarity === 3 ? 1 : 0),
                    legends: state.legends + (resS.rarity === 4 ? 1 : 0),
                    path: state.path.concat({ type: 'single', item: getItemNameSafe(resS.itemId), addr: Nodes[state.nodeIdx - 1]?.address || '?' }),
                    rollCount: state.rollCount + 1
                };
                const key = `${nextState.nodeIdx}_${nextState.lastId}_${nextState.currentNg}`;
                if (t + 1 <= totalTickets && (!dp[t + 1].has(key) || calculateScore(dp[t + 1].get(key)) < calculateScore(nextState))) {
                    dp[t + 1].set(key, nextState);
                }
            }

            // 10連ガチャ (10-Roll)
            if (t + 10 <= totalTickets) {
                const startNode = Nodes[state.nodeIdx - 1];
                if (startNode) {
                    let curIdx = state.nodeIdx;
                    let curLastId = state.lastId;
                    let curNg = state.currentNg;
                    let curRoll = state.rollCount;
                    
                    let items = [];
                    let ubers = 0;
                    let legends = 0;
                    let addLayer = new Array(targetLayers.length).fill(0);
                    let validCycle = true;
                    
                    let gRarityId = null;
                    let gRollIndexInCycle = -1;

                    if (!isNaN(curNg) && curNg !== 'none' && curNg > 0 && curNg <= curRoll + 9) {
                        for (let i = 0; i < 10; i++) {
                            if (((curRoll + i - curNg) % 10 === 0) && (curRoll + i >= curNg)) {
                                gRollIndexInCycle = i;
                                break;
                            }
                        }
                    }

                    if (gRollIndexInCycle !== -1) {
                        const gRarityNode = Nodes[curIdx - 1];
                        if (!gRarityNode) {
                            validCycle = false;
                        } else {
                            gRarityId = gRarityNode.rarityGId;
                            curIdx++; // Consume seed for guaranteed rarity
                        }
                    }

                    if (validCycle) {
                        for (let j = 0; j < 10; j++) {
                            const currentRollNumber = curRoll + j;
                            if (j === gRollIndexInCycle) {
                                // Guaranteed Slot
                                const gSlotNode = Nodes[curIdx - 1];
                                if (!gSlotNode) { validCycle = false; break; }
                                
                                const poolG = gacha.rarityItems[gRarityId] || [];
                                const slotG = gSlotNode.seed1 % Math.max(1, poolG.length);
                                const itemIdG = poolG[slotG];
                                const rarityG = itemMaster[itemIdG]?.rarity || 0;

                                items.push(getItemNameSafe(itemIdG));
                                targetLayers.forEach((ids, idx) => { if (ids.includes(itemIdG)) addLayer[idx]++; });
                                if (rarityG === 3) ubers++;
                                if (rarityG === 4) legends++;

                                curLastId = itemIdG;
                                curIdx += 1;
                                curNg = gacha.guaranteedCycle || 30;

                            } else {
                                // Normal Slot
                                const node = Nodes[curIdx - 1];
                                if (!node) { validCycle = false; break; }

                                const isMatch = (node.itemId !== -1 && node.itemId === curLastId);
                                const isRR = (node.rarityId === 1 && node.poolSize > 1 && isMatch) || node.reRerollFlag;
                                
                                let finalId = node.itemId;
                                let useSeeds = 2;
                                if (isRR) {
                                    finalId = node.reRollItemId;
                                    useSeeds = 3;
                                }

                                const finalRarity = itemMaster[finalId]?.rarity || 0;
                                items.push(getItemNameSafe(finalId));
                                targetLayers.forEach((ids, idx) => { if (ids.includes(finalId)) addLayer[idx]++; });
                                if (finalRarity === 3) ubers++;
                                if (finalRarity === 4) legends++;
                                
                                curLastId = finalId;
                                curIdx += useSeeds;
                                if (!isNaN(curNg) && curNg !== 'none') {
                                   curNg = (curNg <= 1) ? (gacha.guaranteedCycle || 30) : curNg - 1;
                                }
                            }
                        }
                    }

                    if (validCycle) {
                        const nextStateTen = {
                            nodeIdx: curIdx,
                            lastId: curLastId,
                            currentNg: curNg,
                            layerCounts: state.layerCounts.map((c, idx) => c + addLayer[idx]),
                            ubers: state.ubers + ubers,
                            legends: state.legends + legends,
                            path: state.path.concat({ type: 'ten', items: items, addr: startNode.address }),
                            rollCount: curRoll + 10
                        };
                        const keyTen = `${nextStateTen.nodeIdx}_${nextStateTen.lastId}_${nextStateTen.currentNg}`;
                        if (!dp[t + 10].has(keyTen) || calculateScore(dp[t + 10].get(keyTen)) < calculateScore(nextStateTen)) {
                            dp[t + 10].set(keyTen, nextStateTen);
                        }
                    }
                }
            }
        }
    }
    return findBestBeamSearchResult(dp, totalTickets);
}

====================
FILE: logic-completed.js
====================
/**
 * 担当: 「コンプ済み」ビューにおける全アイテムの計算ロジック
 * 構成:
 * 1. メイン計算関数 `calculateCompletedData`
 *    - `initializeNodes`: 全ノードの基本情報を算出
 *    - `calculateRerolls`: 再抽選・再々抽選の判定
 *    - `calculateSingleRollRoute`: 単発ルートのテキストを生成
 *    - `calculateMultiRollRoute`: 10連ルートのテキストを生成
 * 2. ポップアップHTML生成 `generateNodeCalculationDetailsHtml`
 *    - 各種ヘルパー関数
 * 3. 最適ルート探索 `runGachaBeamSearchCorrected`
 *    - `simulateSingleRoll`: 1回分のガチャをシミュレート
 *    - その他ヘルパー関数
 * 4. ハイライト情報生成 `generateHighlightMap`
 */

// =================================================================================
// メイン計算関数
// =================================================================================

function calculateCompletedData(initialSeed, gacha, tableRows, thresholds, initialLastRollId, initialNg) {
    const maxSeedsNeeded = Math.max(tableRows * 20, 20000);
    const SEED_LIST = generateSeedList(initialSeed, maxSeedsNeeded);
    
    const maxNodeIndex = Math.max(tableRows * 6, 6000);
    const Nodes = initializeNodes(SEED_LIST, maxNodeIndex, gacha, thresholds);
    
    calculateRerolls(Nodes, initialLastRollId, gacha);

    const singleRouteText = calculateSingleRollRoute(Nodes, tableRows, initialNg, initialLastRollId, gacha, thresholds, SEED_LIST);
    const multiRouteText = calculateMultiRollRoute(Nodes, tableRows, initialNg, initialLastRollId, gacha, thresholds, SEED_LIST);
    const highlightInfo = generateHighlightMap(Nodes, tableRows, initialNg, initialLastRollId, gacha.guaranteedCycle || 30, gacha);

    return { Nodes, singleRouteText, multiRouteText, highlightInfo, maxNodeIndex, SEED_LIST };
}

====================
FILE: logic-uncompleted-sim.js
====================
/**
 * 担当: 「未コンプ」ビュー用の10連ガチャシミュレーションおよび期待値計算ロジック
 * 依存関係: logic-common.js
 */

/**
 * 10連詳細（現在地からの1回分）を計算するロジック
 */
function calculateTenPullDetailedLogic(fullSeedArray, gacha, thresholds, ngVal, initialLastRollId, getAddressFunc) {
    const isGuaranteedActive = !isNaN(ngVal);
    const guaranteedCycle = gacha.guaranteedCycle || 30;
    
    let guaranteedStatus = 'none';
    let currentNgVal = ngVal;
    
    // Featured 判定で実際に消費したシードの数をトラック
    let featuredSeedPtr = 0; 
    
    if (isGuaranteedActive && currentNgVal > 0) {
        if (currentNgVal <= 10) {
            guaranteedStatus = `next guaranteed(${currentNgVal}) <= 10 → 9ロール抽選`;
        } else {
            guaranteedStatus = `next guaranteed(${currentNgVal}) >= 11 → 10ロール抽選`;
        }
    } else {
        guaranteedStatus = 'Not Guaranteed/NG Invalid → 10ロール抽選';
    }

    const featuredLog = [];
    const processLog = [];
    const results = [];
    let featuredCountInCycle = 0; 

    // 目玉判定用シード (S1～S10) の計算
    const featuredResults = [];
    for (let i = 1; i <= 10; i++) { 
        const isGuaranteedRoll = isGuaranteedActive && i === currentNgVal && currentNgVal <= 10;

        if (isGuaranteedRoll) {
             featuredLog.push(`S${i} (Skipped): Guaranteed Roll (${currentNgVal})`);
             continue;
        }
        
        const sVal = fullSeedArray[featuredSeedPtr];
        if (sVal === undefined) {
             console.error(`Seed is undefined at index ${featuredSeedPtr}.`);
             break; 
        }

        const mod = sVal % 10000;
        const isFeatured = mod < gacha.featuredItemRate;
        featuredResults.push({ index: i, isFeatured: isFeatured, seedIndex: featuredSeedPtr + 1 });
        featuredLog.push(`S${featuredSeedPtr + 1} (${sVal}) % 10000 = ${mod} < ${gacha.featuredItemRate} → ${isFeatured} (Roll ${i}用)`);
        featuredSeedPtr++;
    }

    let currentSeedIndex = featuredSeedPtr; 
    let lastItemId = initialLastRollId || -1;
    const rollCount = 10;
    let featuredIdxPtr = 0; 

    for (let r = 1; r <= rollCount; r++) {
        let label = `Roll${r}`;
        
        // 確定ロール判定
        if (isGuaranteedActive && r === currentNgVal) {
            label += `(G${r})`;
            if (currentNgVal <= 10) { 
                processLog.push(`${label} (Skipped): Guaranteed Roll`);
            } else {
                processLog.push(`${label}: Featured Item by guaranteed`); 
            }
            results.push({ label: label, name: '目玉(確定)', isGuaranteed: true, isFeatured: false, isReroll: false, preRerollName: null });
            featuredCountInCycle++; 
            continue;
        }

        // 非確定ロール判定
        const fRes = featuredResults[featuredIdxPtr];
        if (!fRes) {
             processLog.push(`${label}: **ERROR**: Featured check result missing.`);
             break;
        }
        featuredIdxPtr++; 
        
        if (fRes.isFeatured) {
            results.push({ label: label, name: '目玉', isGuaranteed: false, isFeatured: true, isReroll: false, preRerollName: null });
             processLog.push(`${label}: Featured (by S${fRes.seedIndex})`);
             lastItemId = -2;
             featuredCountInCycle++; 
        } else {
            // Continuation Seeds Consumption
            const sRarity = fullSeedArray[currentSeedIndex];
            const sSlot = fullSeedArray[currentSeedIndex+1];
            
            if (sRarity === undefined || sSlot === undefined) {
                 processLog.push(`${label}: **ERROR**: Seed array ended unexpectedly.`);
                 break; 
            }

            const rarityInfo = getRarityFromRoll(sRarity % 10000, thresholds);
            const rId = rarityInfo.id;
            const rName = rarityInfo.name;
            let logStr = `${label}: S${currentSeedIndex+1}→${rName}`;
            
            const pool = gacha.rarityItems[rId] || [];
            const poolSize = pool.length > 0 ? pool.length : 1;
            const slot = sSlot % poolSize;
            const itemId = (pool[slot] !== undefined) ? pool[slot] : -1;
            const itemName = getItemNameSafe(itemId);
            
            logStr += `, S${currentSeedIndex+2}→${itemName}`;
            
            let finalId = itemId;
            let finalName = itemName;
            let consumed = 2;
            let isReroll = false;
            let preRerollName = null;

            // Dupe Check
            if (rId === 1 && itemId !== -1 && itemId === lastItemId) {
                const sReRoll = fullSeedArray[currentSeedIndex+2];
                if (sReRoll === undefined) break;
                const rePool = pool.filter(id => id !== itemId);
                const reDiv = rePool.length;
                logStr += ` [Dupe]`;
                if (reDiv > 0) {
                    isReroll = true;
                    preRerollName = itemName;
                    const reSlot = sReRoll % reDiv;
                    finalId = rePool[reSlot];
                    finalName = getItemNameSafe(finalId);
                    logStr += `, S${currentSeedIndex+3}→${finalName}`;
                }
                consumed = 3;
            }

            processLog.push(logStr);
            results.push({ label: label, name: finalName, isGuaranteed: false, isFeatured: false, isReroll: isReroll, preRerollName: preRerollName });
            currentSeedIndex += consumed;
            lastItemId = finalId;
        }
    }

    const nextSeedVal = fullSeedArray[currentSeedIndex]; 
    const nextIndex = currentSeedIndex + 1;
    const nextAddress = (fullSeedArray.length > currentSeedIndex) ? getAddressFunc(nextIndex) : 'End';
    const nextNgVal = isGuaranteedActive ? currentNgVal : NaN;
    const seedsConsumedCorrectly = currentSeedIndex; 

    return {
        guaranteedStatus, featuredLog, processLog, results, featuredCountInCycle,
        transition: { consumedCount: seedsConsumedCorrectly, nextIndex: nextIndex, nextAddress: nextAddress, nextSeed: nextSeedVal, lastItemId: lastItemId, nextNgVal: nextNgVal }
    };
}

/**
 * nサイクル分の10連計算を実行
 */
function calculateTenPullsOverCycles(initialFullSeedArray, gacha, thresholds, initialNgVal, initialLastRollId, nCycles = 10) {
    const getAddress = (n) => getAddressStringGeneric(n, 3);
    const guaranteedCycle = gacha.guaranteedCycle || 30; // 確定サイクルの値を取得
    let currentSeedArray = [...initialFullSeedArray];
    let currentLastRollId = initialLastRollId;
    let currentNgVal = initialNgVal;
    
    const cycleResults = [];
    const maxSeedsInTenPull = 40; 

    for (let c = 1; c <= nCycles; c++) {
        if (currentSeedArray.length < 1) break;
        const tenPullSeedSlice = currentSeedArray.slice(0, maxSeedsInTenPull); 
        const cycleResult = calculateTenPullDetailedLogic(tenPullSeedSlice, gacha, thresholds, currentNgVal, currentLastRollId, getAddress);
        
        cycleResults.push({ cycle: c, ...cycleResult, startNgVal: currentNgVal, startLastRollId: currentLastRollId });

        const consumedCount = cycleResult.transition.consumedCount;
        currentSeedArray = currentSeedArray.slice(consumedCount);
        currentLastRollId = cycleResult.transition.lastItemId;
        let nextNgValFromLogic = cycleResult.transition.nextNgVal; // logicから返されたNG値

        // 10連が終わった時点で10ロール分マイナスする
        if (!isNaN(nextNgValFromLogic)) {
                currentNgVal = nextNgValFromLogic - 10;
            // 確定サイクルをまたいだ場合の処理
            if (currentNgVal <= 0) {
                 currentNgVal = guaranteedCycle + currentNgVal;
            }
        } else {
            // 確定システムが無効な場合はそのまま NaN を維持
            currentNgVal = nextNgValFromLogic;
        }
    }
    return cycleResults;
}

/**
 * 単発Nロール後の10連目玉獲得数期待値の計算ロジック
 */
function calculateExpectedFeaturedCounts(initialFullSeedArray, gacha, thresholds, nRollsArray, initialNgVal, initialLastRollId) {
    const results = {};
    const guaranteedCycle = gacha.guaranteedCycle || 30;
    const tenPullSimulationLength = 40; 
    
    // Nロール後の状態をシミュレーション
    const simulateSingleRollsAndGetState = (n, seedArray, initialNg, initialLastRoll) => {
        let currentSeedIndex = 0;
        let currentNg = !isNaN(initialNg) && initialNg > 0 ? initialNg : guaranteedCycle;
        let lastItemId = initialLastRoll || -1;
        
        for (let r = 1; r <= n; r++) {
            if (currentSeedIndex >= seedArray.length) break;
            const isFeatured = (seedArray[currentSeedIndex] % 10000) < gacha.featuredItemRate;
            const isGuaranteedRoll = (currentNg === 1);
            let usedSeeds = 0;

            if (isGuaranteedRoll) {
                usedSeeds = 1; currentNg = guaranteedCycle; lastItemId = -2;
            } else if (isFeatured) {
                usedSeeds = 1; currentNg = currentNg - 1;
                if (currentNg <= 0) currentNg = guaranteedCycle;
                lastItemId = -2;
            } else {
                const sRarity = seedArray[currentSeedIndex+1];
                const sSlot = seedArray[currentSeedIndex+2];
                if (sRarity === undefined || sSlot === undefined) { usedSeeds = 3; break; }
                const rarityInfo = getRarityFromRoll(sRarity % 10000, thresholds);
                const rId = rarityInfo.id;
                const pool = gacha.rarityItems[rId] || [];
                const itemId = (pool[sSlot % (pool.length||1)] !== undefined) ? pool[sSlot % (pool.length||1)] : -1;
                usedSeeds = 3;
                let finalId = itemId;

                if (rId === 1 && itemId !== -1 && itemId === lastItemId) {
                    const sReRoll = seedArray[currentSeedIndex+3];
                    if (sReRoll !== undefined) {
                        const rePool = pool.filter(id => id !== itemId);
                        if (rePool.length > 0) {
                            finalId = rePool[sReRoll % rePool.length];
                            usedSeeds = 4;
                        }
                    }
                }
                currentNg = currentNg - 1;
                if (currentNg <= 0) currentNg = guaranteedCycle;
                lastItemId = finalId;
            }
            currentSeedIndex += usedSeeds;
        }
        return { nextSeedIndex: currentSeedIndex, nextNg: currentNg, nextLastRollId: lastItemId };
    };

    for (const n of nRollsArray) {
        if (n < 0) continue;
        const { nextSeedIndex, nextNg, nextLastRollId } = simulateSingleRollsAndGetState(n, initialFullSeedArray, initialNgVal, initialLastRollId);
        const tenPullSeedArray = initialFullSeedArray.slice(nextSeedIndex, nextSeedIndex + tenPullSimulationLength);

        if (tenPullSeedArray.length < 9) {
             results[n] = 0; continue;
        }
        const tenPullResult = calculateTenPullDetailedLogic(tenPullSeedArray, gacha, thresholds, nextNg, nextLastRollId, (addr) => `S${nextSeedIndex + addr}`);
        results[n] = tenPullResult.featuredCountInCycle;
    }
    return results;
}

====================
FILE: logic-uncompleted.js
====================
/**
 * 担当: 「未コンプ」ビューにおけるメインテーブル用のノード計算
 * 依存関係: logic-common.js, logic-uncompleted-sim.js
 */

/**
 * 未コンプ（分割）ビュー用のデータを計算する関数
 */
function calculateUncompletedData(initialSeed, gacha, tableRows, thresholds, initialLastRollId, params) {
    // 1. シード生成
    const maxSeedsNeeded = tableRows * 10 + 1000; 
    const SEED = generateSeedList(initialSeed, maxSeedsNeeded);
    const getAddress = (n) => getAddressStringGeneric(n, 3);
    
    // 2. 全ノード計算 (メインテーブル用)
    const Nodes = [];
    const maxNodes = tableRows * 3 + 20; 
    const highlightInfo = new Map(); 

    const ngVal = parseInt(params.get('ng'), 10);
    const initialFs = parseInt(params.get('fs'), 10) || 0; 
    const guaranteedCycle = gacha.guaranteedCycle || 30;
    
    for (let i = 1; i <= maxNodes; i++) {
        const seedStartIdx = i; 
        const s1 = SEED[seedStartIdx];     
        const s2 = SEED[seedStartIdx + 1]; 
        const s3 = SEED[seedStartIdx + 2]; 
        const s4 = SEED[seedStartIdx + 3]; 
        let prevSeedVal = SEED[seedStartIdx - 1];

        const node = {
            index: i, address: getAddress(i),
            seed1: s1, seed2: s2, seed3: s3, seed4: s4,
            prevSeed1: prevSeedVal,
            isFeatured: (s1 % 10000) < gacha.featuredItemRate,
            singleRoll: null, singleUseSeeds: null, singleNextAddr: null,
            guaranteedNextNgVal: ngVal,
            isFeaturedUsedFs: false,
        };

        node.featuredNextAddress = getAddress(i + 1); 
        node.normalNextAddress = getAddress(i + 3);   
        node.reRollNextAddress = getAddress(i + 4);   

        node.rarity = getRarityFromRoll(s2 % 10000, thresholds);
        node.rarityId = node.rarity.id;
        node.rarityName = node.rarity.name; 
        
        // レアリティ範囲表示用
        let lowerBound = 0, upperBound = 10000;
        const rarityIds = Object.keys(thresholds).map(Number).sort((a, b) => a - b);
        for(const id of rarityIds) {
            if (id < node.rarityId) lowerBound = thresholds[id];
            if (id === node.rarityId) { upperBound = thresholds[id]; break; }
        }
        node.rarityRateRangeDisplay = `${lowerBound}<=${s2 % 10000}<${upperBound}`;
        
        const pool = gacha.rarityItems[node.rarityId] || [];
        node.poolSize = pool.length;
        if (pool.length > 0) {
            node.slot = s3 % pool.length;
            node.itemId = pool[node.slot];
            node.itemName = getItemNameSafe(node.itemId);
        } else {
            node.slot = 0; node.itemId = -1; node.itemName = '---';
        }
        
        const isRare = (node.rarityId === 1);
        if (isRare && pool.length > 1) {
            const reRollPool = pool.filter(id => id !== node.itemId);
            if (reRollPool.length > 0) {
                node.reRollSlot = s4 % reRollPool.length;
                node.reRollItemId = reRollPool[node.reRollSlot];
                node.reRollItemName = getItemNameSafe(node.reRollItemId);
            } else { node.reRollItemId = -1; node.reRollItemName = '---'; }
        } else { node.reRollItemId = -1; node.reRollItemName = '---'; }

        // Dupe判定用
        let compareId3Node = -1, compareId4Node = -1;
        let compareName3Node = '---', compareName4Node = '---';
        
        if (i <= 1) { 
            compareId3Node = initialLastRollId || -1;
            compareName3Node = getItemNameSafe(initialLastRollId || -1);
        } else {
            const pNode3 = (i > 3) ? Nodes[i-4] : null; 
            if (pNode3 && pNode3.singleUseSeeds === 3) {
                 compareId3Node = pNode3.itemId; compareName3Node = pNode3.itemName;
            } else if (i <= 3) {
                compareId3Node = initialLastRollId || -1; compareName3Node = getItemNameSafe(initialLastRollId || -1);
            }
            const pNode4 = (i > 4) ? Nodes[i-5] : null;
            if (pNode4 && pNode4.singleUseSeeds === 4 && pNode4.reRollItemId !== -1) {
                 compareId4Node = pNode4.reRollItemId; compareName4Node = pNode4.reRollItemName;
            }
        }
        
        const currentId = node.itemId;
        const isDupe3 = (currentId !== -1 && currentId === compareId3Node);
        const isDupe4 = (compareId4Node !== -1 && currentId === compareId4Node); 
        node.isDupe = (node.rarityId === 1 && (isDupe3 || isDupe4)); 

        if (node.rarityId === 1) {
            const id3 = compareId3Node !== -1 ? compareName3Node : '-';
            const id4 = compareId4Node !== -1 ? compareName4Node : '';
            node.dupeCompareTargets = `${id3}${id4 ? '/' + id4 : ''}`; 
        } else { node.dupeCompareTargets = node.rarityName; }

        Nodes.push(node);
    }
    
    // 3. 単発ルート計算
    let sIdx = 1; 
    let sLastActualItemId = initialLastRollId || -1; 
    let sCurrentFs = initialFs;
    const singleRoutePath = new Map();
    const hasGuaranteed = !isNaN(ngVal);
    let currentNg = hasGuaranteed ? ngVal : -1;

    for (let roll = 1; roll <= tableRows; roll++) {
        if (sIdx > maxNodes) break;
        const node = Nodes[sIdx - 1];
        if (!node) break;
        
        const isGuaranteedRoll = hasGuaranteed && (currentNg === 1); 
        node.singleCompareItemName = getItemNameSafe(sLastActualItemId);
        node.singleCompareItemId = sLastActualItemId; 

            let usedSeeds = 0;
            let finalId = -1;
            
            if (node.isFeatured) {
                usedSeeds = 1; finalId = -2; 
                node.singleRoll = roll;
                node.singleUseSeeds = usedSeeds;
                node.singleNextAddr = node.featuredNextAddress; 
                if (sCurrentFs > 0) { sCurrentFs -= 1; node.isFeaturedUsedFs = true; }
            } else {
                const poolSize = gacha.rarityItems[1] ? gacha.rarityItems[1].length : 0;
                const currentId = Number(node.itemId);
                const lastId = Number(sLastActualItemId);
                const isMatch = (currentId !== -1 && lastId !== -1 && currentId === lastId);
                const isReroll = (node.rarityId === 1) && isMatch && poolSize > 1; 
                
                finalId = isReroll ? node.reRollItemId : node.itemId;
                usedSeeds = isReroll ? 4 : 3;
                
                node.singleIsReroll = isReroll; 
                node.singleRoll = roll;
                node.singleUseSeeds = usedSeeds;
                node.singleNextAddr = isReroll ? node.reRollNextAddress : node.normalNextAddress; 
            }
            sLastActualItemId = finalId; 
            if (hasGuaranteed) {
                currentNg = currentNg - 1;
                if (currentNg <= 0) currentNg = guaranteedCycle;
            }
        if (isGuaranteedRoll) {
            node.singleRoll = `${roll}g`;
            //node.singleUseSeeds = 0; 
            //node.singleNextAddr = node.featuredNextAddress;
            //node.singleIsReroll = false; 
            node.isGuaranteedRoll = true; // フラグ
            currentNg = guaranteedCycle; 
            sLastActualItemId = -2; 
        }
        singleRoutePath.set(sIdx, roll);
        sIdx = sIdx + (node.singleUseSeeds === 0 ? 0 : node.singleUseSeeds || 3); 
    }

    // 4. Highlight Info 生成 (単発ルート)
    sIdx = 1; 
    for (let roll = 1; roll <= tableRows; roll++) {
        if (sIdx > maxNodes) break;
        const node = Nodes[sIdx - 1];
        if (!node || node.singleRoll === null) break;
        const addressKey = node.address;
        
        const info = highlightInfo.get(addressKey) || {};
        info.single = true; info.singleRoll = roll; 

        if (node.singleRoll.toString().endsWith('g')) {
             info.s_guaranteed = true;
        } else if (node.isFeatured) {
             info.s_featured = true; info.s_reRoll = false;
        } else if (node.rarityId !== 1) { 
             info.s_featured = false; info.s_reRoll = false; 
             info.s_normalName = node.rarityName; 
        } else {
             info.s_featured = false;
             info.s_reRoll = node.singleIsReroll; 
             info.s_currentId = node.itemId;
             if (info.s_reRoll) {
                 info.s_normalName = node.itemName; 
                 info.s_reRollName = node.reRollItemName;
             }
        }
        highlightInfo.set(addressKey, info);
        sIdx += node.singleUseSeeds || 3; 
    }
    
    // 5. Simロジック委譲: 10連サイクル計算 & 期待値計算
    const tenPullCyclesData = calculateTenPullsOverCycles(SEED, gacha, thresholds, ngVal, initialLastRollId, 10);
    const nRollsArray = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    const expectedFeaturedCounts = calculateExpectedFeaturedCounts(SEED, gacha, thresholds, nRollsArray, ngVal, initialLastRollId);

    return { Nodes, highlightInfo, maxNodes, singleRoutePath, tenPullCyclesData, expectedFeaturedCounts };
}

====================
FILE: main.js
====================
/**
 * 担当: アプリケーションの起動、URLパラメータ管理、DOMイベントリスナーの制御
 */

// --- グローバル変数 ---
const DEFAULT_PARAMS = {
    gacha: '45',
    seed: '12345',
    ng: 'none',
    fs: 'none',
    lr: null,
    comp: false,
    tx: false,
    roll: 100,
    displaySeed: '0',
    displaySim: '0' 
};

let currentHighlightMode = 'all'; 
let activeGachaId;
let forceRerollMode = false;

window.activeGachaId = activeGachaId;
window.forceRerollMode = forceRerollMode;

/**
 * シミュレーション実行および表示のメインディスパッチャー
 */
function runSimulationAndDisplay(options = {}) {
    const { hideSeedInput = false, uiOverrides = {} } = options;
    const params = new URLSearchParams(window.location.search);
    
    // 最新のガチャIDを取得
    const gachaIds = Object.keys(gachaMaster).map(Number);
    const latestGachaId = Math.max(...gachaIds).toString();

    // 現在のパラメータを取得、未設定ならデフォルトを適用
    const p = {};
    ['gacha', 'seed', 'ng', 'fs', 'lr', 'comp', 'tx', 'roll', 'displaySeed', 'displaySim'].forEach(k => {
        p[k] = params.get(k);
    });

    if (!p.gacha || !gachaMaster[p.gacha]) p.gacha = latestGachaId;
    if (!p.seed) p.seed = DEFAULT_PARAMS.seed;
    if (!p.roll) p.roll = DEFAULT_PARAMS.roll;
    if (!p.ng) p.ng = DEFAULT_PARAMS.ng;
    if (!p.displaySeed) p.displaySeed = DEFAULT_PARAMS.displaySeed;
    if (!p.displaySim) p.displaySim = DEFAULT_PARAMS.displaySim;

    // UI操作による上書き設定
    if (uiOverrides.seed !== undefined) p.seed = uiOverrides.seed;
    if (uiOverrides.guaranteedRolls !== undefined) p.ng = uiOverrides.guaranteedRolls;
    if (uiOverrides.featuredStock !== undefined) p.fs = uiOverrides.featuredStock;
    if (uiOverrides.isComplete !== undefined) p.comp = uiOverrides.isComplete ? 'true' : 'false';
    if (uiOverrides.displaySeed !== undefined) p.displaySeed = uiOverrides.displaySeed;
    if (uiOverrides.displaySim !== undefined) p.displaySim = uiOverrides.displaySim;
    
    activeGachaId = p.gacha;
    window.activeGachaId = activeGachaId;
    const gacha = gachaMaster[p.gacha];
    
    // シミュレーション表示設定の反映
    const simContainer = document.getElementById('sim-ui-container');
    const toggleSimBtn = document.getElementById('toggleSimBtn');
    
    if (p.displaySim === '1') {
        simContainer.style.display = 'block';
        toggleSimBtn.textContent = 'シミュレーションを非表示';
        // UIコンテナの初期化とターゲット情報の更新
        if (typeof initializeSimulationView === 'function') {
            initializeSimulationView(gacha);
        }
    } else {
        simContainer.style.display = 'none';
        toggleSimBtn.textContent = 'シミュレーションを表示';
    }

    // 入力フォームへの反映
    document.getElementById('seedInput').value = p.seed;
    const isComplete = (p.comp === 'true');
    document.getElementById('featuredCompleteCheckbox').checked = isComplete;
    
    // ガチャ設定に応じた目玉・確定枠の表示制御
    if (gacha.featuredItemStock === 0) {
        document.getElementById('featuredCompleteCheckbox').checked = true;
        document.getElementById('featuredCompleteCheckbox').parentElement.classList.add('hidden-control');
    } else {
        document.getElementById('featuredCompleteCheckbox').parentElement.classList.remove('hidden-control');
    }
    
    const isComp = document.getElementById('featuredCompleteCheckbox').checked;
    const stockControl = document.getElementById('stockControl');
    const guaranteedControl = document.getElementById('guaranteedControl');
    const legendDisplay = document.getElementById('legendDisplay');
    const legendCommon = document.getElementById('legendCommon');

    populateFeaturedStockInput(p.gacha, p.fs);

    if (isComp) {
        stockControl.classList.add('hidden-control');
        if (gacha.uberGuaranteedFlag || gacha.legendGuaranteedFlag) {
            guaranteedControl.classList.remove('hidden-control');
            legendDisplay.classList.remove('hidden-control');
            populateGuaranteedRolls(10, p.ng);
        } else {
            guaranteedControl.classList.add('hidden-control');
            legendDisplay.classList.add('hidden-control');
        }
        legendCommon.style.display = 'inline-block';
    } else {
        stockControl.classList.remove('hidden-control');
        guaranteedControl.classList.remove('hidden-control');
        legendDisplay.classList.remove('hidden-control');
        populateGuaranteedRolls(gacha.guaranteedCycle || 30, p.ng);
        legendCommon.style.display = 'none';
    }

    // 直前アイテム表示
    const lastRollDisplay = document.getElementById('lastRollDisplay');
    if (p.lr && itemMaster[p.lr]) {
        lastRollDisplay.textContent = `LastRoll: ${itemMaster[p.lr].name}`;
    } else {
        lastRollDisplay.textContent = '';
    }

    // SEED表示トグルボタンのテキスト更新
    const toggleSeedBtn = document.getElementById('toggleSeedBtn');
    if (p.displaySeed === '1') {
        toggleSeedBtn.textContent = 'SEEDを非表示';
    } else {
        toggleSeedBtn.textContent = 'SEEDを表示';
    }

    // ブラウザのURL履歴を更新
    const newParams = {
        gacha: p.gacha, seed: p.seed, ng: p.ng, fs: p.fs, lr: p.lr,
        comp: isComp ? 'true' : 'false',
        tx: (p.tx === '1' || (!hideSeedInput && !document.getElementById('seedRow').classList.contains('hidden-control'))) ? '1' : '0',
        roll: p.roll, displaySeed: p.displaySeed, displaySim: p.displaySim
    };
    const newQuery = generateUrlQuery(newParams);
    window.history.replaceState({ path: newQuery }, '', `${window.location.pathname}${newQuery}`);

    // 各種ビュー（テーブル描画）の実行
    const seedValue = parseInt(p.seed, 10);
    const lastRollId = p.lr ? parseInt(p.lr, 10) : null;
    const rows = parseInt(p.roll, 10);
    const thresholds = {
        '0': gacha.rarityRates['0'],
        '1': gacha.rarityRates['0'] + gacha.rarityRates['1'],
        '2': gacha.rarityRates['0'] + gacha.rarityRates['1'] + gacha.rarityRates['2'],
        '3': gacha.rarityRates['0'] + gacha.rarityRates['1'] + gacha.rarityRates['2'] + gacha.rarityRates['3'],
        '4': 10000
    };

    if (isComp) {
        createAndDisplayCompletedSeedView(seedValue, gacha, rows, thresholds, lastRollId, p.displaySeed, new URLSearchParams(newQuery), p.ng);
    } else {
        createAndDisplayUncompletedSeedView(seedValue, gacha, rows, thresholds, lastRollId, p.displaySeed, new URLSearchParams(newQuery));
    }
}

/**
 * 確定枠セレクトボックスの生成
 */
function populateGuaranteedRolls(max, currentVal) {
    const input = document.getElementById('guaranteedRollsInput');
    input.innerHTML = '';
    const unsetOption = document.createElement('option');
    unsetOption.value = 'none'; unsetOption.textContent = '未設定'; input.appendChild(unsetOption);
    for (let i = 1; i <= max; i++) {
        const option = document.createElement('option');
        option.value = i; option.textContent = i; input.appendChild(option);
    }
    if (currentVal && input.querySelector(`option[value="${currentVal}"]`)) {
        input.value = currentVal;
    } else {
        input.value = 'none';
    }
}

/**
 * 目玉在庫数セレクトボックスの生成
 */
function populateFeaturedStockInput(gachaId, preferredValue) {
    const gacha = gachaMaster[gachaId];
    const input = document.getElementById('featuredStockInput');
    if (!gacha) return;
    input.innerHTML = '';
    const unsetOption = document.createElement('option');
    unsetOption.value = 'none'; unsetOption.textContent = '-'; input.appendChild(unsetOption);
    for (let i = 1; i <= gacha.featuredItemStock; i++) {
        const option = document.createElement('option');
        option.value = i; option.textContent = i; input.appendChild(option);
    }
    if (preferredValue && preferredValue !== 'none' && input.querySelector(`option[value="${preferredValue}"]`)) {
        input.value = preferredValue;
    } else {
        input.value = 'none';
    }
}

/**
 * SEED入力欄の表示/非表示トグル
 */
function toggleSeedInput() {
    const seedRow = document.getElementById('seedRow');
    if (seedRow.classList.contains('hidden-control')) {
        seedRow.classList.remove('hidden-control');
    } else {
        seedRow.classList.add('hidden-control');
    }
}

// イベントリスナーの設定
document.addEventListener('DOMContentLoaded', () => {
    // ユーティリティによる初期化
    setupGachaRarityItems();

    // 各UI要素のイベント紐付け
    document.getElementById('executeButton').addEventListener('click', () => {
        runSimulationAndDisplay({ hideSeedInput: true, uiOverrides: { seed: document.getElementById('seedInput').value } });
    });
    
    document.getElementById('guaranteedRollsInput').addEventListener('change', (e) => {
        runSimulationAndDisplay({ uiOverrides: { guaranteedRolls: e.target.value } });
    });
    
    document.getElementById('featuredStockInput').addEventListener('change', (e) => {
        runSimulationAndDisplay({ uiOverrides: { featuredStock: e.target.value } });
    });
    
    document.getElementById('featuredCompleteCheckbox').addEventListener('change', () => {
        runSimulationAndDisplay({ uiOverrides: { isComplete: document.getElementById('featuredCompleteCheckbox').checked } });
    });
    
    document.getElementById('toggleSeedBtn').addEventListener('click', () => {
        const params = new URLSearchParams(window.location.search);
        const current = params.get('displaySeed') === '1' ? '0' : '1';
        runSimulationAndDisplay({ uiOverrides: { displaySeed: current } });
    });

    document.getElementById('toggleSimBtn').addEventListener('click', () => {
        const params = new URLSearchParams(window.location.search);
        const current = params.get('displaySim') === '1' ? '0' : '1';
        runSimulationAndDisplay({ uiOverrides: { displaySim: current } });
    });

    document.getElementById('copySeedLink').addEventListener('click', (event) => {
        event.preventDefault();
        const seedToCopy = new URLSearchParams(window.location.search).get('seed');
        if (seedToCopy && navigator.clipboard) {
            navigator.clipboard.writeText(seedToCopy).then(() => {
                const originalText = event.target.textContent;
                event.target.textContent = 'Copied!';
                setTimeout(() => { event.target.textContent = originalText; }, 1500);
            });
        }
    });

    document.getElementById('result-table-container').addEventListener('click', (event) => {
        if (event.target.id === 'forceRerollToggle') {
            window.forceRerollMode = !window.forceRerollMode;
            runSimulationAndDisplay();
        }
    });

    document.getElementById('showSeedInputLink').addEventListener('click', (e) => {
        e.preventDefault();
        toggleSeedInput();
    });

    // ハイライトモードの適用
    const applyHighlightMode = () => {
         const table = document.querySelector('#result-table-container table');
         if (!table) return;
         table.classList.remove('mode-single', 'mode-multi');
         if (currentHighlightMode === 'single') table.classList.add('mode-single');
         if (currentHighlightMode === 'multi') table.classList.add('mode-multi');
    };

    document.getElementById('legendSingle').addEventListener('click', () => {
        if (document.getElementById('featuredCompleteCheckbox').checked) {
            currentHighlightMode = (currentHighlightMode === 'single') ? 'all' : 'single';
            applyHighlightMode();
        }
    });

    document.getElementById('legendMulti').addEventListener('click', () => {
        if (document.getElementById('featuredCompleteCheckbox').checked) {
            currentHighlightMode = (currentHighlightMode === 'multi') ? 'all' : 'multi';
            applyHighlightMode();
        }
    });

    // 初回実行
    runSimulationAndDisplay();
});

====================
FILE: master.js
====================
/**
 * 担当: ガチャ設定およびアイテム情報のマスターデータ定義
 * 依存関係: なし
 */

// --- マスターデータ ---
//'0': NORMAL_CHANCE, '1': RARE_CHANCE, '2': SUPER_CHANCE, '3': UBER_CHANCE, '4': LEGEND_CHANCE /合計10000【要確認】

const gachaMaster = {
    '34': { name: '(旧)ハロウィン',
            featuredItemRate: 600,
            featuredItemStock: 5,
            guaranteedCycle: 30,
            uberGuaranteedFlag: false,
            legendGuaranteedFlag: false,
            rarityRates: { '0': 2000, '1': 5000, '2': 3000, '3': 0, '4': 0 },
            pool: [0, 2, 3, 4, 5, 10, 11, 12, 14] },

    '42': { name: '1.1億DL記念',
            featuredItemRate: 500,
            featuredItemStock: 5,
            guaranteedCycle: 30,
            uberGuaranteedFlag: false,
            legendGuaranteedFlag: false,
            rarityRates: { '0': 1000, '1': 5000, '2': 3000, '3': 1000, '4': 0 },
            pool: [0, 2, 3, 4, 5, 10, 11, 12, 14, 375, 381, 689] },

    '44': { name: 'ハロウィン',
            featuredItemRate: 500,
            featuredItemStock: 8,
            guaranteedCycle: 30,
            uberGuaranteedFlag: false,
            legendGuaranteedFlag: false,
            rarityRates: { '0': 2000, '1': 4900, '2': 3000, '3': 0, '4': 100 },
            pool: [0, 2, 3, 4, 5, 10, 11, 12, 14, 18] },
            
    '45': { name: 'にゃんこレンジャー',
            featuredItemRate: 0,
            featuredItemStock: 0,
            guaranteedCycle: 10,
            uberGuaranteedFlag: true,
            legendGuaranteedFlag: false,
            rarityRates: { '0': 0, '1': 7000, '2': 2300, '3': 500, '4': 200 },
            pool: [0,2,3,4,5,11,12,14,197,184,375,726,831] },

    '46': { name: '春節',
            featuredItemRate: 0,
            featuredItemStock: 0,
            guaranteedCycle: 10,
            uberGuaranteedFlag: true,
            legendGuaranteedFlag: false,
            rarityRates: { '0': 800, '1': 5000, '2': 3000, '3': 1000, '4': 200 },
            pool: [10,0,3,11,12,2,4,5,14,730,646,202,197] }
};

const itemMaster = {
    0: { name: "スピダ", rarity: 1 },
    2: { name: "ネコボン", rarity: 2 },
    3: { name: "ニャンピュ", rarity: 1 },
    4: { name: "おかめ", rarity: 2 },
    5: { name: "スニャ", rarity: 2 },
    10: { name: "5千XP", rarity: 0 },
    11: { name: "1万XP", rarity: 1 },
    12: { name: "3万XP", rarity: 1 },
    14: { name: "10万XP", rarity: 2 },
    18: { name: "200万XP", rarity: 4 },
    197: { name: "100万XP", rarity: 4 },
    184: { name: "ミスターニンジャ", rarity: 3 },
    202: { name: "ネコ小籠包", rarity: 3 },
    375: { name: "記念ネコ", rarity: 3 },
    381: { name: "ねこ農家", rarity: 3 },
    646: { name: "爆竹ネコ", rarity: 3 },
    689: { name: "石の上にも10年ネコ", rarity: 3 },
    726: { name: "ネコメダル王", rarity: 3 },
    730: { name: "古びたタマゴ:N204", rarity: 3 },
    831: { name: "スカーフにゃんこ", rarity: 3 }
};

====================
FILE: style.css
====================
/**
 * 担当: テーブルレイアウト、ハイライト色、UI要素、ポップアップのスタイリング定義
 */
 
 body {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
    line-height: 1.2;
    padding: 5px;
    max-width: 1200px;
    margin: 0 auto;
    background-color: #f4f7f9;
    color: #333;
    font-size: 9px;
}
.container {
    background: #fff;
    padding: 10px;
    border-radius: 12px;
    box-shadow: 0 6px 15px rgba(0, 0, 0, 0.1);
}
h1 {
    color: #004085;
    font-size: 0.9rem;
    border-bottom: 1px solid #e9ecef;
    padding-bottom: 3px;
    margin-top: 0;
    text-align: center;
}
.controls {
    display: flex;
    flex-direction: column;
    gap: 5px;
    margin-bottom: 10px;
    padding: 8px;
    background-color: #f9fbfd;
    border-radius: 4px;
}
.row {
    display: flex;
    flex-wrap: wrap;
    justify-content: space-between;
    gap: 5px;
    align-items: center;
}
.control-group-left, .control-group-right {
    display: flex;
    align-items: center;
    gap: 15px;
}
.input-item {
    flex: 0 1 auto;
    display: flex;
    flex-direction: row;
    align-items: center;
    gap: 3px;
}
.input-item-display-only {
    flex: 0 1 auto;
    display: flex;
    align-items: center;
    font-size: 0.7rem;
    color: #555;
    padding: 0 5px;
}
.input-item-seed {
    display: flex;
    flex-direction: row;
    align-items: center;
    gap: 3px;
}
.seed-input-group {
    display: flex;
    align-items: center;
    gap: 5px;
    flex: 1 1 200px;
}
label {
    font-weight: 600;
    color: #555;
}
input[type="number"],
select {
    padding: 3px;
    border: 1px solid #ccc;
    border-radius: 3px;
    font-size: 0.8rem;
    width: 100%;
    box-sizing: border-box;
    transition: border-color 0.3s;
}
input[type="number"]:focus,
select:focus {
    outline: none;
    border-color: #007bff;
}
button {
    flex-shrink: 0;
    width: auto;
    padding: 5px 10px;
    background-color: #007bff;
    color: #fff;
    border: none;
    border-radius: 3px;
    cursor: pointer;
    font-size: 0.8rem;
    font-weight: bold;
    transition: background-color 0.3s ease, transform 0.2s ease;
}
button:hover {
    background-color: #0056b3;
}
.hidden-control {
    display: none !important;
}
#showSeedInputLink {
    color: #007bff;
    text-decoration: underline;
    cursor: pointer;
    padding: 0 5px;
    font-weight: bold;
}
#copySeedLink {
    color: #007bff;
    text-decoration: underline;
    cursor: pointer;
    white-space: nowrap;
}

#result-container {
    margin-top: 15px;
}
#result-table-container {
    overflow-x: auto;
    border: 1px solid #e0e0e0;
    border-radius: 8px;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
}
table {
    width: 100%;
    border-collapse: collapse;
}
th, td {
    padding: 4px;
    text-align: center;
    border: 1px solid #e0e0e0;
    word-break: break-all;
    font-size: 0.8rem;
}
th {
    background-color: #f0f4f7;
    color: #444;
    font-weight: 600;
    position: sticky;
    top: 0;
    z-index: 10;
}

/* 列幅の固定設定 */
.col-no {
    width: 35px;
}
.data-col {
    width: 85px; /* A, AG, B, BG列を同じ幅に統一 */
}
.col-seed {
    width: 105px; /* SEED列の幅を必要最小限に */
    font-family: monospace;
    font-size: 0.75rem;
    background-color: #fdfdfd;
}

/* アイテム装飾 */
.featuredItem-text {
    color: #d9534f;
    font-weight: bold;
}
.legendItem-text {
    color: #0000ff;
    font-weight: bold;
}
#result-table-container td a {
    color: inherit;
    text-decoration: none;
    cursor: pointer;
}
/* SEED表示時、アイテム名をリンク風に見せる（ポップアップ用） */
.clickable-item {
    color: #007bff !important;
    text-decoration: underline !important;
}

/* 凡例 */
.legend-box {
    padding: 2px 5px;
    border-radius: 3px;
    margin-left: 5px;
    cursor: pointer;
    border: 1px solid transparent;
}
.legend-box:hover {
    border: 1px solid #999;
}
.legend-single { background-color: #e0f7ff; }
.legend-multi { background-color: #ffffe0; }
.legend-common { background-color: #dfffb0; }

/* ハイライト */
.highlight-roll { background-color: #e0f7ff !important; }
.highlight-roll-10pull { background-color: #ffffe0 !important; }
.highlight-roll-overlap { background-color: #dfffb0 !important; }
.highlight-roll-dark { background-color: #80d8ff !important; }
.highlight-roll-10pull-dark { background-color: #ffff8d !important; }
.highlight-roll-overlap-dark { background-color: #b9f6ca !important; }

/* ポップアップ（モーダル） */
.popup-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.6);
    display: none;
    justify-content: center;
    align-items: center;
    z-index: 2000;
}
.popup-modal {
    background-color: #fff;
    padding: 20px;
    border-radius: 8px;
    box-shadow: 0 5px 20px rgba(0,0,0,0.3);
    max-width: 600px;
    width: 90%;
    max-height: 85vh;
    overflow-y: auto;
    position: relative;
    font-size: 0.85rem;
    line-height: 1.5;
}
.popup-close-btn {
    position: absolute;
    top: 10px;
    right: 15px;
    cursor: pointer;
    font-size: 1.5rem;
    font-weight: bold;
    color: #999;
}
.popup-close-btn:hover {
    color: #333;
}
.popup-details h3 {
    margin-top: 0;
    color: #004085;
    border-bottom: 2px solid #007bff;
    padding-bottom: 5px;
}
.popup-details h4 {
    margin: 15px 0 5px 0;
    background-color: #f0f4f7;
    padding: 3px 8px;
    border-left: 4px solid #6c757d;
}
.seed-comparison-error {
    color: #d9534f;
    font-weight: bold;
    background-color: #fff5f5;
    padding: 5px;
    border: 1px solid #d9534f;
    margin-top: 10px;
}

#calculation-details {
    font-family: monospace;
    font-size: 11px;
    line-height: 1.4;
    margin-top: 15px;
    padding: 10px;
    border: 1px solid #ccc;
    border-radius: 5px;
    background: #f9f9f9;
}

.scroll-buttons button {
    font-size: 0.75rem;
    background-color: #28a745;
}
.scroll-buttons button:hover {
    background-color: #218838;
}

/* シミュレーションUI */
#sim-ui-group {
    margin-bottom: 15px;
}

====================
FILE: utils.js
====================
/**
 * 担当: URLクエリ生成、乱数生成、共有の表示補助等の汎用ユーティリティ関数
 * 依存関係: master.js (itemMaster/gachaMasterの参照)
 */

// --- ユーティリティ関数 ---

/**
 * URLSearchParamsオブジェクトからクエリ文字列を生成する
 */
function generateUrlQuery(p) {
    const query = new URLSearchParams();
    for (const key in p) {
        if (p[key] !== null && p[key] !== undefined) {
            query.set(key, p[key]);
        }
    }
    return '?' + query.toString();
}

/**
 * 32bit Xorshiftによる乱数生成（次シード算出）
 */
function xorshift32(seed) {
    let x = seed;
    x ^= x << 13;
    x ^= x >>> 17;
    x ^= x << 15;
    return x >>> 0;
}

/**
 * マスターデータのpool情報をレアリティ別に分類する初期化処理
 * 修正内容: IDによるソートを削除し、定義順（マスターの並び順）を維持します。
 */
function setupGachaRarityItems() {
    for (const gachaId in gachaMaster) {
        const gacha = gachaMaster[gachaId];
        if (gacha && gacha.pool) {
            // 各レアリティのコンテナを初期化
            gacha.rarityItems = { '0': [], '1': [], '2': [], '3': [], '4': [] };
            
            // pool配列に出現する順番で各レアリティに振り分ける
            for (const itemId of gacha.pool) {
                const item = itemMaster[itemId];
                if (item && gacha.rarityItems[item.rarity.toString()] !== undefined) {
                    gacha.rarityItems[item.rarity.toString()].push(itemId);
                }
            }
            
            // 重要: ここでの .sort() を削除しました。
            // これにより、gachaMaster[id].pool の定義順がスロット順になります。
        }
    }
}

/**
 * デバッグ用：マスター情報のHTMLを生成
 */
function generateMasterInfoHtml(gacha) {
    let html = `<h2>＜マスター情報＞</h2>`;
    html += `(ガチャ) ${gacha.name}(ID:${window.activeGachaId || '?'})<br>`;
    html += `(目玉) ${gacha.featuredItemRate > 0}(レート:${gacha.featuredItemRate}, 初期残数:${gacha.featuredItemStock})<br>`;
    html += `(確定) 超激:${gacha.uberGuaranteedFlag}, 伝説:${gacha.legendGuaranteedFlag}<br>`;
    
    const r = gacha.rarityRates;
    const r0 = r['0'];
    const t1 = r0;
    const t2 = r0 + r['1'];
    const t3 = t2 + r['2'];
    const t4 = t3 + r['3'];
    
    let rateStr = `(レート) `;
    if (r0 === 0) rateStr += `0(ノーマル)-, `;
    else rateStr += `0(ノーマル)～${t1-1}, `;
    rateStr += `1(レア)～${t2-1}, `;
    rateStr += `2(激レア)～${t3-1}, `;
    rateStr += `3(超激レア)～${t4-1}, `;
    rateStr += `4(伝説レア)～9999`;
    html += rateStr + `<br>`;
    
    html += `(各レアリティ別アイテム ※スロット順)<br>`;
    const rarities = ['0.ノーマル', '1.レア', '2.激レア', '3.超激レア', '4.伝説レア'];
    for (let i = 0; i <= 4; i++) {
        const pool = gacha.rarityItems[i.toString()];
        if (pool && pool.length > 0) {
            const itemsStr = pool.map(id => `${itemMaster[id].name}(ID:${id})`).join(', ');
            html += `${rarities[i]}(${pool.length}種) ${itemsStr}<br>`;
        }
    }
    return html + '<br>';
}

/**
 * アイテム比較情報の整形（コンプ済み表示用）
 */
function getFormattedItemComparison(nodeItemName, nodeItemId, nodeRarityId, prevItemId, comparisonTargetName) {
    const rComp = (nodeRarityId === 1) ? '1=1' : `${nodeRarityId}≠1`;
    let idComp = '';
    let targetDisplay = comparisonTargetName ? comparisonTargetName : (prevItemId === -1 ? 'Null' : `${prevItemId}`);

    if (prevItemId === -1) {
         idComp = (nodeItemId === -1) ? '=Null' : '≠Null'; 
    } else {
         idComp = (nodeItemId === prevItemId) ? `=${targetDisplay}` : `≠${targetDisplay}`;
    }
    
    const text = `${nodeItemName}(${nodeItemId}(${rComp})${idComp})`;
    return { text, isDupe: (nodeRarityId === 1 && nodeItemId !== -1 && nodeItemId === prevItemId) };
}

/**
 * アイテムリンク生成ヘルパー
 */
function generateItemLink(baseParams, newSeed, newItemId, ngVal, rollNumberInSequence, isCompleted, fsVal) {
    const gId = window.activeGachaId;
    const paramsForQuery = {};
    
    // baseParams (URLSearchParams) から現在の値をコピー
    for (const [key, value] of baseParams.entries()) {
        paramsForQuery[key] = value;
    }
    
    if (!paramsForQuery.gacha) paramsForQuery.gacha = gId;

    paramsForQuery.seed = newSeed;
    if (newItemId !== undefined) paramsForQuery.lr = newItemId;
    
    if (fsVal !== undefined && fsVal !== null && !isNaN(fsVal)) {
        paramsForQuery.fs = fsVal;
    }

    if (ngVal !== undefined && ngVal !== null) {
        paramsForQuery.ng = ngVal.toString();
    }
    
    return generateUrlQuery(paramsForQuery);
}

====================
FILE: view-completed.js
====================
/**
 * 担当: 「コンプ済み」ビューのメインテーブル描画およびポップアップ制御
 */

let viewData = {
    calculatedData: null,
    gacha: null,
    initialLastRollId: null,
};

function showCalculationPopup(nodeIndex, isGuaranteed, linkSeeds) {
    if (nodeIndex === undefined || viewData.calculatedData === null) return;
    const node = viewData.calculatedData.Nodes[nodeIndex];
    if (!node) return;

    const popupOverlay = document.getElementById('seed-popup-overlay');
    const popupContent = document.getElementById('popup-content');
    const html = generateNodeCalculationDetailsHtml(
        node, viewData.gacha, viewData.calculatedData.thresholds,
        viewData.initialLastRollId, viewData.calculatedData.Nodes,
        linkSeeds, isGuaranteed
    );
    popupContent.innerHTML = html;
    popupOverlay.style.display = 'flex';
}

function setupPopupHandlers() {
    const popupOverlay = document.getElementById('seed-popup-overlay');
    const closeBtn = document.querySelector('.popup-close-btn');
    const copyBtn = document.getElementById('copy-popup-content-btn');
    if (!popupOverlay || !closeBtn) return;

    const hidePopup = () => { popupOverlay.style.display = 'none'; };
    if (!window.hasEscListener) {
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && popupOverlay.style.display === 'flex') hidePopup();
        });
        window.hasEscListener = true;
    }

    if (!popupOverlay.dataset.handlerAttached) {
        popupOverlay.addEventListener('click', (e) => { if (e.target === popupOverlay) hidePopup(); });
        closeBtn.addEventListener('click', hidePopup);
        if (copyBtn) {
            copyBtn.onclick = () => {
                const text = document.getElementById('popup-content').innerText;
                navigator.clipboard.writeText(text).then(() => {
                    const original = copyBtn.textContent;
                    copyBtn.textContent = 'コピー完了';
                    setTimeout(() => { copyBtn.textContent = original; }, 1500);
                });
            };
        }
        popupOverlay.dataset.handlerAttached = 'true';
    }
}

function createAndDisplayCompletedSeedView(initialSeed, gacha, tableRows, thresholds, initialLastRollId, displaySeed, params, initialNg) {
    setupPopupHandlers();
    const { Nodes, highlightInfo } = calculateCompletedData(initialSeed, gacha, tableRows, thresholds, initialLastRollId, initialNg);

    viewData.calculatedData = { Nodes, highlightInfo, thresholds };
    viewData.gacha = gacha;
    viewData.initialLastRollId = initialLastRollId;

    const getAddress = (n) => getAddressStringGeneric(n, 2);
    const currentParams = new URLSearchParams(window.location.search);
    let table = `<table style="table-layout: fixed;" class="${currentHighlightMode === 'single' ? 'mode-single' : (currentHighlightMode === 'multi' ? 'mode-multi' : '')}">`;
    table += '<thead>';
    const header = (displaySeed === '1') 
        ? `<tr><th id="forceRerollToggle" class="col-no">#</th><th class="col-seed">SEED</th><th>A</th><th>AG</th><th class="col-seed">SEED</th><th>B</th><th>BG</th></tr>`
        : `<tr><th id="forceRerollToggle" class="col-no">#</th><th>A</th><th>AG</th><th>B</th><th>BG</th></tr>`;
    table += header + '</thead><tbody>';

    for (let r = 1; r <= tableRows; r++) {
        const nodeIdxA = (r - 1) * 2 + 1;
        const nodeIdxB = (r - 1) * 2 + 2;
        const nodeA = Nodes[nodeIdxA - 1];
        const nodeB = Nodes[nodeIdxB - 1];
        if (!nodeA || !nodeB) break;

        table += `<tr><td class="col-no">${r}</td>`;

        const renderCell = (node, isGuar) => {
            const addr = node.address + (isGuar ? 'G' : '');
            const info = highlightInfo.get(addr);
            
            let cls = determineHighlightClass(info);
            const isPartnerRR = (node.reRollFlag || node.reRerollFlag);
            
            let linkSeeds = {
                normal: node.seed2, 
                reroll: isPartnerRR ? node.seed3 : null, 
                avoid: node.seed2,
                cycleHeadSeed: (info && info.gRaritySeed) ? info.gRaritySeed : null,
                cycleHeadIdx: (info && info.cycleHeadIdx) ? info.cycleHeadIdx : null
            };

            const getFmt = (id, skipStyle = false) => {
                if (id === undefined || id === null || id === -1) return '---';
                const name = getItemNameSafe(id);
                if (skipStyle) return name;
                
                const item = itemMaster[id];
                if (!item) return name;
                if (item.rarity === 3) return `<span style="color:#d9534f; font-weight:bold;">${name}</span>`;
                if (item.rarity === 4) return `<span style="color:#0000ff; font-weight:bold;">${name}</span>`;
                return name;
            };

            const buildStaticItemDisplay = (isGuaranteedColumn) => {
                if (isGuaranteedColumn) {
                    const base = getFmt(node.itemGId, true);
                    if (isPartnerRR) {
                        const poolG = gacha.rarityItems[node.rarityGId] || [];
                        const itemG_rr_Id = poolG[node.seed2 % Math.max(1, poolG.length)];
                        return `${base}<br>${getFmt(itemG_rr_Id, true)}`;
                    }
                    return base;
                } else {
                    const base = getFmt(node.itemId);
                    if (isPartnerRR) {
                        return `${base}<br>${getAddress(node.index + 3)}) ${getFmt(node.reRollItemId)}`;
                    }
                    return base;
                }
            };

            let displayHtml = '---';
            if (node.itemId !== -1) {
                const nameHtml = buildStaticItemDisplay(isGuar);

                if (displaySeed === '1') {
                    const json = JSON.stringify(linkSeeds).replace(/"/g, '&quot;');
                    displayHtml = `<a href="#" onclick="showCalculationPopup(${node.index - 1}, ${isGuar}, ${json}); return false;">${nameHtml}</a>`;
                } else {
                    // リンク先シードの計算ロジック（単発遷移）
                    const lSeed = isGuar ? (isPartnerRR ? node.seed3 : node.seed2) : (isPartnerRR ? node.seed3 : node.seed2);
                    const lId = isGuar ? (isPartnerRR ? (gacha.rarityItems[node.rarityGId] || [])[node.seed2 % Math.max(1, (gacha.rarityItems[node.rarityGId] || []).length)] : node.itemGId) : (isPartnerRR ? node.reRollItemId : node.itemId);
                    displayHtml = `<a href="${generateItemLink(currentParams, lSeed, lId, initialNg, r, true)}">${nameHtml}</a>`;
                }
            }
            return { html: `<td class="${cls || ''}">${displayHtml}</td>` };
        };

        const cA = renderCell(nodeA, false); const cAG = renderCell(nodeA, true);
        const cB = renderCell(nodeB, false); const cBG = renderCell(nodeB, true);

        if (displaySeed === '1') {
            table += `<td class="col-seed">${nodeA.seed1} [${nodeA.index}]</td>${cA.html}${cAG.html}<td class="col-seed">${nodeB.seed1} [${nodeB.index}]</td>${cB.html}${cBG.html}`;
        } else {
            table += cA.html + cAG.html + cB.html + cBG.html;
        }
        table += '</tr>';
    }
    table += '</tbody></table>';
    document.getElementById('result-table-container').innerHTML = table;
}

====================
FILE: view-simulation.js
====================
/**
 * 担当: シミュレーションUIの構築、ターゲット選択管理、および結果の描画
 */

/**
 * シミュレーション表示エリアの初期化
 */
function initializeSimulationView(gacha) {
    const simContainer = document.getElementById('sim-ui-container');
    if (!simContainer) return;

    // 既存の内容をクリアして再構築
    simContainer.innerHTML = '';
    simContainer.dataset.initialized = 'true';

    const simGroup = document.createElement('div');
    simGroup.id = 'sim-ui-group';
    simGroup.style.padding = '15px';
    simGroup.style.background = '#eef6ff';
    simGroup.style.borderRadius = '8px';
    simGroup.style.border = '1px solid #bdd7ff';
    simGroup.style.marginTop = '10px';

    // 上部コントロール行（チケット、開始、コピー）
    const controlRow = document.createElement('div');
    controlRow.style.display = 'flex';
    controlRow.style.alignItems = 'center';
    controlRow.style.flexWrap = 'wrap';
    controlRow.style.gap = '15px';
    controlRow.style.marginBottom = '12px';
    
    controlRow.innerHTML = `
        <div style="display: flex; align-items: center; gap: 5px;">
            <label style="font-size: 0.8rem; font-weight: bold; color: #555;">チケット:</label>
            <input type="number" id="simTicketInput" value="30" min="1" max="1000" 
                   style="width: 60px; padding: 5px; border: 1px solid #ccc; border-radius: 4px;">
        </div>
        <div id="selectedTargetStatus" style="font-size: 0.75rem; color: #0056b3; font-weight: bold; 
             background: #fff; padding: 5px 10px; border-radius: 4px; border: 1px solid #bdd7ff;">
            階層: 1
        </div>
        <button id="runSimBtn" style="background-color: #28a745; color: white; border: none; 
                padding: 7px 15px; border-radius: 4px; cursor: pointer; font-weight: bold;">
            シミュレーション開始
        </button>
        <button id="copySimResultBtn" style="background-color: #6c757d; color: white; border: none; 
                padding: 7px 15px; border-radius: 4px; cursor: pointer; font-weight: bold;">
            結果をコピー
        </button>
    `;
    simGroup.appendChild(controlRow);

    // ターゲット階層コンテナ
    const layersContainer = document.createElement('div');
    layersContainer.id = 'targetLayersContainer';
    simGroup.appendChild(layersContainer);

    // 階層追加ボタン
    const addLayerBtn = document.createElement('button');
    addLayerBtn.id = 'addPriorityLayerBtn';
    addLayerBtn.textContent = '＋ 次順位の階層を追加';
    addLayerBtn.style.marginTop = '10px';
    addLayerBtn.style.fontSize = '0.75rem';
    addLayerBtn.style.padding = '5px 10px';
    addLayerBtn.style.cursor = 'pointer';
    addLayerBtn.style.backgroundColor = '#fff';
    addLayerBtn.style.border = '1px solid #007bff';
    addLayerBtn.style.color = '#007bff';
    addLayerBtn.style.borderRadius = '4px';
    simGroup.appendChild(addLayerBtn);
    
    simContainer.appendChild(simGroup);

    // 結果表示エリア
    const resultDisplay = document.createElement('div');
    resultDisplay.id = 'sim-result-text';
    resultDisplay.style.marginTop = '15px';
    resultDisplay.style.padding = '15px';
    resultDisplay.style.border = '2px dashed #28a745';
    resultDisplay.style.backgroundColor = '#fafffa';
    resultDisplay.style.whiteSpace = 'pre-wrap';
    resultDisplay.style.fontFamily = 'monospace';
    resultDisplay.style.fontSize = '0.85rem';
    resultDisplay.style.display = 'none';
    resultDisplay.style.borderRadius = '8px';
    simContainer.appendChild(resultDisplay);

    // イベント紐付け
    addLayerBtn.onclick = () => createLayerUI(gacha, layersContainer.children.length + 1);
    document.getElementById('runSimBtn').onclick = runSimulation;
    document.getElementById('copySimResultBtn').onclick = copySimResult;

    // 初期階層を作成
    createLayerUI(gacha, 1);
}

/**
 * 優先ターゲット選択用のUI階層を作成
 */
function createLayerUI(gacha, priority) {
    const layersContainer = document.getElementById('targetLayersContainer');
    if (!layersContainer) return;

    const wrapper = document.createElement('div');
    wrapper.className = 'priority-layer-wrapper';
    wrapper.style.marginTop = '12px';
    wrapper.style.padding = '10px';
    wrapper.style.background = '#fff';
    wrapper.style.border = '1px solid #ccc';
    wrapper.style.borderRadius = '6px';

    wrapper.innerHTML = `<div style="font-size: 0.8rem; font-weight: bold; margin-bottom: 8px; color: #004085;">
        【第 ${priority} 優先ターゲット】
    </div>`;

    const area = document.createElement('div');
    area.className = 'layer-selection-area';
    area.dataset.priority = priority;
    area.style.display = 'flex';
    area.style.flexWrap = 'wrap';
    area.style.gap = '10px';
    area.style.maxHeight = '120px';
    area.style.overflowY = 'auto';
    area.style.padding = '5px';

    populateLayerWithOptions(area, gacha);

    wrapper.appendChild(area);
    layersContainer.appendChild(wrapper);

    const status = document.getElementById('selectedTargetStatus');
    if (status) status.textContent = `階層: ${layersContainer.children.length}`;
}

/**
 * 選択エリアにアイテムのチェックボックスを配置
 */
function populateLayerWithOptions(area, gacha) {
    area.innerHTML = '';
    const targetPool = [];
    
    // 全レアリティのアイテムを収集
    Object.keys(gacha.rarityItems).sort((a, b) => parseInt(b) - parseInt(a)).forEach(rid => {
        if (gacha.rarityItems[rid]) targetPool.push(...gacha.rarityItems[rid]);
    });

    // 重複を除去して描画
    Array.from(new Set(targetPool)).forEach(id => {
        const item = itemMaster[id];
        if (!item) return;

        const label = document.createElement('label');
        label.style.fontSize = '0.75rem';
        label.style.display = 'flex';
        label.style.alignItems = 'center';
        label.style.cursor = 'pointer';
        label.style.background = '#f8f9fa';
        label.style.padding = '2px 6px';
        label.style.borderRadius = '3px';
        label.style.border = '1px solid #eee';

        let color = '#333';
        if (item.rarity === 2) color = '#c0a000'; // 激レア
        else if (item.rarity === 3) color = '#d9534f'; // 超激レア
        else if (item.rarity === 4) color = '#0000ff'; // 伝説レア

        label.innerHTML = `
            <input type="checkbox" class="layer-target-checkbox" value="${id}" style="margin-right: 5px;">
            <span style="color: ${color}; font-weight: ${item.rarity >= 3 ? 'bold' : 'normal'};">${item.name}</span>
        `;
        area.appendChild(label);
    });
}

/**
 * ガチャ切り替え時にUI内のアイテムリストを更新
 */
function updateSimGachaItems(gacha) {
    const layers = document.querySelectorAll('.layer-selection-area');
    layers.forEach(area => populateLayerWithOptions(area, gacha));
}

/**
 * ビームサーチを実行し結果を表示
 */
function runSimulation() {
    if (!viewData.calculatedData) {
        alert("表示データがありません。まず「更新」ボタンを押してガチャ結果を表示してください。");
        return;
    }
    
    const { Nodes, thresholds } = viewData.calculatedData;
    const { gacha, initialLastRollId } = viewData;
    const params = new URLSearchParams(window.location.search);
    const initialNg = params.get('ng') || 'none';

    const tickets = parseInt(document.getElementById('simTicketInput').value);
    if (isNaN(tickets) || tickets <= 0) {
        alert("チケット枚数を正しく入力してください。");
        return;
    }

    // 各階層でチェックされたアイテムIDを取得
    const layers = document.querySelectorAll('.layer-selection-area');
    const targetLayers = Array.from(layers).map(area => {
        const checked = area.querySelectorAll('.layer-target-checkbox:checked');
        return Array.from(new Set(Array.from(checked).map(cb => parseInt(cb.value))));
    });

    // ビームサーチ実行 (logic-completed-search.js)
    const result = runGachaBeamSearchCorrected(Nodes, initialLastRollId, tickets, gacha, thresholds, initialNg, targetLayers);
    const display = document.getElementById('sim-result-text');

    if (!result) { 
        display.textContent = "指定されたチケット枚数内でターゲットを獲得できるルートが見つかりませんでした。";
        display.style.display = 'block';
        window.lastSimText = "";
    } else {
        display.innerHTML = "";
        
        // ヘッダー（スコア情報）
        const hdr = document.createElement('div');
        hdr.style.fontWeight = 'bold';
        hdr.style.marginBottom = '12px';
        hdr.style.borderBottom = '1px solid #28a745';
        hdr.style.paddingBottom = '5px';
        
        let statusT = result.layerCounts.map((c, i) => `P${i + 1}:${c}`).join(', ');
        hdr.textContent = `【最適ルート】(獲得数 -> ${statusT} / 超激:${result.ubers} / 伝説:${result.legends})`;
        display.appendChild(hdr);

        let plainText = `【最適ルートシミュレーション結果】(${statusT}, 超激:${result.ubers}, 伝説:${result.legends})\n\n`;
        const path = result.path;
        let i = 0;

        while (i < path.length) {
            const rowC = document.createElement('div');
            rowC.className = 'sim-row';
            rowC.style.display = 'flex';
            rowC.style.gap = '8px';
            rowC.style.marginBottom = '6px';
            rowC.style.alignItems = 'flex-start';

            const cb = document.createElement('input');
            cb.type = 'checkbox';
            cb.style.marginTop = '3px';
            cb.style.cursor = 'pointer';
            
            const span = document.createElement('span');
            span.style.lineHeight = '1.4';

            let rowHeader = "";
            let rowHtml = "";
            let rowPlain = "";

            const getColoredItemHtml = (name) => {
                const itemEntry = Object.values(itemMaster).find(it => it.name === name);
                if (!itemEntry) return name;
                if (itemEntry.rarity === 3) return `<span style="color: #d9534f; font-weight: bold;">${name}</span>`;
                if (itemEntry.rarity === 4) color = `<span style="color: #0000ff; font-weight: bold;">${name}</span>`;
                return name;
            };

            if (path[i].type === 'single') {
                // 連続する単発をまとめる
                let j = i;
                let itemsHtml = [];
                let itemsPlain = [];
                while (j < path.length && path[j].type === 'single') { 
                    itemsHtml.push(getColoredItemHtml(path[j].item));
                    itemsPlain.push(path[j].item); 
                    j++;
                }
                rowHeader = `<span style="color: #007bff; font-weight: bold;">[単発]</span> ${j - i}ロール (${path[i].addr}～):<br>`;
                rowHtml = "　=> " + itemsHtml.join('、');
                rowPlain = `[単発] ${j - i}ロール (${path[i].addr}～) => ` + itemsPlain.join('、');
                i = j;
            } else {
                // 10連
                rowHeader = `<span style="color: #c0a000; font-weight: bold;">[10連]</span> (${path[i].addr}～):<br>`;
                rowHtml = "　=> " + path[i].items.map(n => getColoredItemHtml(n)).join('、');
                rowPlain = `[10連] (${path[i].addr}～) => ` + path[i].items.join('、');
                i++;
            }

            span.innerHTML = rowHeader + rowHtml;
            plainText += rowPlain + "\n";

            // 消し込み（打ち消し線）機能
            cb.onchange = () => { 
                span.style.color = cb.checked ? '#aaa' : '#333';
                span.style.textDecoration = cb.checked ? 'line-through' : 'none'; 
            };

            rowC.appendChild(cb);
            rowC.appendChild(span);
            display.appendChild(rowC);
        }
        
        window.lastSimText = plainText;
        display.style.display = 'block';
    }
}

/**
 * シミュレーション結果をクリップボードにコピー
 */
function copySimResult() {
    if (window.lastSimText && navigator.clipboard) {
        navigator.clipboard.writeText(window.lastSimText).then(() => {
            const btn = document.getElementById('copySimResultBtn');
            const originalText = btn.textContent;
            btn.textContent = 'コピー完了！';
            btn.style.backgroundColor = '#28a745';
            setTimeout(() => { 
                btn.textContent = originalText; 
                btn.style.backgroundColor = '#6c757d';
            }, 1500);
        });
    } else {
        alert("コピーする結果がありません。先にシミュレーションを実行してください。");
    }
}

====================
FILE: view-uncompleted-details.js
====================
/**
 * 担当: 「未コンプ」ビューの下部に表示される計算過程および10連詳細のHTML描画
 * 依存関係: utils.js (generateItemLinkの利用)
 */

/**
 * 詳細テーブル（計算過程）と10連詳細のHTMLを生成してDOMに挿入
 */
function renderUncompletedDetails(Nodes, highlightInfo, maxNodes, tenPullCyclesData, gacha, initialLastRollId, params) {
    const ngVal = parseInt(params.get('ng'), 10);
    const initialFs = parseInt(params.get('fs'), 10) || 0;
    const guaranteedCycle = gacha.guaranteedCycle || 30;
    let ngTrackerDetail = !isNaN(ngVal) && ngVal > 0 ? ngVal : guaranteedCycle;

    // --- 1. 計算詳細 (単発ガチャ詳細) のHTML組み立て ---
    let html = generateMasterInfoHtml(gacha);
    
    let lastRollText = 'Null';
    if (initialLastRollId && itemMaster[initialLastRollId]) {
        lastRollText = `${itemMaster[initialLastRollId].name}(${initialLastRollId}(${itemMaster[initialLastRollId].rarity}))`;
    }

    html += '<h2>＜ノード計算詳細 (No.1～)＞</h2>';
    html += `LastRoll：${lastRollText}<br><br>単発ガチャ詳細<br>`;
    html += '<table style="table-layout: fixed; width: auto; font-size: 9px; border-collapse: collapse;"><thead>';
    html += '<tr style="background-color: #f2f2f2;">';
    html += '<th style="border: 1px solid #ccc; padding: 5px;">No.<br>Address</th><th style="border: 1px solid #ccc; padding: 5px;">Seed<br>(Sn)</th><th style="border: 1px solid #ccc; padding: 5px;">Featured<br>(Sn)</th><th style="border: 1px solid #ccc; padding: 5px;">Rarity<br>(Sn+1)</th><th style="border: 1px solid #ccc; padding: 5px;">Item<br>(Sn+2)</th><th style="border: 1px solid #ccc; padding: 5px;">Reroll<br>(Sn+3)</th><th style="border: 1px solid #ccc; padding: 5px;">ReRollFlag<br>Crnt vs Prev</th><th style="border: 1px solid #ccc; padding: 5px;">Roll<br>(next)</th><th style="border: 1px solid #ccc; padding: 5px;">NextGuar<br>aftRoll</th>'; 
    html += '</tr></thead><tbody>'; 

    for (let i = 1; i <= maxNodes; i++) {
        const node = Nodes[i-1];
        if (!node) continue;
        
        // NGカウンター更新
        let ngContentDetail = '-';
        if (node.singleRoll !== null) {
            let nextNg = ngTrackerDetail - 1;
            if (ngTrackerDetail === 1) { 
                 const nextStartNg = guaranteedCycle - 1; 
                 ngContentDetail = `目玉(確定)<br>${guaranteedCycle}→${nextStartNg}`;
                 ngTrackerDetail = nextStartNg;
            } else if (ngTrackerDetail > 1) {
                ngContentDetail = nextNg.toString();
                ngTrackerDetail = nextNg;
            }
        }
        
        // Highlight logic
        const itemInfo = highlightInfo.get(node.address);
        const baseCls = determineHighlightClass(itemInfo);
        let featuredClsAttr = '', itemClsForNormal = '', itemClsForReroll = '';

        if (itemInfo) {
            if (itemInfo.single && itemInfo.s_featured) featuredClsAttr = ` class="${baseCls}"`; 
            if ((itemInfo.single && !itemInfo.s_reRoll && !itemInfo.s_featured) || (itemInfo.ten && !itemInfo.t_reRoll)) itemClsForNormal = baseCls; 
            if ((itemInfo.single && itemInfo.s_reRoll) || (itemInfo.ten && itemInfo.t_reRoll)) itemClsForReroll = baseCls; 
        }

        // 修正箇所: 変数定義を追加
        const itemClsAttr = itemClsForNormal ? ` class="${itemClsForNormal}"` : '';
        const rerollClsAttr = itemClsForReroll ? ` class="${itemClsForReroll}"` : '';

        // Columns Content
        let singleDisplay = node.singleRoll !== null ? node.singleRoll.toString() : '';
        if (node.singleRoll !== null && node.singleUseSeeds !== null) {
             singleDisplay += `<br>${node.index}+${node.singleUseSeeds}<br>${node.index + node.singleUseSeeds}(${node.singleNextAddr})`;
        }

        // Featured Content
        let featuredContent = node.isFeatured ? 'True' : 'False';
        if (node.isFeatured) {
             const fHref = generateItemLink(node.seed1, -2, node.guaranteedNextNgVal || ngVal, node.index, false, initialFs);
             featuredContent = `<a href="${fHref}" style="text-decoration: none; color: inherit;">True</a>`;
        }
        featuredContent += `<br>S${node.index}%10000<br>${node.seed1 % 10000}${node.isFeatured ? '<' : '>='}${gacha.featuredItemRate}`;

        // Rarity Content
        let rarityContent = `${node.rarityId}(${node.rarity.name})<br>S${node.index + 1}%10000<br><span style="font-size: 80%;">${node.rarityRateRangeDisplay}</span>`;

        // Item & Reroll Content
        let itemContent = '-';
        if (node.itemId !== -1) {
             const nextNg = node.isGuaranteedRoll ? (guaranteedCycle - 1) : ngTrackerDetail;
             const iHref = generateItemLink(node.seed3, node.itemId, nextNg, node.index + 1, false, initialFs);
             let style = node.isFeatured && itemInfo && itemInfo.single ? "color: red; font-weight: bold;" : "";
             if (node.isGuaranteedRoll) {
                 const gHref = generateItemLink(node.prevSeed1, node.singleCompareItemId, guaranteedCycle, node.index, false, initialFs);
                 itemContent = `<a href="${gHref}" class="featuredItem-text">目玉(確定)</a> / <a href="${iHref}">${node.itemName}</a>`;
             } else {
                 itemContent = `<a href="${iHref}" style="${style}">${node.itemName}</a>`;
             }
             itemContent += `<br>S${node.index+2}%${node.poolSize}<br>${node.slot}→ID:${node.itemId}`;
        }

        let rerollContent = '-';
        if (node.reRollItemId !== -1) {
             const nextNg = node.isGuaranteedRoll ? (guaranteedCycle - 1) : ngTrackerDetail;
             const rHref = generateItemLink(node.seed4, node.reRollItemId, nextNg, node.index + 1, false, initialFs);
             rerollContent = `<a href="${rHref}">${node.reRollItemName}</a><br>S${node.index+3}%${node.poolSize>1?node.poolSize-1:0}<br>${node.reRollSlot}→ID:${node.reRollItemId}`;
        }

        // ReRoll Flag (Simplified)
        let reRollFlagContent = node.reRollFlag || '-'; 
        if (!node.reRollFlag && node.singleRoll) {
             reRollFlagContent = node.singleIsReroll ? 'True' : 'False';
             if (node.rarityId===1 && !node.isFeatured) reRollFlagContent += `<br>レア→Yes<br>${node.itemId}vs${node.singleCompareItemId}`;
             else if (node.isFeatured) reRollFlagContent += '<br>目玉→No';
             else reRollFlagContent += '<br>Other→No';
        }

        html += `<tr>
            <td style="border: 1px solid #ccc; padding: 5px; text-align: center;">${node.index}<br>${node.address}</td>
            <td style="border: 1px solid #ccc; padding: 5px; text-align: center; font-family: monospace;">S${node.index}<br>${node.seed1}</td>
            <td style="border: 1px solid #ccc; padding: 5px; text-align: center;"${featuredClsAttr}>${featuredContent}</td>
            <td style="border: 1px solid #ccc; padding: 5px; text-align: center;">${rarityContent}</td>
            <td style="border: 1px solid #ccc; padding: 5px; text-align: center;"${itemClsAttr}>${itemContent}</td>
            <td style="border: 1px solid #ccc; padding: 5px; text-align: center;"${rerollClsAttr}>${rerollContent}</td>
            <td style="border: 1px solid #ccc; padding: 5px; text-align: center;">${reRollFlagContent}</td>
            <td style="border: 1px solid #ccc; padding: 5px; text-align: center;">${singleDisplay}</td>
            <td style="border: 1px solid #ccc; padding: 5px; text-align: center;">${ngContentDetail}</td>
        </tr>`;
    }
    html += '</tbody></table>';

    // --- 2. 10連詳細セクション ---
    if (tenPullCyclesData && tenPullCyclesData.length > 0) {
        html += '<h2 style="margin-top:20px;">＜10連詳細 (現在地からのシミュレーション / 10サイクル)＞</h2>';
        let cumulativeFs = initialFs;
        
        tenPullCyclesData.forEach((cycle, idx) => {
            const count = cycle.featuredCountInCycle || 0;
            cumulativeFs -= count;
            
            html += `<div style="margin-top: 15px; border: 1px solid #000; padding: 10px; background-color: #fcfcfc;">`;
            html += `<h3>【Cycle ${idx + 1}】 (目玉: ${count})</h3>`;
            html += `<p>NG開始: ${cycle.startNgVal}, LastRoll: ${getItemNameSafe(cycle.startLastRollId)}</p>`;
            html += `<p>判定: ${cycle.guaranteedStatus}</p>`;
            
            html += '<h4>[Log]</h4><ul>';
            cycle.processLog.forEach(l => html += `<li style="font-size: 0.8rem;">${l}</li>`);
            html += '</ul>';

            html += '<h4>[Result]</h4><table style="border-collapse: collapse;">';
            cycle.results.forEach(res => {
                const style = res.isGuaranteed || res.isFeatured ? 'color: #d9534f; font-weight: bold;' : '';
                html += `<tr><td style="border: 1px solid #eee;">${res.label}</td><td style="border: 1px solid #eee; ${style}">${res.name}</td></tr>`;
            });
            html += '</table>';

            const linkUrl = generateItemLink(cycle.transition.nextSeed, cycle.transition.lastItemId, cycle.transition.nextNgVal, cycle.transition.nextIndex, false, cumulativeFs);
            html += `<p>Next: ${cycle.transition.nextIndex}(${cycle.transition.nextAddress}) → <a href="${linkUrl}" style="font-weight: bold; color: blue;">遷移する</a></p>`;
            html += '</div>';
        });
    }

    // DOM挿入
    const detailsDiv = document.getElementById('calculation-details'); 
    detailsDiv.innerHTML = html;
}

====================
FILE: view-uncompleted-table.js
====================
/**
 * 担当: 「未コンプ」ビューのメインテーブルおよび期待値情報のHTML描画
 * 依存関係: utils.js (generateItemLinkの利用)
 */

/**
 * 未コンプビューのメインテーブル（期待値表示含む）を生成してDOMに挿入する関数
 * @param {Array} Nodes - 計算済みの全ノードデータ
 * @param {Map} highlightInfo - ハイライト情報（単発ルート、10連ルートの判定用）
 * @param {Array} tenPullCyclesData - 10連シミュレーションの結果データ
 * @param {Object} expectedFeaturedCounts - 期待値データ
 * @param {number} tableRows - 表示する行数
 * @param {string} displaySeed - '1'なら詳細表示、それ以外は通常表示
 * @param {number} initialNg - 初期のNext Guaranteed値
 * @param {number} initialFs - 初期のFeatured Stock値
 * @param {number} guaranteedCycle - 確定周期（通常30）
 */
function renderUncompletedMainTable(Nodes, highlightInfo, tenPullCyclesData, expectedFeaturedCounts, tableRows, displaySeed, initialNg, initialFs, guaranteedCycle) {
    
    // --- ヘルパー関数: アイテムCSS決定 ---
    function determineItemCss(itemId) {
        if (!itemMaster[itemId]) return '';
        if (itemMaster[itemId].rarity === 4) return 'legendItem-text';
        if (itemMaster[itemId].rarity >= 3) return 'featuredItem-text';
        return '';
    }

    // --- 期待値表示エリア ---
    let expectedValueHtml = '<div>';
    if (expectedFeaturedCounts) {
        expectedValueHtml += '<h3>＜単発Nroll後の10連での目玉獲得数予測＞</h3>'; 
        const expectedKeys = Object.keys(expectedFeaturedCounts).sort((a, b) => parseInt(a) - parseInt(b));
        
        const expectedValueText = expectedKeys.map(n => {
            const m = expectedFeaturedCounts[n];
            const rollNum = parseInt(n) + 1; 
            return `${rollNum}roll:<span style="font-weight: bold;">${Math.floor(m)}個</span>`;
        }).join(', ');
        
        expectedValueHtml += `<p style="font-size: 1.1em;">${expectedValueText}</p>`;
    } else {
        expectedValueHtml += '<p>期待値データが見つかりませんでした。</p>';
    }
    expectedValueHtml += '</div><br>';

    // --- テーブルヘッダー生成 ---
    let table = expectedValueHtml;
    table += '<table style="table-layout: fixed;"><thead>';
    
    let header1 = `<tr><th id="forceRerollToggle" class="col-no" style="cursor: pointer;">${window.forceRerollMode ? '☑' : '□'}</th>`;
    header1 += '<th>A</th><th>B</th><th>C</th><th>G</th>';
    header1 += '</tr>';
    table += header1;
    table += '</thead><tbody>';

    // --- メインループ変数の初期化 ---
    let currentNgVal = !isNaN(initialNg) ? initialNg : -1;
    let currentFsVal = initialFs;

    // --- メインループ (各行の生成) ---
    for (let r = 0; r < tableRows; r++) {
        table += `<tr><td class="col-no">${r + 1}</td>`;
        const nodeIndices = [r * 3 + 1, r * 3 + 2, r * 3 + 3]; // 1行あたりA, B, Cの3ノード
        
        // --- A, B, C 列の処理 ---
        nodeIndices.forEach((idx, colIndex) => {
            const node = Nodes[idx - 1];
            if (!node) {
                table += displaySeed === '1' ? '<td colspan="5"></td>' : '<td></td>';
                return;
            }

            const info = highlightInfo.get(node.address);
            let cls = determineHighlightClass(info);
            
            const isSingleRouteNode = info && info.single; // 単発ガチャのルートに存在するノードか
            const isGuaranteedNode = isSingleRouteNode && node.isGuaranteedRoll; // 単発ルートで確定ロールか

            let content = '';
            let linkFs = currentFsVal;
            
            // ReRollFlagの取得
            const nodeReRollFlag = node.reRollFlag; // logic側で計算済みと仮定

            // ----------------------------------------------------------------
            // Case 1: Single Route Logic (単発ガチャルート上のノード)
            // ----------------------------------------------------------------
            if (isSingleRouteNode) {
                 if (isGuaranteedNode) {
                     // 1-A. Guaranteed Roll Processing (確定ノード)
                     // Next NG resets to guaranteedCycle - 1 (例: 29)
                     const nextNg = guaranteedCycle - 1; 

                     // 目玉(確定)リンク (前の状態への遷移、NG=30)
                     const guaranteedLinkSeed = node.prevSeed1; 
                     const guaranteedLinkNg = guaranteedCycle; 
                     const guaranteedLinkFs = initialFs; // FSは減らない(仕様による)
                     const guaranteedHref = generateItemLink(guaranteedLinkSeed, node.singleCompareItemId, guaranteedLinkNg, node.index, false, guaranteedLinkFs);
                     const guaranteedLinkStyle = `text-decoration: none; color: inherit; font-weight: bold;`;
                     const guaranteedLink = `<a href="${guaranteedHref}" class="featuredItem-text" style="${guaranteedLinkStyle}">目玉(確定)</a>`; 

                     // アイテム名リンク (確定ロール後の状態への遷移、NG=29)
                     const itemDisplayName = node.itemName;
                     const itemLinkSeed = node.seed3; // S(n+2)
                     const itemLinkNg = guaranteedCycle - 1; 
                     const itemLinkFs = initialFs;
                     const itemHref = generateItemLink(itemLinkSeed, node.itemId, itemLinkNg, r+1, false, itemLinkFs);
                     const itemLinkStyle = `text-decoration: none; color: inherit; font-weight: normal;"`;
                     const itemNameLink = `<a href="${itemHref}" style="${itemLinkStyle}">${itemDisplayName}</a>`;

                     content = `${guaranteedLink} / ${itemNameLink}`;
                     
                     // 状態更新
                     currentNgVal = guaranteedCycle - 1; // 次のNG値をリセット
                     currentFsVal = linkFs; 

                 } else {
                     // 1-B. Normal Single Route Node (非確定ノード)
                     // 次のノードの開始NG値
                     let nextNg = (currentNgVal !== -1) ? currentNgVal - 1 : 'none';
                     if (nextNg !== 'none' && nextNg <= 0) nextNg = guaranteedCycle;
                     
                     if (node.isFeatured) {
                         // 目玉アイテムの場合
                         linkFs = currentFsVal - 1;
                         const currentSeedVal = node.seed1; 
                         const hrefFeatured = generateItemLink(currentSeedVal, -2, nextNg, r+1, false, linkFs);
                         content = `${node.featuredNextAddress})<a href="${hrefFeatured}"><span class="featuredItem-text">目玉</span></a>`;
                         currentFsVal -= 1; // FSカウンターを減らす
                     } else {
                        // 通常アイテム
                        const isRerollHighlight = info ? info.s_reRoll : false;
                        
                        if (isRerollHighlight) {
                             // 再抽選が行われたケース
                             const preRerollName = node.itemName; 
                             const postRerollId = node.reRollItemId;
                             const postRerollName = node.reRollItemName;
                             
                             // Pre-Reroll Link: S(n+2)
                             const preSeed = node.seed3; 
                             const preHref = generateItemLink(preSeed, node.itemId, nextNg, r+1, false, linkFs);
                             let preCss = determineItemCss(node.itemId);

                             // Post-Reroll Link: S(n+3)
                             const postSeed = node.seed4; 
                             const postHref = generateItemLink(postSeed, postRerollId, nextNg, r+1, false, linkFs);
                             let postCss = determineItemCss(postRerollId);

                             content = `<a href="${preHref}" class="${preCss}">${preRerollName}</a><br>${node.reRollNextAddress})<a href="${postHref}" class="${postCss}">${postRerollName}</a>`;

                        } else {
                             // 通常排出のケース
                             // Item Link: S(n+2)
                             const nextSeed = node.seed3; 
                             const finalId = node.itemId; 
                             const href = generateItemLink(nextSeed, finalId, nextNg, r+1, false, linkFs);
                             let css = determineItemCss(finalId);
                             content = `<a href="${href}" class="${css}">${node.itemName}</a>`;

                             // 再抽選候補リンク (ReRollFlagがTrueの場合、または強制再抽選モードの場合)
                             if (node.reRollItemId !== -1) { 
                                 if (node.singleIsReroll || window.forceRerollMode) { // node.singleIsReroll を参照
                                     // ReRoll Link: S(n+3)
                                     const rrHref = generateItemLink(node.seed4, node.reRollItemId, nextNg, r+1, false, linkFs); 
                                     let rrName = node.reRollItemName;
                                     let rrCss = determineItemCss(node.reRollItemId);
                                     content += `<br>${node.reRollNextAddress})<a href="${rrHref}" class="${rrCss}">${rrName}</a>`;
                                 }
                             }
                        }
                     }
                     // 状態更新
                     if (currentNgVal !== -1) {
                         currentNgVal -= 1; // 通常時は1減らす
                         if (currentNgVal <= 0) currentNgVal = guaranteedCycle;
                     }
                 }
            } else {
                // ----------------------------------------------------------------
                // Case 2: Off-Route Logic (ルート外の共通ロジック)
                // ----------------------------------------------------------------
                // リンクNG値は「次のロールの開始NG値」
                let linkNgVal = (initialNg !== -1) ? initialNg - (r + 1) : 'none';
                if (linkNgVal !== 'none' && linkNgVal <= 0) {
                    // 0以下になった場合、次のロールの開始NG値は guaranteedCycle - 1
                    // (ここでの計算は簡易的なため、厳密なNG追跡が必要ならLogic側で計算してNodeに持たせるのが理想)
                    linkNgVal = guaranteedCycle - 1;
                }
                const linkFsVal = initialFs; 
                
                if (node.isFeatured) {
                    // 目玉アイテムの場合
                    const currentSeed = node.seed1; 
                    const hrefFeatured = generateItemLink(currentSeed, -2, linkNgVal, r+1, false, linkFsVal);
                    content = `${node.featuredNextAddress})<a href="${hrefFeatured}"><span class="featuredItem-text">目玉</span></a>`;
                    
                } else {
                    const finalId = node.itemId;
                    const preRerollName = node.itemName; 
                    
                    // 1. Pre-Reroll / Normal Link: S(n+2)
                    const nextSeedNormal = node.seed3; 
                    const hrefNormal = generateItemLink(nextSeedNormal, finalId, linkNgVal, r+1, false, linkFsVal);
                    let cssNormal = determineItemCss(finalId);

                    content = `<a href="${hrefNormal}" class="${cssNormal}">${preRerollName}</a>`;
                    
                    // 再抽選リンク (重複再抽選フラグがTrueの場合、または強制再抽選モードの場合)
                    if (node.reRollItemId !== -1 && node.isDupe) {
                        if (window.forceRerollMode || (info && info.ten && info.t_reRoll)) { // 10連ルートの再抽選判定などを考慮
                            // 2. Post-Reroll Link: S(n+3)
                            const nextSeedReroll = node.seed4; 
                            const rrId = node.reRollItemId;
                            const rrName = node.reRollItemName;
                            const rrHref = generateItemLink(nextSeedReroll, rrId, linkNgVal, r+1, false, linkFsVal);
                            let rrCss = determineItemCss(rrId);
                            
                            content += `<br>${node.reRollNextAddress})<a href="${rrHref}" class="${rrCss}">${rrName}</a>`;
                        }
                    }
                }
            }

            // --- セルHTML生成 ---
            if (displaySeed === '1' && node) {
                content += `<br><span class="seed-value" style="font-size: 0.7em; color: #888;">${node.seed1}</span>`;
            }
            table += `<td${cls ? ' class="'+cls+'"' : ''}>${content}</td>`;
        });

        // --- G Column Logic (10連ガチャシミュレーション結果) ---
        let gContent = '-';
        let gStyle = '';
        
        const cycleIndex = Math.floor(r / 10);
        const rollIndex = r % 10;
        
        const tenPullDetailData = tenPullCyclesData ? tenPullCyclesData[cycleIndex] : null; 
        
        if (rollIndex < 9) { gStyle = 'background-color: #ffffe0;'; } else if (rollIndex === 9) { gStyle = 'background-color: #ffff8d;'; }

        if (tenPullDetailData && rollIndex < 10) {
            const res = tenPullDetailData.results[rollIndex];
            if (res) {
                let cellName = res.name;
                if (res.isReroll && res.preRerollName) {
                    cellName = `（${res.preRerollName}↓）<br>${cellName}`;
                }
                if (res.isGuaranteed) {
                    cellName = `<span class="featuredItem-text">${cellName}</span>`;
                } else if (res.isFeatured) {
                    cellName = `<span class="featuredItem-text">${cellName}</span>`;
                }

                if (rollIndex === 9) {
                    const addressStr = tenPullDetailData.transition.nextAddress;
                    let nextNg = tenPullDetailData.transition.nextNgVal;
                    
                    if (isNaN(nextNg) || nextNg <= 0) {
                        nextNg = guaranteedCycle - 1; 
                    }
                    
                    let usedFs = tenPullDetailData.featuredCountInCycle || 0;
                    let nextFs = initialFs - usedFs; // ※累積計算は簡易的（このサイクル分のみ減算）

                    const href10 = generateItemLink(
                        tenPullDetailData.transition.nextSeed,
                        tenPullDetailData.transition.lastItemId,
                        nextNg,
                        tenPullDetailData.transition.nextIndex, 
                        false, 
                        nextFs
                    );
                    gContent = `${addressStr})<a href="${href10}">${cellName}</a>`;
                } else {
                    gContent = cellName;
                }
            }
        }
        if (displaySeed === '1' && tenPullDetailData && tenPullDetailData.transition) {
            // 10連シミュレーションの結果がある場合、SEED情報を追記
             gContent += `<br><span class="seed-value" style="font-size: 0.7em; color: #888;">${tenPullDetailData.transition.nextSeed}</span>`;
        }
        table += `<td style="${gStyle}">${gContent}</td>`;
        table += '</tr>';
    }
    table += '</tbody></table>';

    // DOMへの挿入
    document.getElementById('result-table-container').innerHTML = table;
}

====================
FILE: view-uncompleted.js
====================
/**
 * 担当: 「未コンプ」ビュー全体の描画制御および各コンポーネントの呼び出し
 * 依存関係: logic-uncompleted.js, view-uncompleted-table.js, view-uncompleted-details.js
 */

function createAndDisplayUncompletedSeedView(initialSeed, gacha, tableRows, thresholds, initialLastRollId, displaySeed, params) {
    // 1. データ計算 (Logic)
    const { 
        Nodes, highlightInfo, maxNodes, singleRoutePath, 
        tenPullCyclesData, expectedFeaturedCounts 
    } = calculateUncompletedData(initialSeed, gacha, tableRows, thresholds, initialLastRollId, params);
    
    // デバッグ出力
    console.log("Uncompleted Data Calculated:", { Nodes: Nodes.length, tenPullCyclesData, expectedFeaturedCounts });

    // パラメータ取得
    const ngVal = parseInt(params.get('ng'), 10);
    const initialFs = parseInt(params.get('fs'), 10) || 0; 
    const guaranteedCycle = gacha.guaranteedCycle || 30;
    let initialNg = !isNaN(ngVal) && ngVal > 0 ? ngVal : guaranteedCycle;

    // 2. 詳細画面 (Debug View) のレンダリング
    renderUncompletedDetails(Nodes, highlightInfo, maxNodes, tenPullCyclesData, gacha, initialLastRollId, params);

    // 3. メインテーブル (Main View) のレンダリング
    // 注意: view-uncompleted-table.js 内の関数です。元の view-uncompleted.js の複雑なリンク生成ロジックは
    // そちらに移動している前提です。
    renderUncompletedMainTable(Nodes, highlightInfo, tenPullCyclesData, expectedFeaturedCounts, tableRows, displaySeed, initialNg, initialFs, guaranteedCycle);

    // 4. 詳細表示トグルの制御
    const detailsDiv = document.getElementById('calculation-details');
    const detailsControls = document.getElementById('details-controls');
    const toggleBtn = document.getElementById('toggleDetailsBtn');
    const scrollButtons = detailsControls.querySelector('.scroll-buttons');
    if (scrollButtons) scrollButtons.remove();
    
    detailsControls.style.display = 'flex';
    toggleBtn.style.display = 'inline-block'; 
    toggleBtn.onclick = () => {
        if (detailsDiv.style.display === 'none') {
            detailsDiv.style.display = 'block';
            toggleBtn.textContent = '計算過程を非表示';
        } else {
            detailsDiv.style.display = 'none';
            toggleBtn.textContent = '計算過程を表示';
        }
    };
}

