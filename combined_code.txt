====================
FILE: index.html
====================
/**
 * 担当: アプリケーションの全体構造定義と外部リソースの読み込み
 * 依存関係: style.css, master.js, utils.js, logic-*.js, view-*.js, main.js
 */
 
 <!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>イベントガチャロールズ</title>
    <link rel="stylesheet" href="style.css">
    <link rel="icon" href="data:,">
</head>
<body>

<div class="container">
    <h1>イベントガチャロールズ</h1>
    <div class="input-group">
        <div class="controls">
            <div class="row">
                <div class="control-group-left">
                    <div class="input-item">
                         <a id="showSeedInputLink" href="#">SEED入力</a>
                    </div>
                    <div class="input-item" id="guaranteedControl">
                        <label for="guaranteedRollsInput">next guaranteed</label>
                        <select id="guaranteedRollsInput"></select>
                    </div>
                    <div class="input-item" id="legendDisplay" style="font-size: 0.7rem;">
                        <span id="legendSingle" class="legend-box legend-single">単発ルート</span>
                        <span id="legendMulti" class="legend-box legend-multi">10連ルート</span>
                        <span id="legendCommon" class="legend-box legend-common">共通ルート</span>
                    </div>
                    <div id="lastRollDisplay" class="input-item-display-only">
                        </div>
                </div>
                <div class="control-group-right">
                    <div class="input-item">
                        <label for="featuredCompleteCheckbox">コンプ済み</label>
                        <input type="checkbox" id="featuredCompleteCheckbox">
                    </div>
                    <div class="input-item" id="stockControl">
                        <label for="featuredStockInput">目玉残数</label>
                        <select id="featuredStockInput"></select>
                    </div>
                    <a id="copySeedLink" href="#">Copy SEED</a>
                </div>
            </div>
            <div class="row hidden-control" id="seedRow">
                <div class="input-item-seed">
                    <label for="seedInput">SEED</label>
                    <div class="seed-input-group">
                        <input type="number" id="seedInput" value="123456789">
                        <button id="executeButton">更新</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div id="result-container">
        <div id="output"></div>
        <div id="result-table-container"></div>
        <div id="details-controls" style="display: none; margin-top: 10px; align-items: center; gap: 10px;">
            <button id="toggleDetailsBtn">計算過程を表示</button>
            <div class="scroll-buttons" style="display: none;">
                <button id="scrollToSingle">単発ルートへ</button>
                <button id="scrollToMulti">10連ルートへ</button>
            </div>
        </div>
        <div id="calculation-details" style="display:none;"></div>
    </div>
</div>

<script src="master.js"></script>
<script src="utils.js"></script>
<script src="logic-common.js"></script>
<script src="logic-completed.js"></script>
<script src="logic-uncompleted-sim.js"></script>
<script src="logic-uncompleted.js"></script>
<script src="view-completed.js"></script>
<script src="view-uncompleted-details.js"></script>
<script src="view-uncompleted-table.js"></script>
<script src="view-uncompleted.js"></script>

<script src="main.js"></script>

</body>
</html>

====================
FILE: logic-common.js
====================
/**
 * 担当: シード配列生成、レアリティ判定、アドレス計算等の共通計算ロジック
 * 依存関係: utils.js (getItemNameSafe等の利用)
 */

// --- 共通ロジック ---

/**
 * シード配列を一括生成する
 */
function generateSeedList(initialSeed, count) {
    const seeds = [initialSeed];
    for (let i = 1; i < count; i++) {
        seeds[i] = xorshift32(seeds[i - 1]);
    }
    return seeds;
}

/**
 * ロール値と閾値からレアリティ情報を取得する
 */
function getRarityFromRoll(roll, thresholds) {
    if (roll < thresholds['0']) return { id: 0, name: 'ノーマル' };
    if (roll < thresholds['1']) return { id: 1, name: 'レア' };
    if (roll < thresholds['2']) return { id: 2, name: '激レア' };
    if (roll < thresholds['3']) return { id: 3, name: '超激レア' };
    return { id: 4, name: '伝説レア' };
}

/**
 * アドレス文字列 (1A, 1B, 2A...) を生成する
 * cols: 列数 (completed=2, uncompleted=3)
 */
function getAddressStringGeneric(n, cols) {
    if (n <= 0) return '';
    const zeroBasedIndex = n - 1;
    const col_char = String.fromCharCode('A'.charCodeAt(0) + (zeroBasedIndex % cols));
    const row_num = Math.floor(zeroBasedIndex / cols) + 1;
    return `${row_num}${col_char}`;
}

/**
 * アイテム名を取得する安全なヘルパー
 */
function getItemNameSafe(itemId) {
    if (itemId === -1 || itemId === undefined) return '---';
    return itemMaster[itemId]?.name || '---';
}

/**
 * ハイライトクラス判定ロジック
 */
function determineHighlightClass(info) {
    if (!info) return '';
    let cls = '';
    const isSingle10 = info.single && (info.singleRoll % 10 === 0);
    const isTen10 = info.ten && (info.tenRoll % 10 === 0);
    
    if (info.single && info.ten) {
        cls = (isSingle10 || isTen10) ? 'highlight-roll-overlap-dark' : 'highlight-roll-overlap';
    } else if (info.single) {
        cls = isSingle10 ? 'highlight-roll-dark' : 'highlight-roll';
    } else if (info.ten) {
        cls = isTen10 ? 'highlight-roll-10pull-dark' : 'highlight-roll-10pull';
    }
    return cls;
}

====================
FILE: logic-completed.js
====================
/**
 * 担当: 「コンプ済み」ビューにおける全アイテムの出現順およびルート計算
 * 依存関係: logic-common.js (シード生成・レアリティ判定の利用)
 */

function calculateCompletedData(initialSeed, gacha, tableRows, thresholds, initialLastRollId, initialNg) {
    // 1. シード生成
    // 1つのノードで最大3〜4つのシードを参照するため、余裕を持って生成
    const maxSeedsNeeded = tableRows * 4 * 2 + 1000;
    const SEED = generateSeedList(initialSeed, maxSeedsNeeded);

    // ヘルパー
    const getAddress = (n) => getAddressStringGeneric(n, 2);
    const Nodes = [];
    const maxNodeIndex = tableRows * 2 + 100;

    // 2. ノード計算 (No.1 ～ maxNodeIndex)
    for (let i = 1; i <= maxNodeIndex; i++) {
        const node = {
            index: i,
            address: getAddress(i),
            /**
             * 【シード消費の定義】
             * seed1 (SEED[i]):   レアリティ判定に使用される
             * seed2 (SEED[i+1]): アイテムスロット（通常/確定枠）の抽選に使用される
             * seed3 (SEED[i+2]): レア重複時の再抽選スロットに使用される
             */
            seed1: SEED[i],
            seed2: SEED[i+1],
            seed3: SEED[i+2],
            singleRoll: null, singleUseSeeds: null, singleNextAddr: null,
            tenPullMark: null, tenPullUseSeeds: null, tenPullNextAddr: null,
            roll1: SEED[i] % 10000
        };

        const roll1 = node.seed1 % 10000;
        node.rarity = getRarityFromRoll(roll1, thresholds);
        node.rarityId = node.rarity.id;
        node.roll1 = roll1;

        // 確定枠（超激レア/伝説レア）の判定計算
        const uberRate = gacha.uberGuaranteedFlag ? (gacha.rarityRates['3'] || 0) : 0;
        const legendRate = gacha.legendGuaranteedFlag ? (gacha.rarityRates['4'] || 0) : 0;
        const gDivisor = uberRate + legendRate;

        if (gDivisor > 0) {
            const gRoll = node.seed1 % gDivisor;
            node.rarityGId = (gRoll < uberRate) ? '3' : '4';
            node.rarityGName = (node.rarityGId === '3') ? '超激レア' : '伝説レア';
            node.gRoll = gRoll; node.gDivisor = gDivisor;
        } else {
            node.rarityGId = null;
            node.rarityGName = '-'; node.gRoll = 0; node.gDivisor = 0;
        }

        // 通常アイテム抽選 (使用シード: seed2)
        const pool = gacha.rarityItems[node.rarityId] || [];
        node.poolSize = pool.length;
        if (pool.length > 0) {
            node.slot = node.seed2 % pool.length;
            node.itemId = pool[node.slot];
            node.itemName = getItemNameSafe(node.itemId);
        } else {
            node.slot = 0;
            node.itemId = -1; node.itemName = '---';
        }

        // 確定枠アイテム抽選 (使用シード: seed2)
        const poolG = node.rarityGId ? (gacha.rarityItems[node.rarityGId] || []) : [];
        node.poolGSize = poolG.length;
        if (poolG.length > 0) {
            node.slotG = node.seed2 % poolG.length;
            node.itemGId = poolG[node.slotG];
            node.itemGName = getItemNameSafe(node.itemGId);
        } else {
            node.slotG = 0;
            node.itemGId = -1; node.itemGName = '---';
        }

        // 重複再抽選 (ReRoll) の判定用ロジック
        const prevNode = (i > 2) ? Nodes[i - 3] : null;
        const isRare = (node.rarityId === 1);
        const prevItemId = prevNode ? (prevNode.reRollFlag ? prevNode.reRollItemId : prevNode.itemId) : initialLastRollId;
        
        // レアリティがレア、かつ前回アイテムと一致する場合に再抽選フラグを立てる
        node.reRollFlag = isRare && (pool.length > 1) && (node.itemId !== -1) && (node.itemId === prevItemId);
        node.useSeeds = node.reRollFlag ? 3 : 2;

        if (isRare && pool.length > 1) {
             const reRollPool = pool.filter(id => id !== node.itemId);
             if (reRollPool.length > 0) {
                 // 再抽選スロット判定 (使用シード: seed3)
                 node.reRollSlot = node.seed3 % reRollPool.length;
                 node.reRollItemId = reRollPool[node.reRollSlot];
                 node.reRollItemName = getItemNameSafe(node.reRollItemId);
             } else {
                 node.reRollItemId = -1;
                 node.reRollItemName = '---';
             }
             const nextIdxRe = i + 3;
             node.reRollNextAddress = getAddress(nextIdxRe);
        } else {
             node.reRollItemId = -1;
             node.reRollItemName = '---';
             node.reRollNextAddress = '-';
        }
        Nodes.push(node);
    }

    // 3. 単発ルート計算
    let sIdx = 1;
    let sLastItemId = initialLastRollId || -1;
    let sRoll = 1;
    const ngVal = parseInt(initialNg, 10);
    const hasGuaranteed = !isNaN(ngVal);

    while (sIdx <= maxNodeIndex && sRoll <= tableRows) {
        const node = Nodes[sIdx - 1];
        const isGuaranteedRoll = hasGuaranteed && (gacha.uberGuaranteedFlag || gacha.legendGuaranteedFlag) && (sRoll >= ngVal) && ((sRoll - ngVal) % 10 === 0);
        
        if (isGuaranteedRoll) {
            if (node) {
                node.singleRoll = `${sRoll}g`;
                node.singleUseSeeds = 2; // レア判定(1) + 確定スロット(1)
                node.singleNextAddr = getAddress(sIdx + 2);
            }
            sLastItemId = node ? node.itemGId : -1;
            sIdx += 2;
        } else {
            const isRare = (node && node.rarityId === 1);
            const poolSize = gacha.rarityItems[1] ? gacha.rarityItems[1].length : 0;
            const isMatch = (node && node.itemId !== -1 && node.itemId === sLastItemId);
            const reRollFlag = isRare && isMatch && poolSize > 1;
            
            const useSeeds = reRollFlag ? 3 : 2;
            const finalId = (node && reRollFlag) ? node.reRollItemId : (node ? node.itemId : -1);
            if (node) {
                node.singleRoll = sRoll;
                node.singleUseSeeds = useSeeds;
                node.singleNextAddr = getAddress(sIdx + useSeeds);
            }
            sLastItemId = finalId;
            sIdx += useSeeds;
        }
        sRoll++;
    }

    // 4. 10連ルート計算
    let tIdx = 1;
    let tRoll = 1;
    let tLastItemId = initialLastRollId || -1; 

    while (tIdx <= maxNodeIndex && tRoll <= tableRows) {
        const isCycleStart = (tRoll - 1) % 10 === 0;
        const isGuaranteedRoll = hasGuaranteed && (gacha.uberGuaranteedFlag || gacha.legendGuaranteedFlag) && (tRoll >= ngVal) && ((tRoll - ngVal) % 10 === 0);
        
        if (isCycleStart) {
            const nodeG = Nodes[tIdx - 1];
            if(nodeG) { 
                nodeG.tenPullMark = 'r';
                nodeG.tenPullUseSeeds = 1; 
                nodeG.tenPullNextAddr = getAddress(tIdx + 1); 
            }
            tIdx++;
        }
        if (tIdx <= maxNodeIndex) {
            if (isGuaranteedRoll) {
                const gNode = Nodes[tIdx - 2];
                const nextNode = Nodes[tIdx - 1]; 
                if (gNode) tLastItemId = gNode.itemGId;
                if (nextNode) {
                    nextNode.tenPullMark = `↖${tRoll}g`;
                    nextNode.tenPullUseSeeds = 1; 
                    nextNode.tenPullNextAddr = getAddress(tIdx + 1); 
                }
                tIdx++;
            } else {
                const node = Nodes[tIdx - 1];
                const isRare = (node && node.rarityId === 1);
                const poolSize = gacha.rarityItems[1] ? gacha.rarityItems[1].length : 0;
                const isMatch = (node && node.itemId !== -1 && node.itemId === tLastItemId);
                const reRollFlag = isRare && isMatch && poolSize > 1;

                const useSeeds = reRollFlag ? 3 : 2;
                const finalId = (node && reRollFlag) ? node.reRollItemId : (node ? node.itemId : -1);
                if (node) {
                    node.tenPullMark = tRoll;
                    node.tenPullUseSeeds = useSeeds;
                    node.tenPullNextAddr = getAddress(tIdx + useSeeds);
                }
                tLastItemId = finalId;
                tIdx += useSeeds;
            }
        }
        tRoll++;
    }

    // 5. highlightInfo 生成
    const highlightInfo = new Map();
    sIdx = 1;
    sLastItemId = initialLastRollId || -1;
    for (let roll = 1; roll <= tableRows; roll++) {
        if (sIdx > maxNodeIndex) break;
        const node = Nodes[sIdx - 1];
        const isGuaranteedRoll = hasGuaranteed && (gacha.uberGuaranteedFlag || gacha.legendGuaranteedFlag) && (roll >= ngVal) && ((roll - ngVal) % 10 === 0);
        
        if (isGuaranteedRoll) {
            const addressKey = node.address + 'G';
            const info = highlightInfo.get(addressKey) || {};
            info.single = true; info.singleRoll = roll; 
            highlightInfo.set(addressKey, info);
            sLastItemId = node.itemGId;
            sIdx += 2;
        } else {
            const isRare = (node.rarityId === 1);
            const poolSize = gacha.rarityItems[1] ? gacha.rarityItems[1].length : 0;
            const isMatch = (node && node.itemId !== -1 && node.itemId === sLastItemId);
            const reRollFlag = isRare && isMatch && poolSize > 1;
            const useSeeds = reRollFlag ? 3 : 2;
            const finalId = (node && reRollFlag) ? node.reRollItemId : (node ? node.itemId : -1);
            
            const info = highlightInfo.get(node.address) || {};
            info.single = true; info.singleRoll = roll; 
            info.s_reRoll = reRollFlag;
            if (reRollFlag) {
                info.s_normalName = node.itemName;
                info.s_reRollName = node.reRollItemName;
                info.s_nextAddr = getAddress(sIdx + useSeeds);
            }
            highlightInfo.set(node.address, info);
            sLastItemId = finalId;
            sIdx += useSeeds;
        }
    }
    
    tIdx = 1;
    tLastItemId = initialLastRollId || -1;
    for (let roll = 1; roll <= tableRows; roll++) {
        if (tIdx > maxNodeIndex) break;
        const isCycleStart = (roll - 1) % 10 === 0;
        if (isCycleStart) tIdx++;
        if (tIdx <= maxNodeIndex) {
            const node = Nodes[tIdx - 1];
            const isGuaranteedRoll = (gacha.uberGuaranteedFlag || gacha.legendGuaranteedFlag) && (roll >= ngVal) && ((roll - ngVal) % 10 === 0);
            
            if (isGuaranteedRoll) {
                const gNode = Nodes[tIdx - 2];
                if (gNode) {
                    const addressKey = gNode.address + 'G';
                    const info = highlightInfo.get(addressKey) || {};
                    info.ten = true; info.tenRoll = roll; 
                    highlightInfo.set(addressKey, info);
                    tLastItemId = gNode.itemGId;
                } 
                tIdx += 1;
            } else {
                const isRare = (node && node.rarityId === 1);
                const poolSize = gacha.rarityItems[1] ? gacha.rarityItems[1].length : 0;
                const isMatch = (node.itemId !== -1 && node.itemId === tLastItemId);
                const reRollFlag = isRare && isMatch && poolSize > 1;
                const useSeeds = reRollFlag ? 3 : 2;
                let finalId = node.itemId;
                if (reRollFlag) finalId = node.reRollItemId;
                
                const info = highlightInfo.get(node.address) || {};
                info.ten = true;
                info.tenRoll = roll; 
                info.t_reRoll = reRollFlag;
                if (reRollFlag) {
                    info.t_normalName = node.itemName;
                    info.t_reRollName = node.reRollItemName;
                    info.t_nextAddr = getAddress(tIdx + useSeeds);
                }
                highlightInfo.set(node.address, info);
                tLastItemId = finalId;
                tIdx += useSeeds;
            }
        }
    }

    return { Nodes, highlightInfo, maxNodeIndex };
}

/**
 * ビームサーチによる最適ガチャルートのシミュレーション
 */
function runGachaBeamSearch(Nodes, initialLastRollId, totalTickets, gacha, thresholds, initialNg) {
    const ngVal = parseInt(initialNg);
    const hasGuaranteed = !isNaN(ngVal);

    // 単一ロールのシミュレーションヘルパー
    const simulateRoll = (node, lastId, rollNum) => {
        const isGuaranteed = hasGuaranteed && (gacha.uberGuaranteedFlag || gacha.legendGuaranteedFlag) && (rollNum >= ngVal) && ((rollNum - ngVal) % 10 === 0);
        if (isGuaranteed) {
            return { itemId: node.itemGId, itemName: node.itemGName, useSeeds: 2, rarity: itemMaster[node.itemGId]?.rarity || 0 };
        } else {
            const pool = gacha.rarityItems[node.rarityId] || [];
            const isMatch = (node.itemId !== -1 && node.itemId === lastId);
            const reRoll = (node.rarityId === 1) && (pool.length > 1) && isMatch;
            const finalId = reRoll ? node.reRollItemId : node.itemId;
            return { itemId: finalId, itemName: reRoll ? node.reRollItemName : node.itemName, useSeeds: reRoll ? 3 : 2, rarity: itemMaster[finalId]?.rarity || 0 };
        }
    };

    // dp[チケット消費数] = Map( "nodeIdx_lastId" => { score, path, ubers, legends, nodeIdx, lastId, rollCount } )
    let dp = new Array(totalTickets + 1).fill(null).map(() => new Map());

    dp[0].set(`1_${initialLastRollId}`, {
        nodeIdx: 1,
        lastId: initialLastRollId,
        ubers: 0,
        legends: 0,
        path: [],
        rollCount: 1
    });

    const updateDP = (map, state) => {
        const key = `${state.nodeIdx}_${state.lastId}`;
        const currentScore = state.ubers * 1000 + state.legends; // 超激レア優先
        const existing = map.get(key);
        if (!existing || (existing.ubers * 1000 + existing.legends) < currentScore) {
            map.set(key, state);
        }
    };

    for (let t = 0; t < totalTickets; t++) {
        for (let state of dp[t].values()) {
            // 1. 単発ロール (消費1)
            const nodeS = Nodes[state.nodeIdx - 1];
            if (nodeS) {
                const res = simulateRoll(nodeS, state.lastId, state.rollCount);
                updateDP(dp[t + 1], {
                    nodeIdx: state.nodeIdx + res.useSeeds,
                    lastId: res.itemId,
                    ubers: state.ubers + (res.rarity === 3 ? 1 : 0),
                    legends: state.legends + (res.rarity === 4 ? 1 : 0),
                    path: state.path.concat({ type: 'single', item: res.itemName, addr: nodeS.address }),
                    rollCount: state.rollCount + 1
                });
            }

            // 2. 10連ロール (消費10)
            if (t + 10 <= totalTickets) {
                let curIdx = state.nodeIdx + 1; // サイクルスタート分 +1
                let curLastId = state.lastId;
                let curRollCount = state.rollCount;
                let items = [], ubers = 0, legends = 0;
                let startAddr = Nodes[state.nodeIdx - 1]?.address || '??';

                for (let i = 0; i < 10; i++) {
                    const node = Nodes[curIdx - 1];
                    if (!node) break;
                    const res = simulateRoll(node, curLastId, curRollCount);
                    items.push(res.itemName);
                    if (res.rarity === 3) ubers++;
                    if (res.rarity === 4) legends++;
                    curIdx += res.useSeeds;
                    curLastId = res.itemId;
                    curRollCount++;
                }

                if (items.length === 10) {
                    updateDP(dp[t + 10], {
                        nodeIdx: curIdx,
                        lastId: curLastId,
                        ubers: state.ubers + ubers,
                        legends: state.legends + legends,
                        path: state.path.concat({ type: 'ten', items: items, addr: startAddr }),
                        rollCount: curRollCount
                    });
                }
            }
        }
    }

    // dp[totalTickets] の中で最高スコアのものを探す
    let best = null;
    let maxScore = -1;
    for (let state of dp[totalTickets].values()) {
        const score = state.ubers * 1000 + state.legends;
        if (score > maxScore) {
            maxScore = score;
            best = state;
        }
    }
    return best;
}

====================
FILE: logic-uncompleted-sim.js
====================
/**
 * 担当: 「未コンプ」ビュー用の10連ガチャシミュレーションおよび期待値計算ロジック
 * 依存関係: logic-common.js
 */

/**
 * 10連詳細（現在地からの1回分）を計算するロジック
 */
function calculateTenPullDetailedLogic(fullSeedArray, gacha, thresholds, ngVal, initialLastRollId, getAddressFunc) {
    const isGuaranteedActive = !isNaN(ngVal);
    const guaranteedCycle = gacha.guaranteedCycle || 30;
    
    let guaranteedStatus = 'none';
    let currentNgVal = ngVal;
    
    // Featured 判定で実際に消費したシードの数をトラック
    let featuredSeedPtr = 0; 
    
    if (isGuaranteedActive && currentNgVal > 0) {
        if (currentNgVal <= 10) {
            guaranteedStatus = `next guaranteed(${currentNgVal}) <= 10 → 9ロール抽選`;
        } else {
            guaranteedStatus = `next guaranteed(${currentNgVal}) >= 11 → 10ロール抽選`;
        }
    } else {
        guaranteedStatus = 'Not Guaranteed/NG Invalid → 10ロール抽選';
    }

    const featuredLog = [];
    const processLog = [];
    const results = [];
    let featuredCountInCycle = 0; 

    // 目玉判定用シード (S1～S10) の計算
    const featuredResults = [];
    for (let i = 1; i <= 10; i++) { 
        const isGuaranteedRoll = isGuaranteedActive && i === currentNgVal && currentNgVal <= 10;

        if (isGuaranteedRoll) {
             featuredLog.push(`S${i} (Skipped): Guaranteed Roll (${currentNgVal})`);
             continue;
        }
        
        const sVal = fullSeedArray[featuredSeedPtr];
        if (sVal === undefined) {
             console.error(`Seed is undefined at index ${featuredSeedPtr}.`);
             break; 
        }

        const mod = sVal % 10000;
        const isFeatured = mod < gacha.featuredItemRate;
        featuredResults.push({ index: i, isFeatured: isFeatured, seedIndex: featuredSeedPtr + 1 });
        featuredLog.push(`S${featuredSeedPtr + 1} (${sVal}) % 10000 = ${mod} < ${gacha.featuredItemRate} → ${isFeatured} (Roll ${i}用)`);
        featuredSeedPtr++;
    }

    let currentSeedIndex = featuredSeedPtr; 
    let lastItemId = initialLastRollId || -1;
    const rollCount = 10;
    let featuredIdxPtr = 0; 

    for (let r = 1; r <= rollCount; r++) {
        let label = `Roll${r}`;
        
        // 確定ロール判定
        if (isGuaranteedActive && r === currentNgVal) {
            label += `(G${r})`;
            if (currentNgVal <= 10) { 
                processLog.push(`${label} (Skipped): Guaranteed Roll`);
            } else {
                processLog.push(`${label}: Featured Item by guaranteed`); 
            }
            results.push({ label: label, name: '目玉(確定)', isGuaranteed: true, isFeatured: false, isReroll: false, preRerollName: null });
            featuredCountInCycle++; 
            continue;
        }

        // 非確定ロール判定
        const fRes = featuredResults[featuredIdxPtr];
        if (!fRes) {
             processLog.push(`${label}: **ERROR**: Featured check result missing.`);
             break;
        }
        featuredIdxPtr++; 
        
        if (fRes.isFeatured) {
            results.push({ label: label, name: '目玉', isGuaranteed: false, isFeatured: true, isReroll: false, preRerollName: null });
             processLog.push(`${label}: Featured (by S${fRes.seedIndex})`);
             lastItemId = -2;
             featuredCountInCycle++; 
        } else {
            // Continuation Seeds Consumption
            const sRarity = fullSeedArray[currentSeedIndex];
            const sSlot = fullSeedArray[currentSeedIndex+1];
            
            if (sRarity === undefined || sSlot === undefined) {
                 processLog.push(`${label}: **ERROR**: Seed array ended unexpectedly.`);
                 break; 
            }

            const rarityInfo = getRarityFromRoll(sRarity % 10000, thresholds);
            const rId = rarityInfo.id;
            const rName = rarityInfo.name;
            let logStr = `${label}: S${currentSeedIndex+1}→${rName}`;
            
            const pool = gacha.rarityItems[rId] || [];
            const poolSize = pool.length > 0 ? pool.length : 1;
            const slot = sSlot % poolSize;
            const itemId = (pool[slot] !== undefined) ? pool[slot] : -1;
            const itemName = getItemNameSafe(itemId);
            
            logStr += `, S${currentSeedIndex+2}→${itemName}`;
            
            let finalId = itemId;
            let finalName = itemName;
            let consumed = 2;
            let isReroll = false;
            let preRerollName = null;

            // Dupe Check
            if (rId === 1 && itemId !== -1 && itemId === lastItemId) {
                const sReRoll = fullSeedArray[currentSeedIndex+2];
                if (sReRoll === undefined) break;
                const rePool = pool.filter(id => id !== itemId);
                const reDiv = rePool.length;
                logStr += ` [Dupe]`;
                if (reDiv > 0) {
                    isReroll = true;
                    preRerollName = itemName;
                    const reSlot = sReRoll % reDiv;
                    finalId = rePool[reSlot];
                    finalName = getItemNameSafe(finalId);
                    logStr += `, S${currentSeedIndex+3}→${finalName}`;
                }
                consumed = 3;
            }

            processLog.push(logStr);
            results.push({ label: label, name: finalName, isGuaranteed: false, isFeatured: false, isReroll: isReroll, preRerollName: preRerollName });
            currentSeedIndex += consumed;
            lastItemId = finalId;
        }
    }

    const nextSeedVal = fullSeedArray[currentSeedIndex]; 
    const nextIndex = currentSeedIndex + 1;
    const nextAddress = (fullSeedArray.length > currentSeedIndex) ? getAddressFunc(nextIndex) : 'End';
    const nextNgVal = isGuaranteedActive ? currentNgVal : NaN;
    const seedsConsumedCorrectly = currentSeedIndex; 

    return {
        guaranteedStatus, featuredLog, processLog, results, featuredCountInCycle,
        transition: { consumedCount: seedsConsumedCorrectly, nextIndex: nextIndex, nextAddress: nextAddress, nextSeed: nextSeedVal, lastItemId: lastItemId, nextNgVal: nextNgVal }
    };
}

/**
 * nサイクル分の10連計算を実行
 */
function calculateTenPullsOverCycles(initialFullSeedArray, gacha, thresholds, initialNgVal, initialLastRollId, nCycles = 10) {
    const getAddress = (n) => getAddressStringGeneric(n, 3);
    const guaranteedCycle = gacha.guaranteedCycle || 30; // 確定サイクルの値を取得
    let currentSeedArray = [...initialFullSeedArray];
    let currentLastRollId = initialLastRollId;
    let currentNgVal = initialNgVal;
    
    const cycleResults = [];
    const maxSeedsInTenPull = 40; 

    for (let c = 1; c <= nCycles; c++) {
        if (currentSeedArray.length < 1) break;
        const tenPullSeedSlice = currentSeedArray.slice(0, maxSeedsInTenPull); 
        const cycleResult = calculateTenPullDetailedLogic(tenPullSeedSlice, gacha, thresholds, currentNgVal, currentLastRollId, getAddress);
        
        cycleResults.push({ cycle: c, ...cycleResult, startNgVal: currentNgVal, startLastRollId: currentLastRollId });

        const consumedCount = cycleResult.transition.consumedCount;
        currentSeedArray = currentSeedArray.slice(consumedCount);
        currentLastRollId = cycleResult.transition.lastItemId;
        let nextNgValFromLogic = cycleResult.transition.nextNgVal; // logicから返されたNG値

        // 10連が終わった時点で10ロール分マイナスする
        if (!isNaN(nextNgValFromLogic)) {
                currentNgVal = nextNgValFromLogic - 10;
            // 確定サイクルをまたいだ場合の処理
            if (currentNgVal <= 0) {
                 currentNgVal = guaranteedCycle + currentNgVal;
            }
        } else {
            // 確定システムが無効な場合はそのまま NaN を維持
            currentNgVal = nextNgValFromLogic;
        }
    }
    return cycleResults;
}

/**
 * 単発Nロール後の10連目玉獲得数期待値の計算ロジック
 */
function calculateExpectedFeaturedCounts(initialFullSeedArray, gacha, thresholds, nRollsArray, initialNgVal, initialLastRollId) {
    const results = {};
    const guaranteedCycle = gacha.guaranteedCycle || 30;
    const tenPullSimulationLength = 40; 
    
    // Nロール後の状態をシミュレーション
    const simulateSingleRollsAndGetState = (n, seedArray, initialNg, initialLastRoll) => {
        let currentSeedIndex = 0;
        let currentNg = !isNaN(initialNg) && initialNg > 0 ? initialNg : guaranteedCycle;
        let lastItemId = initialLastRoll || -1;
        
        for (let r = 1; r <= n; r++) {
            if (currentSeedIndex >= seedArray.length) break;
            const isFeatured = (seedArray[currentSeedIndex] % 10000) < gacha.featuredItemRate;
            const isGuaranteedRoll = (currentNg === 1);
            let usedSeeds = 0;

            if (isGuaranteedRoll) {
                usedSeeds = 1; currentNg = guaranteedCycle; lastItemId = -2;
            } else if (isFeatured) {
                usedSeeds = 1; currentNg = currentNg - 1;
                if (currentNg <= 0) currentNg = guaranteedCycle;
                lastItemId = -2;
            } else {
                const sRarity = seedArray[currentSeedIndex+1];
                const sSlot = seedArray[currentSeedIndex+2];
                if (sRarity === undefined || sSlot === undefined) { usedSeeds = 3; break; }
                const rarityInfo = getRarityFromRoll(sRarity % 10000, thresholds);
                const rId = rarityInfo.id;
                const pool = gacha.rarityItems[rId] || [];
                const itemId = (pool[sSlot % (pool.length||1)] !== undefined) ? pool[sSlot % (pool.length||1)] : -1;
                usedSeeds = 3;
                let finalId = itemId;

                if (rId === 1 && itemId !== -1 && itemId === lastItemId) {
                    const sReRoll = seedArray[currentSeedIndex+3];
                    if (sReRoll !== undefined) {
                        const rePool = pool.filter(id => id !== itemId);
                        if (rePool.length > 0) {
                            finalId = rePool[sReRoll % rePool.length];
                            usedSeeds = 4;
                        }
                    }
                }
                currentNg = currentNg - 1;
                if (currentNg <= 0) currentNg = guaranteedCycle;
                lastItemId = finalId;
            }
            currentSeedIndex += usedSeeds;
        }
        return { nextSeedIndex: currentSeedIndex, nextNg: currentNg, nextLastRollId: lastItemId };
    };

    for (const n of nRollsArray) {
        if (n < 0) continue;
        const { nextSeedIndex, nextNg, nextLastRollId } = simulateSingleRollsAndGetState(n, initialFullSeedArray, initialNgVal, initialLastRollId);
        const tenPullSeedArray = initialFullSeedArray.slice(nextSeedIndex, nextSeedIndex + tenPullSimulationLength);

        if (tenPullSeedArray.length < 9) {
             results[n] = 0; continue;
        }
        const tenPullResult = calculateTenPullDetailedLogic(tenPullSeedArray, gacha, thresholds, nextNg, nextLastRollId, (addr) => `S${nextSeedIndex + addr}`);
        results[n] = tenPullResult.featuredCountInCycle;
    }
    return results;
}

====================
FILE: logic-uncompleted.js
====================
/**
 * 担当: 「未コンプ」ビューにおけるメインテーブル用のノード計算
 * 依存関係: logic-common.js, logic-uncompleted-sim.js
 */

/**
 * 未コンプ（分割）ビュー用のデータを計算する関数
 */
function calculateUncompletedData(initialSeed, gacha, tableRows, thresholds, initialLastRollId, params) {
    // 1. シード生成
    const maxSeedsNeeded = tableRows * 10 + 1000; 
    const SEED = generateSeedList(initialSeed, maxSeedsNeeded);
    const getAddress = (n) => getAddressStringGeneric(n, 3);
    
    // 2. 全ノード計算 (メインテーブル用)
    const Nodes = [];
    const maxNodes = tableRows * 3 + 20; 
    const highlightInfo = new Map(); 

    const ngVal = parseInt(params.get('ng'), 10);
    const initialFs = parseInt(params.get('fs'), 10) || 0; 
    const guaranteedCycle = gacha.guaranteedCycle || 30;
    
    for (let i = 1; i <= maxNodes; i++) {
        const seedStartIdx = i; 
        const s1 = SEED[seedStartIdx];     
        const s2 = SEED[seedStartIdx + 1]; 
        const s3 = SEED[seedStartIdx + 2]; 
        const s4 = SEED[seedStartIdx + 3]; 
        let prevSeedVal = SEED[seedStartIdx - 1];

        const node = {
            index: i, address: getAddress(i),
            seed1: s1, seed2: s2, seed3: s3, seed4: s4,
            prevSeed1: prevSeedVal,
            isFeatured: (s1 % 10000) < gacha.featuredItemRate,
            singleRoll: null, singleUseSeeds: null, singleNextAddr: null,
            guaranteedNextNgVal: ngVal,
            isFeaturedUsedFs: false,
        };

        node.featuredNextAddress = getAddress(i + 1); 
        node.normalNextAddress = getAddress(i + 3);   
        node.reRollNextAddress = getAddress(i + 4);   

        node.rarity = getRarityFromRoll(s2 % 10000, thresholds);
        node.rarityId = node.rarity.id;
        node.rarityName = node.rarity.name; 
        
        // レアリティ範囲表示用
        let lowerBound = 0, upperBound = 10000;
        const rarityIds = Object.keys(thresholds).map(Number).sort((a, b) => a - b);
        for(const id of rarityIds) {
            if (id < node.rarityId) lowerBound = thresholds[id];
            if (id === node.rarityId) { upperBound = thresholds[id]; break; }
        }
        node.rarityRateRangeDisplay = `${lowerBound}<=${s2 % 10000}<${upperBound}`;
        
        const pool = gacha.rarityItems[node.rarityId] || [];
        node.poolSize = pool.length;
        if (pool.length > 0) {
            node.slot = s3 % pool.length;
            node.itemId = pool[node.slot];
            node.itemName = getItemNameSafe(node.itemId);
        } else {
            node.slot = 0; node.itemId = -1; node.itemName = '---';
        }
        
        const isRare = (node.rarityId === 1);
        if (isRare && pool.length > 1) {
            const reRollPool = pool.filter(id => id !== node.itemId);
            if (reRollPool.length > 0) {
                node.reRollSlot = s4 % reRollPool.length;
                node.reRollItemId = reRollPool[node.reRollSlot];
                node.reRollItemName = getItemNameSafe(node.reRollItemId);
            } else { node.reRollItemId = -1; node.reRollItemName = '---'; }
        } else { node.reRollItemId = -1; node.reRollItemName = '---'; }

        // Dupe判定用
        let compareId3Node = -1, compareId4Node = -1;
        let compareName3Node = '---', compareName4Node = '---';
        
        if (i <= 1) { 
            compareId3Node = initialLastRollId || -1;
            compareName3Node = getItemNameSafe(initialLastRollId || -1);
        } else {
            const pNode3 = (i > 3) ? Nodes[i-4] : null; 
            if (pNode3 && pNode3.singleUseSeeds === 3) {
                 compareId3Node = pNode3.itemId; compareName3Node = pNode3.itemName;
            } else if (i <= 3) {
                compareId3Node = initialLastRollId || -1; compareName3Node = getItemNameSafe(initialLastRollId || -1);
            }
            const pNode4 = (i > 4) ? Nodes[i-5] : null;
            if (pNode4 && pNode4.singleUseSeeds === 4 && pNode4.reRollItemId !== -1) {
                 compareId4Node = pNode4.reRollItemId; compareName4Node = pNode4.reRollItemName;
            }
        }
        
        const currentId = node.itemId;
        const isDupe3 = (currentId !== -1 && currentId === compareId3Node);
        const isDupe4 = (compareId4Node !== -1 && currentId === compareId4Node); 
        node.isDupe = (node.rarityId === 1 && (isDupe3 || isDupe4)); 

        if (node.rarityId === 1) {
            const id3 = compareId3Node !== -1 ? compareName3Node : '-';
            const id4 = compareId4Node !== -1 ? compareName4Node : '';
            node.dupeCompareTargets = `${id3}${id4 ? '/' + id4 : ''}`; 
        } else { node.dupeCompareTargets = node.rarityName; }

        Nodes.push(node);
    }
    
    // 3. 単発ルート計算
    let sIdx = 1; 
    let sLastActualItemId = initialLastRollId || -1; 
    let sCurrentFs = initialFs;
    const singleRoutePath = new Map();
    const hasGuaranteed = !isNaN(ngVal);
    let currentNg = hasGuaranteed ? ngVal : -1;

    for (let roll = 1; roll <= tableRows; roll++) {
        if (sIdx > maxNodes) break;
        const node = Nodes[sIdx - 1];
        if (!node) break;
        
        const isGuaranteedRoll = hasGuaranteed && (currentNg === 1); 
        node.singleCompareItemName = getItemNameSafe(sLastActualItemId);
        node.singleCompareItemId = sLastActualItemId; 

            let usedSeeds = 0;
            let finalId = -1;
            
            if (node.isFeatured) {
                usedSeeds = 1; finalId = -2; 
                node.singleRoll = roll;
                node.singleUseSeeds = usedSeeds;
                node.singleNextAddr = node.featuredNextAddress; 
                if (sCurrentFs > 0) { sCurrentFs -= 1; node.isFeaturedUsedFs = true; }
            } else {
                const poolSize = gacha.rarityItems[1] ? gacha.rarityItems[1].length : 0;
                const currentId = Number(node.itemId);
                const lastId = Number(sLastActualItemId);
                const isMatch = (currentId !== -1 && lastId !== -1 && currentId === lastId);
                const isReroll = (node.rarityId === 1) && isMatch && poolSize > 1; 
                
                finalId = isReroll ? node.reRollItemId : node.itemId;
                usedSeeds = isReroll ? 4 : 3;
                
                node.singleIsReroll = isReroll; 
                node.singleRoll = roll;
                node.singleUseSeeds = usedSeeds;
                node.singleNextAddr = isReroll ? node.reRollNextAddress : node.normalNextAddress; 
            }
            sLastActualItemId = finalId; 
            if (hasGuaranteed) {
                currentNg = currentNg - 1;
                if (currentNg <= 0) currentNg = guaranteedCycle;
            }
        if (isGuaranteedRoll) {
            node.singleRoll = `${roll}g`;
            //node.singleUseSeeds = 0; 
            //node.singleNextAddr = node.featuredNextAddress;
            //node.singleIsReroll = false; 
            node.isGuaranteedRoll = true; // フラグ
            currentNg = guaranteedCycle; 
            sLastActualItemId = -2; 
        }
        singleRoutePath.set(sIdx, roll);
        sIdx = sIdx + (node.singleUseSeeds === 0 ? 0 : node.singleUseSeeds || 3); 
    }

    // 4. Highlight Info 生成 (単発ルート)
    sIdx = 1; 
    for (let roll = 1; roll <= tableRows; roll++) {
        if (sIdx > maxNodes) break;
        const node = Nodes[sIdx - 1];
        if (!node || node.singleRoll === null) break;
        const addressKey = node.address;
        
        const info = highlightInfo.get(addressKey) || {};
        info.single = true; info.singleRoll = roll; 

        if (node.singleRoll.toString().endsWith('g')) {
             info.s_guaranteed = true;
        } else if (node.isFeatured) {
             info.s_featured = true; info.s_reRoll = false;
        } else if (node.rarityId !== 1) { 
             info.s_featured = false; info.s_reRoll = false; 
             info.s_normalName = node.rarityName; 
        } else {
             info.s_featured = false;
             info.s_reRoll = node.singleIsReroll; 
             info.s_currentId = node.itemId;
             if (info.s_reRoll) {
                 info.s_normalName = node.itemName; 
                 info.s_reRollName = node.reRollItemName;
             }
        }
        highlightInfo.set(addressKey, info);
        sIdx += node.singleUseSeeds || 3; 
    }
    
    // 5. Simロジック委譲: 10連サイクル計算 & 期待値計算
    const tenPullCyclesData = calculateTenPullsOverCycles(SEED, gacha, thresholds, ngVal, initialLastRollId, 10);
    const nRollsArray = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    const expectedFeaturedCounts = calculateExpectedFeaturedCounts(SEED, gacha, thresholds, nRollsArray, ngVal, initialLastRollId);

    return { Nodes, highlightInfo, maxNodes, singleRoutePath, tenPullCyclesData, expectedFeaturedCounts };
}

====================
FILE: main.js
====================
/**
 * 担当: アプリケーションの起動、URLパラメータ管理、DOMイベントリスナーの制御
 * 依存関係: master.js, logic-*.js, view-*.js (全機能の統括)
 */

/**
 * 【データ相関・アプリケーションフロー図】
 * * [ Entry Point ]
 * index.html (構造定義・外部スクリプト読込)
 * ↓
 * [ Master Data ]
 * master.js (ガチャ設定・アイテムリスト)
 * ↓
 * [ Helpers & Common ]
 * utils.js (URL生成・シード生成・共通パーツ)
 * logic-common.js (レアリティ判定・アドレス計算共通)
 * ↓
 * [ Controller ]
 * main.js (URLパラメータ取得・ビューの切り替え・イベント管理)
 * │
 * ├─→ <コンプ済み (Completed) ビュー表示時>
 * │     │
 * │     ├─ [Logic] logic-completed.js (全ルートのノード計算)
 * │     └─ [View]  view-completed.js (統合テーブル・計算詳細描画)
 * │
 * └─→ <未コンプ (Uncompleted) ビュー表示時>
 * │
 * ├─ [Logic] logic-uncompleted.js (メインノード計算)
 * │     └─ logic-uncompleted-sim.js (10連シミュレーション・期待値計算)
 * │
 * └─ [View]  view-uncompleted.js (描画統括)
 * ├─ view-uncompleted-table.js (メインテーブル・期待値表示)
 * └─ view-uncompleted-details.js (単発計算過程・10連詳細表示)
 * * [ Styling ]
 * style.css (全画面のレイアウト・ハイライト色定義)
 */

// --- グローバル変数 ---
const DEFAULT_PARAMS = {
    gacha: '45',
    seed: '123456789',
    ng: 'none',
    fs: 'none',
    lr: null,
    comp: false,
    tx: false,
    roll: 100,
    displaySeed: '0'
};

// ハイライト状態管理
let currentHighlightMode = 'all'; // 'all', 'single', 'multi'
let activeGachaId;
let forceRerollMode = false;

// グローバルスコープへ公開（viewスクリプトからの参照用）
window.activeGachaId = activeGachaId;
window.forceRerollMode = forceRerollMode;

// --- ディスパッチャー & メイン ---

function runSimulationAndDisplay(options = {}) {
    const { hideSeedInput = false, uiOverrides = {} } = options;
    const params = new URLSearchParams(window.location.search);
    const latestGachaId = Object.keys(gachaMaster).reduce((a, b) => parseInt(a) > parseInt(b) ? a : b);
    
    const p = {};
    ['gacha', 'seed', 'ng', 'fs', 'lr', 'comp', 'tx', 'roll', 'displaySeed'].forEach(k => {
        p[k] = params.get(k);
    });
    if (!p.gacha || !gachaMaster[p.gacha]) p.gacha = latestGachaId;
    if (!p.seed) p.seed = DEFAULT_PARAMS.seed;
    if (!p.roll) p.roll = DEFAULT_PARAMS.roll;
    if (!p.ng) p.ng = DEFAULT_PARAMS.ng;
    if (p.tx === 'true') p.tx = '1'; else if (p.tx === 'false') p.tx = '0';
    if (!p.tx && DEFAULT_PARAMS.tx) p.tx = '1';
    if (p.comp === '1') p.comp = 'true'; else if (p.comp === '0') p.comp = 'false';
    
    if (uiOverrides.seed !== undefined) p.seed = uiOverrides.seed;
    if (uiOverrides.guaranteedRolls !== undefined) p.ng = uiOverrides.guaranteedRolls;
    if (uiOverrides.featuredStock !== undefined) p.fs = uiOverrides.featuredStock;
    if (uiOverrides.isComplete !== undefined) p.comp = uiOverrides.isComplete ? 'true' : 'false';
    
    activeGachaId = p.gacha;
    window.activeGachaId = activeGachaId; // 更新
    
    const gacha = gachaMaster[p.gacha];
    
    document.getElementById('seedInput').value = p.seed;
    const isComplete = (p.comp === 'true');
    document.getElementById('featuredCompleteCheckbox').checked = isComplete;
    
    if (gacha.featuredItemStock === 0) {
        document.getElementById('featuredCompleteCheckbox').checked = true;
        document.getElementById('featuredCompleteCheckbox').parentElement.classList.add('hidden-control');
    } else {
        document.getElementById('featuredCompleteCheckbox').parentElement.classList.remove('hidden-control');
    }
    
    const isComp = document.getElementById('featuredCompleteCheckbox').checked;
    const stockControl = document.getElementById('stockControl');
    const guaranteedControl = document.getElementById('guaranteedControl');
    const legendDisplay = document.getElementById('legendDisplay');

    populateFeaturedStockInput(p.gacha, p.fs);

    const legendCommon = document.getElementById('legendCommon');
    if (isComp) {
        stockControl.classList.add('hidden-control');
        if (gacha.uberGuaranteedFlag || gacha.legendGuaranteedFlag) {
            guaranteedControl.classList.remove('hidden-control');
            legendDisplay.classList.remove('hidden-control');
            populateGuaranteedRolls(10, p.ng);
        } else {
            guaranteedControl.classList.add('hidden-control');
            legendDisplay.classList.add('hidden-control');
        }
        legendCommon.style.display = 'inline-block';
    } else {
        stockControl.classList.remove('hidden-control');
        guaranteedControl.classList.remove('hidden-control');
        legendDisplay.classList.remove('hidden-control');
        populateGuaranteedRolls(gacha.guaranteedCycle || 30, p.ng);
        legendCommon.style.display = 'none'; 
    }

    const lastRollDisplay = document.getElementById('lastRollDisplay');
    if (p.lr && itemMaster[p.lr]) {
        lastRollDisplay.textContent = `LastRoll: ${itemMaster[p.lr].name}`;
    } else {
        lastRollDisplay.textContent = '';
    }

    const newParams = {
        gacha: p.gacha, seed: p.seed, ng: p.ng, fs: p.fs, lr: p.lr,
        comp: isComp ? 'true' : 'false',
        tx: (p.tx === '1' || (!hideSeedInput && document.getElementById('seedRow').classList.contains('hidden-control') === false)) ? '1' : '0',
        roll: p.roll, displaySeed: p.displaySeed
    };
    if (!hideSeedInput && document.getElementById('seedRow').style.display === 'flex') newParams.tx = '1';

    const newQuery = generateUrlQuery(newParams);
    window.history.replaceState({ path: newQuery }, '', `${window.location.pathname}${newQuery}`);

    const seedValue = parseInt(p.seed, 10);
    const lastRollId = p.lr ? parseInt(p.lr, 10) : null;
    const rows = parseInt(p.roll, 10);
    const thresholds = {
        '0': gacha.rarityRates['0'],
        '1': gacha.rarityRates['0'] + gacha.rarityRates['1'],
        '2': gacha.rarityRates['0'] + gacha.rarityRates['1'] + gacha.rarityRates['2'],
        '3': gacha.rarityRates['0'] + gacha.rarityRates['1'] + gacha.rarityRates['2'] + gacha.rarityRates['3'],
        '4': 10000
    };

    if (isComp) {
        createAndDisplayCompletedSeedView(seedValue, gacha, rows, thresholds, lastRollId, p.displaySeed, new URLSearchParams(newQuery), p.ng);
    } else {
        createAndDisplayUncompletedSeedView(seedValue, gacha, rows, thresholds, lastRollId, p.displaySeed, new URLSearchParams(newQuery));
    }
}

function populateGuaranteedRolls(max, currentVal) {
    const input = document.getElementById('guaranteedRollsInput');
    input.innerHTML = '';
    const unsetOption = document.createElement('option');
    unsetOption.value = 'none'; unsetOption.textContent = '未設定'; input.appendChild(unsetOption);
    for (let i = 1; i <= max; i++) {
        const option = document.createElement('option'); option.value = i; option.textContent = i; input.appendChild(option);
    }
    if (currentVal && input.querySelector(`option[value="${currentVal}"]`)) {
        input.value = currentVal;
    } else {
        input.value = 'none';
    }
}
function populateFeaturedStockInput(gachaId, preferredValue) {
    const gacha = gachaMaster[gachaId];
    const input = document.getElementById('featuredStockInput');
    if (!gacha) return;
    input.innerHTML = '';
    const unsetOption = document.createElement('option');
    unsetOption.value = 'none'; unsetOption.textContent = '-'; input.appendChild(unsetOption);
    for (let i = 1; i <= gacha.featuredItemStock; i++) {
        const option = document.createElement('option'); option.value = i; option.textContent = i; input.appendChild(option);
    }
    if (preferredValue && preferredValue !== 'none' && input.querySelector(`option[value="${preferredValue}"]`)) {
        input.value = preferredValue;
    } else {
        input.value = 'none';
    }
}

function toggleSeedInput() {
    const seedRow = document.getElementById('seedRow');
    if (seedRow.classList.contains('hidden-control')) {
        seedRow.classList.remove('hidden-control');
    } else {
        seedRow.classList.add('hidden-control');
    }
}

// イベントリスナー設定
document.addEventListener('DOMContentLoaded', () => {
    setupGachaRarityItems(); // from utils.js

    document.getElementById('executeButton').addEventListener('click', () => runSimulationAndDisplay({ hideSeedInput: true, uiOverrides: { seed: document.getElementById('seedInput').value } }));
    document.getElementById('guaranteedRollsInput').addEventListener('change', (e) => runSimulationAndDisplay({ uiOverrides: { guaranteedRolls: e.target.value } }));
    document.getElementById('featuredStockInput').addEventListener('change', (e) => runSimulationAndDisplay({ uiOverrides: { featuredStock: e.target.value } }));
    document.getElementById('featuredCompleteCheckbox').addEventListener('change', () => runSimulationAndDisplay({ uiOverrides: { isComplete: document.getElementById('featuredCompleteCheckbox').checked } }));
    document.getElementById('copySeedLink').addEventListener('click', (event) => {
        event.preventDefault();
        const seedToCopy = new URLSearchParams(window.location.search).get('seed');
        if (seedToCopy && navigator.clipboard) {
            navigator.clipboard.writeText(seedToCopy).then(() => {
                const originalText = event.target.textContent;
                event.target.textContent = 'Copied!';
                setTimeout(() => { event.target.textContent = originalText; }, 1500);
            });
        }
    });
    document.getElementById('result-table-container').addEventListener('click', (event) => {
        if (event.target.id === 'forceRerollToggle') {
            window.forceRerollMode = !window.forceRerollMode;
            runSimulationAndDisplay();
        }
    });

    document.getElementById('showSeedInputLink').addEventListener('click', (e) => {
        e.preventDefault();
        toggleSeedInput();
    });

    const applyHighlightMode = () => {
         const table = document.querySelector('#result-table-container table');
         if (!table) return;
         table.classList.remove('mode-single', 'mode-multi');
         if (currentHighlightMode === 'single') table.classList.add('mode-single');
         if (currentHighlightMode === 'multi') table.classList.add('mode-multi');
    };

    document.getElementById('legendSingle').addEventListener('click', () => {
        if (document.getElementById('featuredCompleteCheckbox').checked) {
            currentHighlightMode = (currentHighlightMode === 'single') ? 'all' : 'single';
            applyHighlightMode();
        }
    });
    document.getElementById('legendMulti').addEventListener('click', () => {
        if (document.getElementById('featuredCompleteCheckbox').checked) {
            currentHighlightMode = (currentHighlightMode === 'multi') ? 'all' : 'multi';
            applyHighlightMode();
        }
    });

    document.getElementById('scrollToSingle').addEventListener('click', () => {
        const h2s = document.querySelectorAll('#calculation-details h2');
        for (const h2 of h2s) {
            if (h2.textContent.includes('＜単発ルート＞')) {
                h2.scrollIntoView({ behavior: 'smooth' });
                break;
            }
        }
    });

    document.getElementById('scrollToMulti').addEventListener('click', () => {
        const h2s = document.querySelectorAll('#calculation-details h2');
        for (const h2 of h2s) {
            if (h2.textContent.includes('＜10連ルート＞')) {
                h2.scrollIntoView({ behavior: 'smooth' });
                break;
            }
        }
    });

    runSimulationAndDisplay();
});

====================
FILE: master.js
====================
/**
 * 担当: ガチャ設定およびアイテム情報のマスターデータ定義
 * 依存関係: なし
 */

// --- マスターデータ ---
const gachaMaster = {
    '34': { name: '(旧)ハロウィン',
            featuredItemRate: 600,
            featuredItemStock: 5,
            guaranteedCycle: 30,
            uberGuaranteedFlag: false,
            legendGuaranteedFlag: false,
            rarityRates: { '0': 2000, '1': 5000, '2': 3000, '3': 0, '4': 0 },
            pool: [0, 2, 3, 4, 5, 10, 11, 12, 14] },

    '42': { name: '1.1億DL記念',
            featuredItemRate: 500,
            featuredItemStock: 5,
            guaranteedCycle: 30,
            uberGuaranteedFlag: false,
            legendGuaranteedFlag: false,
            rarityRates: { '0': 1000, '1': 5000, '2': 3000, '3': 1000, '4': 0 },
            pool: [0, 2, 3, 4, 5, 10, 11, 12, 14, 375, 381, 689] },

    '44': { name: 'ハロウィン',
            featuredItemRate: 500,
            featuredItemStock: 8,
            guaranteedCycle: 30,
            uberGuaranteedFlag: false,
            legendGuaranteedFlag: false,
            rarityRates: { '0': 2000, '1': 4900, '2': 3000, '3': 0, '4': 100 },
            pool: [0, 2, 3, 4, 5, 10, 11, 12, 14, 18] },
            
    '45': { name: 'にゃんこレンジャー',
            featuredItemRate: 0,
            featuredItemStock: 0,
            guaranteedCycle: 10,
            uberGuaranteedFlag: true,
            legendGuaranteedFlag: false,
            rarityRates: { '0': 0, '1': 7000, '2': 2300, '3': 500, '4': 200 },
            pool: [0,2,3,4,5,11,12,14,197,184,375,726,831] }
};

const itemMaster = {
    0: { name: "スピダ", rarity: 1 },
    2: { name: "ネコボン", rarity: 2 },
    3: { name: "ニャンピュ", rarity: 1 },
    4: { name: "おかめ", rarity: 2 },
    5: { name: "スニャ", rarity: 2 },
    10: { name: "5千XP", rarity: 0 },
    11: { name: "1万XP", rarity: 1 },
    12: { name: "3万XP", rarity: 1 },
    14: { name: "10万XP", rarity: 2 },
    18: { name: "200万XP", rarity: 4 },
    197: { name: "100万XP", rarity: 4 },
    184: { name: "ミスターニンジャ", rarity: 3 },
    375: { name: "記念ネコ", rarity: 3 },
    381: { name: "ねこ農家", rarity: 3 },
    689: { name: "石の上にも10年ネコ", rarity: 3 },
    726: { name: "ネコメダル王", rarity: 3 },
    831: { name: "スカーフにゃんこ", rarity: 3 }
};

====================
FILE: style.css
====================
/**
 * 担当: テーブルレイアウト、ハイライト色、UI要素のスタイリング定義
 * 依存関係: なし
 */
 
 body {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
    line-height: 1.2;
    padding: 5px;
    max-width: 1200px;
    margin: 0 auto;
    background-color: #f4f7f9;
    color: #333;
    font-size: 9px;
}
.container {
    background: #fff;
    padding: 5px;
    border-radius: 12px;
    box-shadow: 0 6px 15px rgba(0, 0, 0, 0.1);
}
h1 {
    color: #004085;
    font-size: 0.9rem;
    border-bottom: 1px solid #e9ecef;
    padding-bottom: 3px;
    margin-top: 0;
    text-align: center;
}
.controls {
    display: flex;
    flex-direction: column;
    gap: 5px;
    margin-bottom: 10px;
    padding: 4px;
    background-color: #f9fbfd;
    border-radius: 4px;
}
.row {
    display: flex;
    flex-wrap: wrap;
    justify-content: space-between;
    gap: 5px;
    align-items: center;
}
.control-group-left, .control-group-right {
    display: flex;
    align-items: center;
    gap: 15px;
}
.input-item {
    flex: 0 1 auto;
    display: flex;
    flex-direction: row;
    align-items: center;
    gap: 3px;
}
.input-item-display-only {
    flex: 0 1 auto;
    display: flex;
    align-items: center;
    font-size: 0.7rem;
    color: #555;
    padding: 0 5px;
}
.input-item-seed {
    display: flex;
    flex-direction: row;
    align-items: center;
    gap: 3px;
}
.seed-input-group {
    display: flex;
    align-items: center;
    gap: 5px;
    flex: 1 1 200px;
}
label {
    font-weight: 600;
    color: #555;
}
input[type="number"],
select {
    padding: 3px;
    border: 1px solid #ccc;
    border-radius: 3px;
    font-size: 0.8rem;
    width: 100%;
    box-sizing: border-box;
    transition: border-color 0.3s;
}
input[type="number"]:focus,
select:focus {
    outline: none;
    border-color: #007bff;
}
button {
    flex-shrink: 0;
    width: auto;
    padding: 5px 10px;
    background-color: #007bff;
    color: #fff;
    border: none;
    border-radius: 3px;
    cursor: pointer;
    font-size: 0.8rem;
    font-weight: bold;
    transition: background-color 0.3s ease, transform 0.2s ease;
}
.hidden-control {
    display: none !important;
}
#showSeedInputLink {
    color: #007bff;
    text-decoration: underline;
    cursor: pointer;
    padding: 0 5px;
    font-weight: bold;
}
#copySeedLink {
    color: #007bff;
    text-decoration: underline;
    cursor: pointer;
    white-space: nowrap;
}

button:hover {
    background-color: #0056b3;
    transform: translateY(-2px);
}
#result-container {
    margin-top: 15px;
}
#result-table-container {
    overflow-x: auto;
    border: 1px solid #e0e0e0;
    border-radius: 8px;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
}
table {
    width: 100%;
    border-collapse: collapse;
}
th, td {
    padding: 3px;
    text-align: center;
    border: 1px solid #e0e0e0;
    word-break: break-word;
    font-size: 0.8rem;
    min-width: 25px;
}
th {
    background-color: #f0f4f7;
    color: #444;
    font-weight: 600;
    position: sticky;
    top: 0;
    z-index: 1;
}
thead th:first-child {
    z-index: 2;
}
td {
    background-color: #fff;
}
.row-number-header {
    font-family: Arial, sans-serif;
    font-weight: bold;
    width: 25px;
    cursor: pointer;
}
.col-no {
    width: 25px;
}

/* アイテム装飾 */
.featuredItem-text {
    color: #d9534f; /* 赤 #d9534f*/
    font-weight: bold;
    text-decoration: none; /* ← 下線を非表示にします */
}
.legendItem-text {
    color: #0000ff; /* 青 */
    font-weight: bold;
}

#result-table-container td a {
    color: inherit;
    text-decoration: none;
}

/* 凡例 */
.legend-box {
    padding: 2px 5px;
    border-radius: 3px;
    margin-left: 5px;
    cursor: pointer;
    border: 1px solid transparent;
}
.legend-box:hover {
    border: 1px solid #999;
}
.legend-single { background-color: #e0f7ff; }
.legend-multi { background-color: #ffffe0; }
.legend-common { background-color: #dfffb0; }

/* ハイライト用CSS (通常) */
.highlight-roll { background-color: #e0f7ff !important; } /* 単発 (青) */
.highlight-roll-10pull { background-color: #ffffe0 !important; } /* 10連 (黄) */
.highlight-roll-overlap { background-color: #dfffb0 !important; } /* 重複 (緑) */

/* ハイライト用CSS (10ロールごとの鮮やかな色) */
.highlight-roll-dark { background-color: #80d8ff !important; } /* 鮮やかな青 (Light Blue A100) */
.highlight-roll-10pull-dark { background-color: #ffff8d !important; } /* 鮮やかな黄 (Yellow A100) */
.highlight-roll-overlap-dark { background-color: #b9f6ca !important; } /* 鮮やかな緑 (Green A100) */

/* モード別表示用 */
/* Single Mode */
.mode-single .highlight-roll { background-color: #e0f7ff !important; }
.mode-single .highlight-roll-dark { background-color: #80d8ff !important; }
.mode-single .highlight-roll-overlap { background-color: #e0f7ff !important; } 
.mode-single .highlight-roll-overlap-dark { background-color: #80d8ff !important; }

.mode-single .highlight-roll-10pull,
.mode-single .highlight-roll-10pull-dark { background-color: #fff !important; }

/* Multi Mode */
.mode-multi .highlight-roll-10pull { background-color: #ffffe0 !important; }
.mode-multi .highlight-roll-10pull-dark { background-color: #ffff8d !important; }
.mode-multi .highlight-roll-overlap { background-color: #ffffe0 !important; }
.mode-multi .highlight-roll-overlap-dark { background-color: #ffff8d !important; }

.mode-multi .highlight-roll,
.mode-multi .highlight-roll-dark { background-color: #fff !important; }

#calculation-details {
    font-family: monospace;
    font-size: 11px;
    line-height: 1.4;
    margin-top: 15px;
    padding: 10px;
    border: 1px solid #ccc;
    border-radius: 5px;
    background: #f9f9f9;
}
#calculation-details h2 {
    font-size: 1.1rem;
    margin-top: 20px;
    margin-bottom: 5px;
    border-bottom: 1px solid #ccc;
    padding-bottom: 3px;
}
#toggleDetailsBtn {
    background-color: #6c757d;
}
#toggleDetailsBtn:hover {
    background-color: #5a6268;
}
#details-controls {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-top: 10px;
}
.scroll-buttons {
    display: flex;
    gap: 10px;
}
.scroll-buttons button {
    font-size: 0.75rem;
    background-color: #28a745;
}
.scroll-buttons button:hover {
    background-color: #218838;
}

====================
FILE: utils.js
====================
/**
 * 担当: URLクエリ生成、乱数生成、共有の表示補助等の汎用ユーティリティ関数
 * 依存関係: master.js (itemMaster/gachaMasterの参照)
 */

// --- ユーティリティ関数 ---

function generateUrlQuery(p) {
    const query = new URLSearchParams();
    // DEFAULT_PARAMSはmain.jsで定義されますが、参照エラーを防ぐため
    // ここでチェックするか、呼び出し側で制御します。
    // 今回は単純化のため、呼び出し側でフィルタリング済みのオブジェクトを受け取る想定、
    // もしくは単純な変換を行います。
    for (const key in p) {
        if (p[key] !== null && p[key] !== undefined) query.set(key, p[key]);
    }
    return '?' + query.toString();
}

function xorshift32(seed) {
    let x = seed;
    x ^= x << 13; x ^= x >>> 17; x ^= x << 15;
    return x >>> 0;
}

function setupGachaRarityItems() {
    for (const gachaId in gachaMaster) {
        const gacha = gachaMaster[gachaId];
        if (gacha && gacha.pool) {
            gacha.rarityItems = { '0': [], '1': [], '2': [], '3': [], '4': [] };
            for (const itemId of gacha.pool) {
                const item = itemMaster[itemId];
                if (item && gacha.rarityItems[item.rarity] !== undefined) {
                    gacha.rarityItems[item.rarity].push(itemId);
                }
            }
            for (const rarity in gacha.rarityItems) gacha.rarityItems[rarity].sort((a, b) => a - b);
        }
    }
}

function generateMasterInfoHtml(gacha) {
    let html = `<h2>＜マスター情報＞</h2>`;
    // activeGachaIdはグローバル変数としてmain.jsで管理される想定
    html += `(ガチャ) ${gacha.name}(ID:${window.activeGachaId || '?'})<br>`;
    html += `(目玉) ${gacha.featuredItemRate > 0}(レート:${gacha.featuredItemRate}, 初期残数:${gacha.featuredItemStock})<br>`;
    html += `(確定) 超激:${gacha.uberGuaranteedFlag}, 伝説:${gacha.legendGuaranteedFlag}<br>`;
    
    const r = gacha.rarityRates;
    const r0 = r['0'];
    const t1 = r0;
    const t2 = r0 + r['1'];
    const t3 = t2 + r['2'];
    const t4 = t3 + r['3'];
    
    let rateStr = `(レート) `;
    if (r0 === 0) rateStr += `0(ノーマル)-, `;
    else rateStr += `0(ノーマル)～${t1-1}, `;
    
    rateStr += `1(レア)～${t2-1}, `;
    rateStr += `2(激レア)～${t3-1}, `;
    rateStr += `3(超激レア)～${t4-1}, `;
    rateStr += `4(伝説レア)～9999`;
    html += rateStr + `<br>`;
    
    html += `(各レアリティ別アイテム)<br>`;
    const rarities = ['0.ノーマル', '1.レア', '2.激レア', '3.超激レア', '4.伝説レア'];
    for (let i = 0; i <= 4; i++) {
        const pool = gacha.rarityItems[i.toString()];
        if (pool && pool.length > 0) {
            const itemsStr = pool.map(id => `${itemMaster[id].name}(ID:${id})`).join(', ');
            html += `${rarities[i]}(${pool.length}種) ${itemsStr}<br>`;
        }
    }
    return html + '<br>';
}

function getFormattedItemComparison(nodeItemName, nodeItemId, nodeRarityId, prevItemId, comparisonTargetName) {
    const rComp = (nodeRarityId === 1) ? '1=1' : `${nodeRarityId}≠1`;
    let idComp = '';
    let targetDisplay = '';

    if (comparisonTargetName) {
         targetDisplay = comparisonTargetName;
    } else {
         targetDisplay = (prevItemId === -1) ? 'Null' : `${prevItemId}`;
    }

    if (prevItemId === -1) {
         idComp = (nodeItemId === -1) ? '=Null' : '≠Null'; 
    } else {
         idComp = (nodeItemId === prevItemId) ? `=${targetDisplay}` : `≠${targetDisplay}`;
    }
    
    const text = `${nodeItemName}(${nodeItemId}(${rComp})${idComp})`;
    return { text, isDupe: (nodeRarityId === 1 && nodeItemId !== -1 && nodeItemId === prevItemId) };
}

/**
 * アイテムリンク生成ヘルパー
 * fs: 現在の残り目玉数 (指定がない場合はnull/undefined)
 * ng: 次の確定までの回数 (指定がない場合は計算しない、またはnone)
 */
function generateItemLink(newSeed, newItemId, ngVal, rollNumberInSequence, isCompleted, fsVal) {
    // グローバルの activeGachaId を参照
    const gId = window.activeGachaId; 
    const currentParams = new URLSearchParams(window.location.search);
    const paramsForQuery = {};
    for (const [key, value] of currentParams.entries()) paramsForQuery[key] = value;
    if (!paramsForQuery.gacha) paramsForQuery.gacha = gId;

    paramsForQuery.seed = newSeed;
    if (newItemId !== undefined) paramsForQuery.lr = newItemId;

    // fsパラメータの設定
    if (fsVal !== undefined && fsVal !== null && !isNaN(fsVal)) {
        paramsForQuery.fs = fsVal;
    }

    // ngパラメータの設定
    // 引数で明示的に渡された場合のみ設定する方針
    if (ngVal !== undefined && ngVal !== null) {
        if (ngVal === 'none') {
             paramsForQuery.ng = 'none';
        } else {
             paramsForQuery.ng = ngVal.toString();
        }
    } else {
        // 既存ロジック互換（今回は使用しないが念のため残す）
        const initialInputNg = paramsForQuery.ng; // 元のクエリから取得
        // ...既存の計算ロジックが必要ならここに記述...
        // 今回は呼び出し元で計算した値を渡すため、ここはスルー
    }
    
    return generateUrlQuery(paramsForQuery);
}

====================
FILE: view-completed.js
====================
/**
 * 担当: 「コンプ済み」ビューのメインテーブルおよび計算詳細のHTML描画
 * 依存関係: logic-completed.js (計算データの取得), utils.js (リンク生成の利用)
 */

function createAndDisplayCompletedSeedView(initialSeed, gacha, tableRows, thresholds, initialLastRollId, displaySeed, params, initialNg) {
    const { Nodes, highlightInfo, maxNodeIndex } = calculateCompletedData(
        initialSeed, gacha, tableRows, thresholds, initialLastRollId, initialNg
    );

    let detailsHtml = generateMasterInfoHtml(gacha);
    detailsHtml += '<h2>＜ノード計算詳細 (No.1～)＞</h2>';
    
    let lastRollText = 'Null';
    if (initialLastRollId && itemMaster[initialLastRollId]) {
        const item = itemMaster[initialLastRollId];
        lastRollText = `${item.name}(rarity:${item.rarity}, itemID:${initialLastRollId})`;
    }
    detailsHtml += `LastRoll：${lastRollText}<br><br>`;

    detailsHtml += '<table style="table-layout: fixed; width: auto; font-size: 9px; border-collapse: collapse;"><thead>';
    detailsHtml += '<tr style="background-color: #f2f2f2;">';
    detailsHtml += '<th style="border: 1px solid #ccc; padding: 5px;">No.</th>';
    detailsHtml += '<th style="border: 1px solid #ccc; padding: 5px;">Address</th>'; 
    detailsHtml += '<th style="border: 1px solid #ccc; padding: 5px;">Seed</th>';
    detailsHtml += '<th style="border: 1px solid #ccc; padding: 5px;">rarity</th>';
    detailsHtml += '<th style="border: 1px solid #ccc; padding: 5px;">Item</th>';
    detailsHtml += '<th style="border: 1px solid #ccc; padding: 5px;">Reroll</th>';
    detailsHtml += '<th style="border: 1px solid #ccc; padding: 5px;">ReRollFlag</th>';
    detailsHtml += '<th style="border: 1px solid #ccc; padding: 5px;">re-ReRollFlag</th>';
    detailsHtml += '<th style="border: 1px solid #ccc; padding: 5px;">rarityG</th>';
    detailsHtml += '<th style="border: 1px solid #ccc; padding: 5px;">uberG</th>'; 
    detailsHtml += '<th style="border: 1px solid #ccc; padding: 5px;">legendG</th>';
    detailsHtml += '<th style="border: 1px solid #ccc; padding: 5px;">Single<br>(next)</th>';
    detailsHtml += '<th style="border: 1px solid #ccc; padding: 5px;">TenPull<br>(next)</th>';
    detailsHtml += '</tr></thead><tbody>'; 
    
    let tableRowsDataHtml = []; 
    for (let i = 1; i <= maxNodeIndex; i++) {
        const node = Nodes[i-1];
        if (!node) continue;
        
        let singleDisplay = '';
        if (node.singleRoll !== null) {
            const rollNum = node.singleRoll.toString();
            if (node.singleUseSeeds !== null && node.singleNextAddr) {
                const nextIndex = node.index + node.singleUseSeeds;
                singleDisplay = `Roll${rollNum}<br><span style="font-size: 80%;">${node.index}+${node.singleUseSeeds}=${nextIndex}(${node.singleNextAddr})</span>`;
            } else { singleDisplay = rollNum; }
        }

        let tenPullDisplay = '';
        if (node.tenPullMark !== null) {
            const rollMark = node.tenPullMark.toString();
            if (node.tenPullMark === 'r') {
                if (node.tenPullUseSeeds !== null && node.tenPullNextAddr) {
                    const nextIndex = node.index + node.tenPullUseSeeds;
                    tenPullDisplay = `${rollMark}<br><span style="font-size: 80%;">${node.index}+${node.tenPullUseSeeds}=${nextIndex}(${node.tenPullNextAddr})</span>`;
                } else { tenPullDisplay = rollMark; }
            } else if (node.tenPullUseSeeds !== null && node.tenPullNextAddr) {
                 const nextIndex = node.index + node.tenPullUseSeeds;
                 let displayRollNum = rollMark;
                 if (typeof node.tenPullMark === 'number' || (typeof node.tenPullMark === 'string' && !node.tenPullMark.startsWith('↖'))) {
                     displayRollNum = `Roll${rollMark}`;
                 } else if (typeof node.tenPullMark === 'string' && node.tenPullMark.startsWith('↖')) {
                     const gRollNum = rollMark.slice(1).replace('g', '');
                     const gNode = Nodes[node.index - 2]; 
                     if (gNode) { displayRollNum = `Roll${gRollNum}g(${gNode.address}G)`; } else { displayRollNum = `Roll${rollMark}`; }
                 }
                 tenPullDisplay = `${displayRollNum}<br><span style="font-size: 80%;">${node.index}+${node.tenPullUseSeeds}=${nextIndex}(${node.tenPullNextAddr})</span>`;
            } else { tenPullDisplay = rollMark; }
        }
        
        const itemInfo = highlightInfo.get(node.address);
        const baseCls = determineHighlightClass(itemInfo);
        let itemClsForNormal = '', itemClsForReroll = '';
        if (itemInfo) {
            const usedNormal = (itemInfo.single && !itemInfo.s_reRoll) || (itemInfo.ten && !itemInfo.t_reRoll);
            const usedReroll = (itemInfo.single && itemInfo.s_reRoll) || (itemInfo.ten && itemInfo.t_reRoll);
            if (usedNormal) itemClsForNormal = baseCls;
            if (usedReroll) itemClsForReroll = baseCls;
        }
        const itemClsAttr = itemClsForNormal ? ` class="${itemClsForNormal}"` : '';
        const rerollClsAttr = itemClsForReroll ? ` class="${itemClsForReroll}"` : '';

        let itemContent = (node.itemId !== -1) ? `${node.itemName}<br><span style="font-size: 80%;">${node.seed2}%${node.poolSize}=${node.slot}</span>` : '-';
        const reRollDivisor = node.poolSize > 1 ? node.poolSize - 1 : 0; 
        let rerollContent = (node.reRollItemId !== -1) ? `${node.reRollItemName}<br><span style="font-size: 80%;">${node.seed3}%${reRollDivisor}=${node.reRollSlot}</span>` : '-';

        const guaranteedInfo = highlightInfo.get(node.address + 'G');
        const guaranteedCls = determineHighlightClass(guaranteedInfo);
        let uberGClsAttr = '', legendGClsAttr = '';
        if (guaranteedInfo && guaranteedCls) {
            if (node.rarityGId === '3' && node.itemGId !== -1) uberGClsAttr = ` class="${guaranteedCls}"`;
            else if (node.rarityGId === '4' && node.itemGId !== -1) legendGClsAttr = ` class="${guaranteedCls}"`;
        }
        let uberGContent = (node.rarityGId === '3' && node.itemGId !== -1) ? `${node.itemGName}<br><span style="font-size: 80%;">${node.seed2}%${node.poolGSize}=${node.slotG}</span>` : '-';
        let legendGContent = (node.rarityGId === '4' && node.itemGId !== -1) ? `${node.itemGName}<br><span style="font-size: 80%;">${node.seed2}%${node.poolGSize}=${node.slotG}</span>` : '-';
        
        let isConsecutiveDupe = false;
        if (i > 3) {
            const pNodeRe = Nodes[i-4];
            if (pNodeRe && node.rarityId === 1 && pNodeRe.reRollFlag && node.itemId === pNodeRe.reRollItemId) { isConsecutiveDupe = true; }
        }
        let prevItemName = (i <= 2) ? getItemNameSafe(initialLastRollId) : (Nodes[i - 3]?.reRollFlag ? (Nodes[i - 3].reRollItemName || '---') : (Nodes[i - 3]?.itemName || '---'));
        let reRollFlagContent = (node.reRollFlag ? 'true' : 'false') + `<br><span style="font-size: 80%;">${node.itemName}vs${prevItemName}</span>`;
        let prevReRollItemName = (i > 3) ? (Nodes[i-4]?.reRollFlag ? (Nodes[i-4].reRollItemName || '---') : (Nodes[i-4]?.itemName || '---')) : '---';
        let reReRollFlagContent = (isConsecutiveDupe ? 'true' : 'false') + `<br><span style="font-size: 80%;">${node.itemName}vs${prevReRollItemName}</span>`;
        let rarityGContent = (node.rarityGId || '-') + `<br><span style="font-size: 80%;">${node.roll1}</span>`; 

        let rowHtml = '<tr>';
        rowHtml += `<td style="border: 1px solid #ccc; padding: 5px; text-align: center;">${node.index}</td>`;
        rowHtml += `<td style="border: 1px solid #ccc; padding: 5px; text-align: center;">${node.address}</td>`;
        rowHtml += `<td style="border: 1px solid #ccc; padding: 5px; text-align: right; font-family: monospace;">${node.seed1}</td>`;
        rowHtml += `<td style="border: 1px solid #ccc; padding: 5px; text-align: center;">${node.rarityId}<br><span style="font-size: 80%;">${node.roll1}</span></td>`;
        rowHtml += `<td style="border: 1px solid #ccc; padding: 5px; text-align: center;"${itemClsAttr}>${itemContent}</td>`;
        rowHtml += `<td style="border: 1px solid #ccc; padding: 5px; text-align: center;"${rerollClsAttr}>${rerollContent}</td>`;
        rowHtml += `<td style="border: 1px solid #ccc; padding: 5px; text-align: center;">${reRollFlagContent}</td>`;
        rowHtml += `<td style="border: 1px solid #ccc; padding: 5px; text-align: center;">${reReRollFlagContent}</td>`;
        rowHtml += `<td style="border: 1px solid #ccc; padding: 5px; text-align: center;">${rarityGContent}</td>`;
        rowHtml += `<td style="border: 1px solid #ccc; padding: 5px; text-align: center;"${uberGClsAttr}>${uberGContent}</td>`;
        rowHtml += `<td style="border: 1px solid #ccc; padding: 5px; text-align: center;"${legendGClsAttr}>${legendGContent}</td>`;
        rowHtml += `<td style="border: 1px solid #ccc; padding: 5px; text-align: center;">${singleDisplay}</td>`;
        rowHtml += `<td style="border: 1px solid #ccc; padding: 5px; text-align: center;">${tenPullDisplay}</td>`;
        rowHtml += '</tr>';
        tableRowsDataHtml.push(rowHtml);
    }
    
    let table = `<table style="table-layout: fixed;" class="${currentHighlightMode === 'single' ? 'mode-single' : (currentHighlightMode === 'multi' ? 'mode-multi' : '')}"><thead>`;
    table += `<tr><th id="forceRerollToggle" class="col-no" style="cursor: pointer;">${window.forceRerollMode ? '☑' : '□'}</th><th>A</th><th>AG</th><th><th>B</th><th>BG</th></tr>`;
    table += '</thead><tbody>';

    for (let r = 1; r <= tableRows; r++) {
        const nodeIdxA = (r - 1) * 2 + 1, nodeIdxB = (r - 1) * 2 + 2;
        const nodeA = Nodes[nodeIdxA - 1], nodeB = Nodes[nodeIdxB - 1];
        if (!nodeA || !nodeB) break;
        table += `<tr><td class="col-no">${r}</td>`;
        const renderCell = (node, suffix) => {
            const address = node.address + suffix, info = highlightInfo.get(address), isGuaranteed = (suffix === 'G');
            const itemId = isGuaranteed ? node.itemGId : node.itemId, itemName = isGuaranteed ? node.itemGName : node.itemName, itemRarity = itemMaster[itemId]?.rarity;
            let cellContent = '---';
            if (itemId !== -1) {
                const isTenDark = info && info.ten && (info.tenRoll % 10 === 0);
                let showReRoll = (info && !isGuaranteed && ((info.single && info.s_reRoll) || (info.ten && info.t_reRoll))) || (!isGuaranteed && (node.reRollFlag || (window.forceRerollMode && node.rarityId === 1 && node.poolSize > 1)));
                const seedForSingle = showReRoll ? node.seed3 : node.seed2;
                if (isTenDark && !isGuaranteed) {
                    const hrefSingle = generateItemLink(seedForSingle, itemId, initialNg, r, true);
                    const seedForTen = (node.tenPullUseSeeds === 3) ? node.seed3 : node.seed2;
                    const hrefTen = generateItemLink(seedForTen, itemId, initialNg, r, true);
                    let cssClass = (itemRarity === 4) ? 'legendItem-text' : (itemRarity >= 3 ? 'featuredItem-text' : '');
                    cellContent = `<a href="${hrefSingle}"${cssClass ? ' class="'+cssClass+'"' : ''}>${itemName}</a><br>単発:<a href="${hrefSingle}">${node.singleNextAddr || '---'}</a>/10連:<a href="${hrefTen}">${node.tenPullNextAddr || '---'}</a>`;
                } else {
                    const href = generateItemLink(seedForSingle, itemId, initialNg, r, true);
                    let nameHtml = `<a href="${href}">${itemName}</a>`;
                    if (!isGuaranteed) {
                        const css = (itemRarity === 4) ? 'legendItem-text' : (itemRarity >= 3 ? 'featuredItem-text' : '');
                        if (css) nameHtml = `<span class="${css}">${nameHtml}</span>`;
                    }
                    if (showReRoll) {
                        const rrId = node.reRollItemId, hrefRe = generateItemLink(node.seed3, rrId, initialNg, r, true);
                        let rrNameHtml = `<a href="${hrefRe}">${node.reRollItemName}</a>`;
                        const rrRarity = itemMaster[rrId]?.rarity;
                        if (rrRarity === 4) rrNameHtml = `<span class="legendItem-text">${rrNameHtml}</span>`; else if (rrRarity >= 3) rrNameHtml = `<span class="featuredItem-text">${rrNameHtml}</span>`;
                        const hrefNorm = generateItemLink(node.seed2, node.itemId, initialNg, r, true);
                        cellContent = `<a href="${hrefNorm}">${node.itemName}</a><br>${node.reRollNextAddress})${rrNameHtml}`;
                    } else { cellContent = nameHtml; }
                }
            }
            let cls = determineHighlightClass(info);
            return { html: `<td${cls ? ' class=\"'+cls+'\"' : ''}>${cellContent}</td>` };
        };
        table += renderCell(nodeA, '').html; table += renderCell(nodeA, 'G').html;
        table += renderCell(nodeB, '').html; table += renderCell(nodeB, 'G').html;
        table += '</tr>';
    }
    table += '</tbody></table>';
    document.getElementById('result-table-container').innerHTML = table;

    // --- シミュレーションUIの実装 ---
    const detailsControls = document.getElementById('details-controls');
    let simGroup = document.getElementById('sim-ui-group');
    if (!simGroup) {
        simGroup = document.createElement('div');
        simGroup.id = 'sim-ui-group';
        simGroup.style.display = 'flex';
        simGroup.style.alignItems = 'center';
        simGroup.style.gap = '8px';
        simGroup.style.marginLeft = '12px';
        simGroup.innerHTML = `
            <input type="number" id="simTicketInput" value="30" style="width: 50px; padding: 4px; border: 1px solid #ccc; border-radius: 4px;">
            <button id="runSimBtn" style="background-color: #28a745; color: white; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer;">シミュレーション開始</button>
        `;
        detailsControls.appendChild(simGroup);
        
        const resultDisplay = document.createElement('div');
        resultDisplay.id = 'sim-result-text';
        resultDisplay.style.marginTop = '20px';
        resultDisplay.style.padding = '15px';
        resultDisplay.style.border = '1px dashed #28a745';
        resultDisplay.style.backgroundColor = '#fafffa';
        resultDisplay.style.whiteSpace = 'pre-wrap';
        resultDisplay.style.fontFamily = 'monospace';
        resultDisplay.style.display = 'none';
        document.getElementById('result-container').appendChild(resultDisplay);
    }

    document.getElementById('runSimBtn').onclick = () => {
        const tickets = parseInt(document.getElementById('simTicketInput').value);
        if (isNaN(tickets) || tickets <= 0) return alert("有効な枚数を入力してください");
        
        const result = runGachaBeamSearch(Nodes, initialLastRollId, tickets, gacha, thresholds, initialNg);
        const display = document.getElementById('sim-result-text');
        
        if (!result) {
            display.textContent = "条件に合うルートが見つかりませんでした。";
        } else {
            let text = `【最適ルートシミュレーション結果】(超激レア:${result.ubers}, 伝説レア:${result.legends})\n\n`;
            let path = result.path;
            let i = 0;
            while (i < path.length) {
                if (path[i].type === 'single') {
                    let j = i, items = [];
                    while (j < path.length && path[j].type === 'single') {
                        items.push(path[j].item);
                        j++;
                    }
                    text += `単発${j - i}ロール/${path[i].addr}～\n${items.join('、')}\n`;
                    i = j;
                } else {
                    text += `10連/${path[i].addr}～\n${path[i].items.join('、')}\n`;
                    i++;
                }
            }
            display.textContent = text;
        }
        display.style.display = 'block';
    };

    const detailsDiv = document.getElementById('calculation-details');
    detailsDiv.innerHTML = detailsHtml + tableRowsDataHtml.join('') + '</tbody></table>';
    const toggleBtn = document.getElementById('toggleDetailsBtn');
    detailsControls.style.display = 'flex';
    toggleBtn.onclick = () => {
        if (detailsDiv.style.display === 'none') {
            detailsDiv.style.display = 'block';
            toggleBtn.textContent = '計算過程を非表示';
        } else {
            detailsDiv.style.display = 'none';
            toggleBtn.textContent = '計算過程を表示';
        }
    };
}

====================
FILE: view-uncompleted-details.js
====================
/**
 * 担当: 「未コンプ」ビューの下部に表示される計算過程および10連詳細のHTML描画
 * 依存関係: utils.js (generateItemLinkの利用)
 */

/**
 * 詳細テーブル（計算過程）と10連詳細のHTMLを生成してDOMに挿入
 */
function renderUncompletedDetails(Nodes, highlightInfo, maxNodes, tenPullCyclesData, gacha, initialLastRollId, params) {
    const ngVal = parseInt(params.get('ng'), 10);
    const initialFs = parseInt(params.get('fs'), 10) || 0;
    const guaranteedCycle = gacha.guaranteedCycle || 30;
    let ngTrackerDetail = !isNaN(ngVal) && ngVal > 0 ? ngVal : guaranteedCycle;

    // --- 1. 計算詳細 (単発ガチャ詳細) のHTML組み立て ---
    let html = generateMasterInfoHtml(gacha);
    
    let lastRollText = 'Null';
    if (initialLastRollId && itemMaster[initialLastRollId]) {
        lastRollText = `${itemMaster[initialLastRollId].name}(${initialLastRollId}(${itemMaster[initialLastRollId].rarity}))`;
    }

    html += '<h2>＜ノード計算詳細 (No.1～)＞</h2>';
    html += `LastRoll：${lastRollText}<br><br>単発ガチャ詳細<br>`;
    html += '<table style="table-layout: fixed; width: auto; font-size: 9px; border-collapse: collapse;"><thead>';
    html += '<tr style="background-color: #f2f2f2;">';
    html += '<th style="border: 1px solid #ccc; padding: 5px;">No.<br>Address</th><th style="border: 1px solid #ccc; padding: 5px;">Seed<br>(Sn)</th><th style="border: 1px solid #ccc; padding: 5px;">Featured<br>(Sn)</th><th style="border: 1px solid #ccc; padding: 5px;">Rarity<br>(Sn+1)</th><th style="border: 1px solid #ccc; padding: 5px;">Item<br>(Sn+2)</th><th style="border: 1px solid #ccc; padding: 5px;">Reroll<br>(Sn+3)</th><th style="border: 1px solid #ccc; padding: 5px;">ReRollFlag<br>Crnt vs Prev</th><th style="border: 1px solid #ccc; padding: 5px;">Roll<br>(next)</th><th style="border: 1px solid #ccc; padding: 5px;">NextGuar<br>aftRoll</th>'; 
    html += '</tr></thead><tbody>'; 

    for (let i = 1; i <= maxNodes; i++) {
        const node = Nodes[i-1];
        if (!node) continue;
        
        // NGカウンター更新
        let ngContentDetail = '-';
        if (node.singleRoll !== null) {
            let nextNg = ngTrackerDetail - 1;
            if (ngTrackerDetail === 1) { 
                 const nextStartNg = guaranteedCycle - 1; 
                 ngContentDetail = `目玉(確定)<br>${guaranteedCycle}→${nextStartNg}`;
                 ngTrackerDetail = nextStartNg;
            } else if (ngTrackerDetail > 1) {
                ngContentDetail = nextNg.toString();
                ngTrackerDetail = nextNg;
            }
        }
        
        // Highlight logic
        const itemInfo = highlightInfo.get(node.address);
        const baseCls = determineHighlightClass(itemInfo);
        let featuredClsAttr = '', itemClsForNormal = '', itemClsForReroll = '';

        if (itemInfo) {
            if (itemInfo.single && itemInfo.s_featured) featuredClsAttr = ` class="${baseCls}"`; 
            if ((itemInfo.single && !itemInfo.s_reRoll && !itemInfo.s_featured) || (itemInfo.ten && !itemInfo.t_reRoll)) itemClsForNormal = baseCls; 
            if ((itemInfo.single && itemInfo.s_reRoll) || (itemInfo.ten && itemInfo.t_reRoll)) itemClsForReroll = baseCls; 
        }

        // 修正箇所: 変数定義を追加
        const itemClsAttr = itemClsForNormal ? ` class="${itemClsForNormal}"` : '';
        const rerollClsAttr = itemClsForReroll ? ` class="${itemClsForReroll}"` : '';

        // Columns Content
        let singleDisplay = node.singleRoll !== null ? node.singleRoll.toString() : '';
        if (node.singleRoll !== null && node.singleUseSeeds !== null) {
             singleDisplay += `<br>${node.index}+${node.singleUseSeeds}<br>${node.index + node.singleUseSeeds}(${node.singleNextAddr})`;
        }

        // Featured Content
        let featuredContent = node.isFeatured ? 'True' : 'False';
        if (node.isFeatured) {
             const fHref = generateItemLink(node.seed1, -2, node.guaranteedNextNgVal || ngVal, node.index, false, initialFs);
             featuredContent = `<a href="${fHref}" style="text-decoration: none; color: inherit;">True</a>`;
        }
        featuredContent += `<br>S${node.index}%10000<br>${node.seed1 % 10000}${node.isFeatured ? '<' : '>='}${gacha.featuredItemRate}`;

        // Rarity Content
        let rarityContent = `${node.rarityId}(${node.rarity.name})<br>S${node.index + 1}%10000<br><span style="font-size: 80%;">${node.rarityRateRangeDisplay}</span>`;

        // Item & Reroll Content
        let itemContent = '-';
        if (node.itemId !== -1) {
             const nextNg = node.isGuaranteedRoll ? (guaranteedCycle - 1) : ngTrackerDetail;
             const iHref = generateItemLink(node.seed3, node.itemId, nextNg, node.index + 1, false, initialFs);
             let style = node.isFeatured && itemInfo && itemInfo.single ? "color: red; font-weight: bold;" : "";
             if (node.isGuaranteedRoll) {
                 const gHref = generateItemLink(node.prevSeed1, node.singleCompareItemId, guaranteedCycle, node.index, false, initialFs);
                 itemContent = `<a href="${gHref}" class="featuredItem-text">目玉(確定)</a> / <a href="${iHref}">${node.itemName}</a>`;
             } else {
                 itemContent = `<a href="${iHref}" style="${style}">${node.itemName}</a>`;
             }
             itemContent += `<br>S${node.index+2}%${node.poolSize}<br>${node.slot}→ID:${node.itemId}`;
        }

        let rerollContent = '-';
        if (node.reRollItemId !== -1) {
             const nextNg = node.isGuaranteedRoll ? (guaranteedCycle - 1) : ngTrackerDetail;
             const rHref = generateItemLink(node.seed4, node.reRollItemId, nextNg, node.index + 1, false, initialFs);
             rerollContent = `<a href="${rHref}">${node.reRollItemName}</a><br>S${node.index+3}%${node.poolSize>1?node.poolSize-1:0}<br>${node.reRollSlot}→ID:${node.reRollItemId}`;
        }

        // ReRoll Flag (Simplified)
        let reRollFlagContent = node.reRollFlag || '-'; 
        if (!node.reRollFlag && node.singleRoll) {
             reRollFlagContent = node.singleIsReroll ? 'True' : 'False';
             if (node.rarityId===1 && !node.isFeatured) reRollFlagContent += `<br>レア→Yes<br>${node.itemId}vs${node.singleCompareItemId}`;
             else if (node.isFeatured) reRollFlagContent += '<br>目玉→No';
             else reRollFlagContent += '<br>Other→No';
        }

        html += `<tr>
            <td style="border: 1px solid #ccc; padding: 5px; text-align: center;">${node.index}<br>${node.address}</td>
            <td style="border: 1px solid #ccc; padding: 5px; text-align: center; font-family: monospace;">S${node.index}<br>${node.seed1}</td>
            <td style="border: 1px solid #ccc; padding: 5px; text-align: center;"${featuredClsAttr}>${featuredContent}</td>
            <td style="border: 1px solid #ccc; padding: 5px; text-align: center;">${rarityContent}</td>
            <td style="border: 1px solid #ccc; padding: 5px; text-align: center;"${itemClsAttr}>${itemContent}</td>
            <td style="border: 1px solid #ccc; padding: 5px; text-align: center;"${rerollClsAttr}>${rerollContent}</td>
            <td style="border: 1px solid #ccc; padding: 5px; text-align: center;">${reRollFlagContent}</td>
            <td style="border: 1px solid #ccc; padding: 5px; text-align: center;">${singleDisplay}</td>
            <td style="border: 1px solid #ccc; padding: 5px; text-align: center;">${ngContentDetail}</td>
        </tr>`;
    }
    html += '</tbody></table>';

    // --- 2. 10連詳細セクション ---
    if (tenPullCyclesData && tenPullCyclesData.length > 0) {
        html += '<h2 style="margin-top:20px;">＜10連詳細 (現在地からのシミュレーション / 10サイクル)＞</h2>';
        let cumulativeFs = initialFs;
        
        tenPullCyclesData.forEach((cycle, idx) => {
            const count = cycle.featuredCountInCycle || 0;
            cumulativeFs -= count;
            
            html += `<div style="margin-top: 15px; border: 1px solid #000; padding: 10px; background-color: #fcfcfc;">`;
            html += `<h3>【Cycle ${idx + 1}】 (目玉: ${count})</h3>`;
            html += `<p>NG開始: ${cycle.startNgVal}, LastRoll: ${getItemNameSafe(cycle.startLastRollId)}</p>`;
            html += `<p>判定: ${cycle.guaranteedStatus}</p>`;
            
            html += '<h4>[Log]</h4><ul>';
            cycle.processLog.forEach(l => html += `<li style="font-size: 0.8rem;">${l}</li>`);
            html += '</ul>';

            html += '<h4>[Result]</h4><table style="border-collapse: collapse;">';
            cycle.results.forEach(res => {
                const style = res.isGuaranteed || res.isFeatured ? 'color: #d9534f; font-weight: bold;' : '';
                html += `<tr><td style="border: 1px solid #eee;">${res.label}</td><td style="border: 1px solid #eee; ${style}">${res.name}</td></tr>`;
            });
            html += '</table>';

            const linkUrl = generateItemLink(cycle.transition.nextSeed, cycle.transition.lastItemId, cycle.transition.nextNgVal, cycle.transition.nextIndex, false, cumulativeFs);
            html += `<p>Next: ${cycle.transition.nextIndex}(${cycle.transition.nextAddress}) → <a href="${linkUrl}" style="font-weight: bold; color: blue;">遷移する</a></p>`;
            html += '</div>';
        });
    }

    // DOM挿入
    const detailsDiv = document.getElementById('calculation-details'); 
    detailsDiv.innerHTML = html;
}

====================
FILE: view-uncompleted-table.js
====================
/**
 * 担当: 「未コンプ」ビューのメインテーブルおよび期待値情報のHTML描画
 * 依存関係: utils.js (generateItemLinkの利用)
 */

/**
 * 未コンプビューのメインテーブル（期待値表示含む）を生成してDOMに挿入する関数
 * @param {Array} Nodes - 計算済みの全ノードデータ
 * @param {Map} highlightInfo - ハイライト情報（単発ルート、10連ルートの判定用）
 * @param {Array} tenPullCyclesData - 10連シミュレーションの結果データ
 * @param {Object} expectedFeaturedCounts - 期待値データ
 * @param {number} tableRows - 表示する行数
 * @param {string} displaySeed - '1'なら詳細表示、それ以外は通常表示
 * @param {number} initialNg - 初期のNext Guaranteed値
 * @param {number} initialFs - 初期のFeatured Stock値
 * @param {number} guaranteedCycle - 確定周期（通常30）
 */
function renderUncompletedMainTable(Nodes, highlightInfo, tenPullCyclesData, expectedFeaturedCounts, tableRows, displaySeed, initialNg, initialFs, guaranteedCycle) {
    
    // --- ヘルパー関数: アイテムCSS決定 ---
    function determineItemCss(itemId) {
        if (!itemMaster[itemId]) return '';
        if (itemMaster[itemId].rarity === 4) return 'legendItem-text';
        if (itemMaster[itemId].rarity >= 3) return 'featuredItem-text';
        return '';
    }

    // --- 期待値表示エリア ---
    let expectedValueHtml = '<div>';
    if (expectedFeaturedCounts) {
        expectedValueHtml += '<h3>＜単発Nroll後の10連での目玉獲得数予測＞</h3>'; 
        const expectedKeys = Object.keys(expectedFeaturedCounts).sort((a, b) => parseInt(a) - parseInt(b));
        
        const expectedValueText = expectedKeys.map(n => {
            const m = expectedFeaturedCounts[n];
            const rollNum = parseInt(n) + 1; 
            return `${rollNum}roll:<span style="font-weight: bold;">${Math.floor(m)}個</span>`;
        }).join(', ');
        
        expectedValueHtml += `<p style="font-size: 1.1em;">${expectedValueText}</p>`;
    } else {
        expectedValueHtml += '<p>期待値データが見つかりませんでした。</p>';
    }
    expectedValueHtml += '</div><br>';

    // --- テーブルヘッダー生成 ---
    let table = expectedValueHtml;
    table += '<table style="table-layout: fixed;"><thead>';
    
    let header1 = `<tr><th rowspan="${displaySeed === '1' ? 2 : 1}" id="forceRerollToggle" class="col-no" style="cursor: pointer;">${window.forceRerollMode ? '☑' : '□'}</th>`;
    let header2 = '<tr>';

    if (displaySeed === '1') {
        header1 += '<th colspan="5">A</th><th colspan="5">B</th><th colspan="5">C</th><th colspan="5">G</th>';
        const subHeaders = ['S1<br>Feat', 'S2<br>Rare', 'S3<br>Slot', 'S4<br>Re', 'Item'];
        for(let i=0; i<4; i++) header2 += subHeaders.map(h => `<th>${h}</th>`).join('');
    } else {
        header1 += '<th>A</th><th>B</th><th>C</th><th>G</th>';
    }
    header1 += '</tr>';
    
    if (displaySeed === '1') { header2 += '</tr>'; table += header1 + header2; } else { table += header1; }
    table += '</thead><tbody>';

    // --- メインループ変数の初期化 ---
    let currentNgVal = !isNaN(initialNg) ? initialNg : -1;
    let currentFsVal = initialFs;

    // --- メインループ (各行の生成) ---
    for (let r = 0; r < tableRows; r++) {
        table += `<tr><td class="col-no">${r + 1}</td>`;
        const nodeIndices = [r * 3 + 1, r * 3 + 2, r * 3 + 3]; // 1行あたりA, B, Cの3ノード
        
        // --- A, B, C 列の処理 ---
        nodeIndices.forEach((idx, colIndex) => {
            const node = Nodes[idx - 1];
            if (!node) {
                table += displaySeed === '1' ? '<td colspan="5"></td>' : '<td></td>';
                return;
            }

            const info = highlightInfo.get(node.address);
            let cls = determineHighlightClass(info);
            
            const isSingleRouteNode = info && info.single; // 単発ガチャのルートに存在するノードか
            const isGuaranteedNode = isSingleRouteNode && node.isGuaranteedRoll; // 単発ルートで確定ロールか

            let content = '';
            let linkFs = currentFsVal;
            
            // ReRollFlagの取得
            const nodeReRollFlag = node.reRollFlag; // logic側で計算済みと仮定

            // ----------------------------------------------------------------
            // Case 1: Single Route Logic (単発ガチャルート上のノード)
            // ----------------------------------------------------------------
            if (isSingleRouteNode) {
                 if (isGuaranteedNode) {
                     // 1-A. Guaranteed Roll Processing (確定ノード)
                     // Next NG resets to guaranteedCycle - 1 (例: 29)
                     const nextNg = guaranteedCycle - 1; 

                     // 目玉(確定)リンク (前の状態への遷移、NG=30)
                     const guaranteedLinkSeed = node.prevSeed1; 
                     const guaranteedLinkNg = guaranteedCycle; 
                     const guaranteedLinkFs = initialFs; // FSは減らない(仕様による)
                     const guaranteedHref = generateItemLink(guaranteedLinkSeed, node.singleCompareItemId, guaranteedLinkNg, node.index, false, guaranteedLinkFs);
                     const guaranteedLinkStyle = `text-decoration: none; color: inherit; font-weight: bold;`;
                     const guaranteedLink = `<a href="${guaranteedHref}" class="featuredItem-text" style="${guaranteedLinkStyle}">目玉(確定)</a>`; 

                     // アイテム名リンク (確定ロール後の状態への遷移、NG=29)
                     const itemDisplayName = node.itemName;
                     const itemLinkSeed = node.seed3; // S(n+2)
                     const itemLinkNg = guaranteedCycle - 1; 
                     const itemLinkFs = initialFs;
                     const itemHref = generateItemLink(itemLinkSeed, node.itemId, itemLinkNg, r+1, false, itemLinkFs);
                     const itemLinkStyle = `text-decoration: none; color: inherit; font-weight: normal;"`;
                     const itemNameLink = `<a href="${itemHref}" style="${itemLinkStyle}">${itemDisplayName}</a>`;

                     content = `${guaranteedLink} / ${itemNameLink}`;
                     
                     // 状態更新
                     currentNgVal = guaranteedCycle - 1; // 次のNG値をリセット
                     currentFsVal = linkFs; 

                 } else {
                     // 1-B. Normal Single Route Node (非確定ノード)
                     // 次のノードの開始NG値
                     let nextNg = (currentNgVal !== -1) ? currentNgVal - 1 : 'none';
                     if (nextNg !== 'none' && nextNg <= 0) nextNg = guaranteedCycle;
                     
                     if (node.isFeatured) {
                         // 目玉アイテムの場合
                         linkFs = currentFsVal - 1;
                         const currentSeedVal = node.seed1; 
                         const hrefFeatured = generateItemLink(currentSeedVal, -2, nextNg, r+1, false, linkFs);
                         content = `${node.featuredNextAddress})<a href="${hrefFeatured}"><span class="featuredItem-text">目玉</span></a>`;
                         currentFsVal -= 1; // FSカウンターを減らす
                     } else {
                        // 通常アイテム
                        const isRerollHighlight = info ? info.s_reRoll : false;
                        
                        if (isRerollHighlight) {
                             // 再抽選が行われたケース
                             const preRerollName = node.itemName; 
                             const postRerollId = node.reRollItemId;
                             const postRerollName = node.reRollItemName;
                             
                             // Pre-Reroll Link: S(n+2)
                             const preSeed = node.seed3; 
                             const preHref = generateItemLink(preSeed, node.itemId, nextNg, r+1, false, linkFs);
                             let preCss = determineItemCss(node.itemId);

                             // Post-Reroll Link: S(n+3)
                             const postSeed = node.seed4; 
                             const postHref = generateItemLink(postSeed, postRerollId, nextNg, r+1, false, linkFs);
                             let postCss = determineItemCss(postRerollId);

                             content = `<a href="${preHref}" class="${preCss}">${preRerollName}</a><br>${node.reRollNextAddress})<a href="${postHref}" class="${postCss}">${postRerollName}</a>`;

                        } else {
                             // 通常排出のケース
                             // Item Link: S(n+2)
                             const nextSeed = node.seed3; 
                             const finalId = node.itemId; 
                             const href = generateItemLink(nextSeed, finalId, nextNg, r+1, false, linkFs);
                             let css = determineItemCss(finalId);
                             content = `<a href="${href}" class="${css}">${node.itemName}</a>`;

                             // 再抽選候補リンク (ReRollFlagがTrueの場合、または強制再抽選モードの場合)
                             if (node.reRollItemId !== -1) { 
                                 if (node.singleIsReroll || window.forceRerollMode) { // node.singleIsReroll を参照
                                     // ReRoll Link: S(n+3)
                                     const rrHref = generateItemLink(node.seed4, node.reRollItemId, nextNg, r+1, false, linkFs); 
                                     let rrName = node.reRollItemName;
                                     let rrCss = determineItemCss(node.reRollItemId);
                                     content += `<br>${node.reRollNextAddress})<a href="${rrHref}" class="${rrCss}">${rrName}</a>`;
                                 }
                             }
                        }
                     }
                     // 状態更新
                     if (currentNgVal !== -1) {
                         currentNgVal -= 1; // 通常時は1減らす
                         if (currentNgVal <= 0) currentNgVal = guaranteedCycle;
                     }
                 }
            } else {
                // ----------------------------------------------------------------
                // Case 2: Off-Route Logic (ルート外の共通ロジック)
                // ----------------------------------------------------------------
                // リンクNG値は「次のロールの開始NG値」
                let linkNgVal = (initialNg !== -1) ? initialNg - (r + 1) : 'none';
                if (linkNgVal !== 'none' && linkNgVal <= 0) {
                    // 0以下になった場合、次のロールの開始NG値は guaranteedCycle - 1
                    // (ここでの計算は簡易的なため、厳密なNG追跡が必要ならLogic側で計算してNodeに持たせるのが理想)
                    linkNgVal = guaranteedCycle - 1;
                }
                const linkFsVal = initialFs; 
                
                if (node.isFeatured) {
                    // 目玉アイテムの場合
                    const currentSeed = node.seed1; 
                    const hrefFeatured = generateItemLink(currentSeed, -2, linkNgVal, r+1, false, linkFsVal);
                    content = `${node.featuredNextAddress})<a href="${hrefFeatured}"><span class="featuredItem-text">目玉</span></a>`;
                    
                } else {
                    const finalId = node.itemId;
                    const preRerollName = node.itemName; 
                    
                    // 1. Pre-Reroll / Normal Link: S(n+2)
                    const nextSeedNormal = node.seed3; 
                    const hrefNormal = generateItemLink(nextSeedNormal, finalId, linkNgVal, r+1, false, linkFsVal);
                    let cssNormal = determineItemCss(finalId);

                    content = `<a href="${hrefNormal}" class="${cssNormal}">${preRerollName}</a>`;
                    
                    // 再抽選リンク (重複再抽選フラグがTrueの場合、または強制再抽選モードの場合)
                    if (node.reRollItemId !== -1 && node.isDupe) {
                        if (window.forceRerollMode || (info && info.ten && info.t_reRoll)) { // 10連ルートの再抽選判定などを考慮
                            // 2. Post-Reroll Link: S(n+3)
                            const nextSeedReroll = node.seed4; 
                            const rrId = node.reRollItemId;
                            const rrName = node.reRollItemName;
                            const rrHref = generateItemLink(nextSeedReroll, rrId, linkNgVal, r+1, false, linkFsVal);
                            let rrCss = determineItemCss(rrId);
                            
                            content += `<br>${node.reRollNextAddress})<a href="${rrHref}" class="${rrCss}">${rrName}</a>`;
                        }
                    }
                }
            }

            // --- セルHTML生成 ---
            if (displaySeed === '1') {
                const sub1 = `(S${(idx-1)*3+1})${node.seed1}<br>${node.seed1%10000}<br>${node.isFeatured}`;
                const sub2 = `(S${(idx-1)*3+2})${node.seed2}<br>${node.seed2%10000}<br>${node.rarity.name}`;
                const sub3 = `(S${(idx-1)*3+3})${node.seed3}<br>${node.poolSize}<br>${node.slot}`;
                let sub4 = '---';
                if (!node.isFeatured && node.reRollItemId !== -1) {
                    sub4 = `(S${(idx-1)*3+4})${node.seed4}<br>ReRoll`;
                }
                table += `<td${cls ? ' class="'+cls+'"' : ''}>${sub1}</td><td${cls ? ' class="'+cls+'"' : ''}>${sub2}</td><td${cls ? ' class="'+cls+'"' : ''}>${sub3}</td><td${cls ? ' class="'+cls+'"' : ''}>${sub4}</td><td${cls ? ' class="'+cls+'"' : ''}>${content}</td>`;
            } else {
                table += `<td${cls ? ' class="'+cls+'"' : ''}>${content}</td>`;
            }
        });

        // --- G Column Logic (10連ガチャシミュレーション結果) ---
        let gContent = '-';
        let gStyle = '';
        
        const cycleIndex = Math.floor(r / 10);
        const rollIndex = r % 10;
        
        const tenPullDetailData = tenPullCyclesData ? tenPullCyclesData[cycleIndex] : null; 
        
        if (rollIndex < 9) { gStyle = 'background-color: #ffffe0;'; } else if (rollIndex === 9) { gStyle = 'background-color: #ffff8d;'; }

        if (tenPullDetailData && rollIndex < 10) {
            const res = tenPullDetailData.results[rollIndex];
            if (res) {
                let cellName = res.name;
                if (res.isReroll && res.preRerollName) {
                    cellName = `（${res.preRerollName}↓）<br>${cellName}`;
                }
                if (res.isGuaranteed) {
                    cellName = `<span class="featuredItem-text">${cellName}</span>`;
                } else if (res.isFeatured) {
                    cellName = `<span class="featuredItem-text">${cellName}</span>`;
                }

                if (rollIndex === 9) {
                    const addressStr = tenPullDetailData.transition.nextAddress;
                    let nextNg = tenPullDetailData.transition.nextNgVal;
                    
                    if (isNaN(nextNg) || nextNg <= 0) {
                        nextNg = guaranteedCycle - 1; 
                    }
                    
                    let usedFs = tenPullDetailData.featuredCountInCycle || 0;
                    let nextFs = initialFs - usedFs; // ※累積計算は簡易的（このサイクル分のみ減算）

                    const href10 = generateItemLink(
                        tenPullDetailData.transition.nextSeed,
                        tenPullDetailData.transition.lastItemId,
                        nextNg,
                        tenPullDetailData.transition.nextIndex, 
                        false, 
                        nextFs
                    );
                    gContent = `${addressStr})<a href="${href10}">${cellName}</a>`;
                } else {
                    gContent = cellName;
                }
            }
        }
        
        if (displaySeed === '1') table += `<td colspan="5" style="${gStyle}">${gContent}</td>`;
        else table += `<td style="${gStyle}">${gContent}</td>`;
        table += '</tr>';
    }
    table += '</tbody></table>';

    // DOMへの挿入
    document.getElementById('result-table-container').innerHTML = table;
}

====================
FILE: view-uncompleted.js
====================
/**
 * 担当: 「未コンプ」ビュー全体の描画制御および各コンポーネントの呼び出し
 * 依存関係: logic-uncompleted.js, view-uncompleted-table.js, view-uncompleted-details.js
 */

function createAndDisplayUncompletedSeedView(initialSeed, gacha, tableRows, thresholds, initialLastRollId, displaySeed, params) {
    // 1. データ計算 (Logic)
    const { 
        Nodes, highlightInfo, maxNodes, singleRoutePath, 
        tenPullCyclesData, expectedFeaturedCounts 
    } = calculateUncompletedData(initialSeed, gacha, tableRows, thresholds, initialLastRollId, params);
    
    // デバッグ出力
    console.log("Uncompleted Data Calculated:", { Nodes: Nodes.length, tenPullCyclesData, expectedFeaturedCounts });

    // パラメータ取得
    const ngVal = parseInt(params.get('ng'), 10);
    const initialFs = parseInt(params.get('fs'), 10) || 0; 
    const guaranteedCycle = gacha.guaranteedCycle || 30;
    let initialNg = !isNaN(ngVal) && ngVal > 0 ? ngVal : guaranteedCycle;

    // 2. 詳細画面 (Debug View) のレンダリング
    renderUncompletedDetails(Nodes, highlightInfo, maxNodes, tenPullCyclesData, gacha, initialLastRollId, params);

    // 3. メインテーブル (Main View) のレンダリング
    // 注意: view-uncompleted-table.js 内の関数です。元の view-uncompleted.js の複雑なリンク生成ロジックは
    // そちらに移動している前提です。
    renderUncompletedMainTable(Nodes, highlightInfo, tenPullCyclesData, expectedFeaturedCounts, tableRows, displaySeed, initialNg, initialFs, guaranteedCycle);

    // 4. 詳細表示トグルの制御
    const detailsDiv = document.getElementById('calculation-details');
    const detailsControls = document.getElementById('details-controls');
    const toggleBtn = document.getElementById('toggleDetailsBtn');
    const scrollButtons = detailsControls.querySelector('.scroll-buttons');
    if (scrollButtons) scrollButtons.remove();
    
    detailsControls.style.display = 'flex';
    toggleBtn.style.display = 'inline-block'; 
    toggleBtn.onclick = () => {
        if (detailsDiv.style.display === 'none') {
            detailsDiv.style.display = 'block';
            toggleBtn.textContent = '計算過程を非表示';
        } else {
            detailsDiv.style.display = 'none';
            toggleBtn.textContent = '計算過程を表示';
        }
    };
}

