====================
FILE: index.html
====================
<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>イベントガチャロールズ</title>
    <link rel="stylesheet" href="style.css">
    <link rel="icon" href="data:,">
</head>
<body>

<div class="container">
    <h1>イベントガチャロールズ</h1>
    <div class="input-group">
        <div class="controls">
            <div class="row">
                <div class="control-group-left">
                    <div class="input-item">
                         <a id="showSeedInputLink" href="#">SEED入力</a>
                    </div>
                    <div class="input-item" id="guaranteedControl">
                        <label for="guaranteedRollsInput">next guaranteed</label>
                        <select id="guaranteedRollsInput"></select>
                    </div>
                    <div class="input-item" id="legendDisplay" style="font-size: 0.7rem;">
                        <span id="legendSingle" class="legend-box legend-single">単発ルート</span>
                        <span id="legendMulti" class="legend-box legend-multi">10連ルート</span>
                        <span id="legendCommon" class="legend-box legend-common">共通ルート</span>
                    </div>
                    <div id="lastRollDisplay" class="input-item-display-only"></div>
                </div>
                <div class="control-group-right">
                    <div class="input-item">
                        <label for="featuredCompleteCheckbox">コンプ済み</label>
                        <input type="checkbox" id="featuredCompleteCheckbox">
                    </div>
                    <div class="input-item" id="stockControl">
                        <label for="featuredStockInput">目玉残数</label>
                        <select id="featuredStockInput"></select>
                    </div>
                    <a id="copySeedLink" href="#">Copy SEED</a>
                </div>
            </div>
            <div class="row hidden-control" id="seedRow">
                <div class="input-item-seed">
                    <label for="seedInput">SEED</label>
                    <div class="seed-input-group">
                        <input type="number" id="seedInput" value="123456789">
                        <button id="executeButton">更新</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div id="result-container">
        <div id="output"></div>
        <div id="result-table-container"></div>
        <div id="details-controls" style="display: none; margin-top: 10px; align-items: center; gap: 10px;">
            <button id="toggleDetailsBtn">計算過程を表示</button>
            <div class="scroll-buttons" style="display: none;">
                <button id="scrollToSingle">単発ルートへ</button>
                <button id="scrollToMulti">10連ルートへ</button>
            </div>
        </div>
        <div id="calculation-details" style="display:none;"></div>
    </div>
</div>

<script src="master.js"></script>
<script src="utils.js"></script>
<script src="logic-common.js"></script>
<script src="logic-completed.js"></script>
<script src="logic-uncompleted-sim.js"></script>
<script src="logic-uncompleted.js"></script>

<script src="view-completed-details-render.js"></script>
<script src="view-completed-path-sim.js"></script>
<script src="view-completed-main.js"></script>

<script src="view-uncompleted-details.js"></script>
<script src="view-uncompleted-table.js"></script>
<script src="view-uncompleted.js"></script>

<script src="main.js"></script>

</body>
</html>

====================
FILE: logic-common.js
====================
/**
 * 担当: シード配列生成、レアリティ判定、アドレス計算等の共通計算ロジック
 * 依存関係: utils.js (getItemNameSafe等の利用)
 */

// --- 共通ロジック ---

/**
 * シード配列を一括生成する
 */
function generateSeedList(initialSeed, count) {
    const seeds = [initialSeed];
    for (let i = 1; i < count; i++) {
        seeds[i] = xorshift32(seeds[i - 1]);
    }
    return seeds;
}

/**
 * ロール値と閾値からレアリティ情報を取得する
 */
function getRarityFromRoll(roll, thresholds) {
    if (roll < thresholds['0']) return { id: 0, name: 'ノーマル' };
    if (roll < thresholds['1']) return { id: 1, name: 'レア' };
    if (roll < thresholds['2']) return { id: 2, name: '激レア' };
    if (roll < thresholds['3']) return { id: 3, name: '超激レア' };
    return { id: 4, name: '伝説レア' };
}

/**
 * アドレス文字列 (1A, 1B, 2A...) を生成する
 * cols: 列数 (completed=2, uncompleted=3)
 */
function getAddressStringGeneric(n, cols) {
    if (n <= 0) return '';
    const zeroBasedIndex = n - 1;
    const col_char = String.fromCharCode('A'.charCodeAt(0) + (zeroBasedIndex % cols));
    const row_num = Math.floor(zeroBasedIndex / cols) + 1;
    return `${row_num}${col_char}`;
}

/**
 * アイテム名を取得する安全なヘルパー
 */
function getItemNameSafe(itemId) {
    if (itemId === -1 || itemId === undefined) return '---';
    return itemMaster[itemId]?.name || '---';
}

/**
 * ハイライトクラス判定ロジック
 */
function determineHighlightClass(info) {
    if (!info) return '';
    let cls = '';
    const isSingle10 = info.single && (info.singleRoll % 10 === 0);
    const isTen10 = info.ten && (info.tenRoll % 10 === 0);
    
    if (info.single && info.ten) {
        cls = (isSingle10 || isTen10) ? 'highlight-roll-overlap-dark' : 'highlight-roll-overlap';
    } else if (info.single) {
        cls = isSingle10 ? 'highlight-roll-dark' : 'highlight-roll';
    } else if (info.ten) {
        cls = isTen10 ? 'highlight-roll-10pull-dark' : 'highlight-roll-10pull';
    }
    return cls;
}

====================
FILE: logic-completed.js
====================
/**
 * 担当: 「コンプ済み」ビューにおける全アイテムの計算ロジック
 * 順序: Step 1 (通常・確定算出) -> Step 2 (再抽選) -> Step 3 (再々抽選) -> ルート計算・テキスト生成
 * 特徴: 消費シードインデックスの完全な線形連続性の確保
 */

function calculateCompletedData(initialSeed, gacha, tableRows, thresholds, initialLastRollId, initialNg) {
    const rarityNames = ["ノーマル", "レア", "激レア", "超激レア", "伝説レア"];
    const gCycle = gacha.guaranteedCycle || 30;
    
    // シードリストの生成 (探索用に余裕を持って確保)
    const maxSeedsNeeded = Math.max(tableRows * 15, 15000);
    const SEED_LIST = generateSeedList(initialSeed, maxSeedsNeeded);
    
    const getAddress = (n) => getAddressStringGeneric(n, 2);
    const Nodes = [];

    // 全ノードに対して各ステップの計算を事前に行う
    const maxNodeIndex = Math.max(tableRows * 5, 5000);

    // --- Step 1: 全ノードの基本算出 (通常抽選 & 確定枠) ---
    for (let i = 1; i <= maxNodeIndex; i++) {
        const node = {
            index: i,
            address: getAddress(i),
            seed1: SEED_LIST[i],     // rarity判定用 (または確定枠Slot用)
            seed2: SEED_LIST[i + 1], // slot判定用
            seed3: SEED_LIST[i + 2], // 再抽選用
            seed4: SEED_LIST[i + 3], // 再々抽選用
        };

        // 通常枠の算出
        node.roll1 = node.seed1 % 10000;
        node.rarity = getRarityFromRoll(node.roll1, thresholds);
        node.rarityId = node.rarity.id;
        
        const pool = gacha.rarityItems[node.rarityId] || [];
        node.poolSize = pool.length;
        if (pool.length > 0) {
            node.slot = node.seed2 % pool.length;
            node.itemId = pool[node.slot];
            node.itemName = getItemNameSafe(node.itemId);
        } else {
            node.slot = 0;
            node.itemId = -1; node.itemName = '---';
        }

        // 確定枠の算出 (このノードで10連を開始した場合の期待値)
        const uFlag = gacha.uberGuaranteedFlag;
        const lFlag = gacha.legendGuaranteedFlag;
        const uRate = uFlag ? (gacha.rarityRates['3'] || 500) : 0;
        const lRate = lFlag ? (gacha.rarityRates['4'] || 200) : 0;
        node.gDivisor = uRate + lRate;
        if (node.gDivisor > 0) {
            node.gRoll = node.seed1 % node.gDivisor;
            node.rarityGId = (node.gRoll < uRate) ? '3' : '4';
            node.rarityGName = (node.rarityGId === '3') ? '超激レア' : '伝説レア';
            const poolG = gacha.rarityItems[node.rarityGId] || [];
            node.poolGSize = poolG.length;
            node.slotG = node.seed1 % poolG.length;
            node.itemGId = poolG[node.slotG];
            node.itemGName = getItemNameSafe(node.itemGId);
        } else {
            node.rarityGId = null;
            node.rarityGName = '-'; node.itemGId = -1; node.itemGName = '---';
        }

        Nodes.push(node);
    }

    // --- Step 2 & 3: 再抽選・再々抽選ロジックの適用 ---
    Nodes.forEach((node, i) => {
        // Step 2: 再抽選判定
        const prevNodeS2 = (i >= 2) ? Nodes[i - 3] : null;
        const prevNameS2 = prevNodeS2 ? (prevNodeS2.reRollFlag ? prevNodeS2.reRollItemName : prevNodeS2.itemName) : getItemNameSafe(initialLastRollId);
        
        node.isMatchS2 = (node.itemName === prevNameS2);
        node.reRollFlag = (node.rarityId === 1 && node.poolSize > 1 && node.isMatchS2);
        
        if (node.reRollFlag) {
            const rrPool = (gacha.rarityItems[1] || []).filter(id => id !== node.itemId);
            node.reRollSlot = node.seed3 % rrPool.length;
            node.reRollItemId = rrPool[node.reRollSlot];
            node.reRollItemName = getItemNameSafe(node.reRollItemId);
            node.reRollNextAddress = getAddress(i + 3);
        } else {
            node.reRollItemId = -1; node.reRollItemName = '---'; node.reRollNextAddress = '-';
        }

        // Step 3: 再々抽選判定
        const prevNodeS3 = (i >= 3) ? Nodes[i - 4] : null;
        const prevRerollName = (prevNodeS3 && (prevNodeS3.reRollFlag || prevNodeS3.reRerollFlag)) ? prevNodeS3.reRollItemName : '---';
        node.isMatchS3 = (prevRerollName !== '---' && node.itemName === prevRerollName);
        node.reRerollFlag = (node.rarityId === 1 && node.isMatchS3);
    });

    // --- 詳細テキスト生成 (単発・10連ルート) ---
    const singleRouteText = [];
    let sIdx = 1, sRoll = 1, sNgTracker = initialNg, sLastInfo = { addr: 'LastRoll', name: getItemNameSafe(initialLastRollId) };
    while (sIdx <= maxNodeIndex && sRoll <= tableRows) {
        const node = Nodes[sIdx - 1];
        if (!node) break;
        const isGuar = !isNaN(initialNg) && sNgTracker > 0 && (gacha.uberGuaranteedFlag || gacha.legendGuaranteedFlag) && (sRoll >= initialNg) && ((sRoll - initialNg) % 10 === 0);
        let block = `<strong>Roll ${sRoll}${isGuar ? '[Guar]' : ''}</strong><br>実行前SEED：Seed[${sIdx - 1}] ${SEED_LIST[sIdx - 1]}<br>`;
        if (isGuar) {
            block += `レアリティ計算：Seed[${sIdx}] ${node.seed1} % ${node.gDivisor} = ${node.gRoll} → ${node.rarityGName}(${node.rarityGId})<br>`;
            const b = sNgTracker; sNgTracker = gCycle;
            block += `スロット計算：Seed[${sIdx + 1}] ${node.seed2} % ${node.poolGSize} = ${node.slotG} ${node.itemGName}(${node.itemGId}) nextGuar ${b}→${sNgTracker} 最終Seed ${node.seed2}<br>`;
            sLastInfo = { addr: node.address + 'G', name: node.itemGName }; sIdx += 2;
        } else {
            const thres = thresholds[node.rarityId];
            block += `レアリティ計算：Seed[${sIdx}] ${node.seed1} % 10000 = ${node.roll1} ＜ ${thres} → ${rarityNames[node.rarityId]}(${node.rarityId})<br>`;
            const b = sNgTracker;
            sNgTracker = (sNgTracker <= 1) ? gCycle : sNgTracker - 1;
            block += `スロット計算：Seed[${sIdx + 1}] ${node.seed2} % ${node.poolSize} = ${node.slot} ${node.itemName}(${node.itemId}) nextGuar ${b}→${sNgTracker} 最終Seed ${node.seed2}<br>`;
            block += `再抽選判定：レアリティ判定 ${rarityNames[node.rarityId]}(${node.rarityId})→${node.rarityId === 1 ? '該当' : '不該当'} 現アイテム ${node.address})${node.itemName} 前アイテム ${sLastInfo.addr})${sLastInfo.name} →${node.isMatchS2 ? '一致' : '不一致'} 再抽選判定 ${node.reRollFlag ? '実行' : 'なし'}<br>`;
            const pNode = (sIdx >= 3) ? Nodes[sIdx - 4] : null;
            const pRRName = (pNode && (pNode.reRollFlag || pNode.reRerollFlag)) ? pNode.reRollItemName : '---';
            block += `再々抽選判定：レアリティ判定 ${rarityNames[node.rarityId]}(${node.rarityId})→${node.rarityId === 1 ? '該当' : '不該当'} 現アイテム ${node.address})${node.itemName} 前アイテム ${pNode ? pNode.address : '---'})${pRRName} →${node.isMatchS3 ? '一致' : '不一致'} 再抽選判定 ${node.reRerollFlag ? '実行' : 'なし'}<br>`;
            if (node.reRollFlag || node.reRerollFlag) {
                block += `再抽選スロット計算：Seed[${sIdx + 2}] ${node.seed3} % ${node.poolSize - 1} = ${node.reRollSlot} ${node.reRollItemName}(${node.reRollItemId}) nextGuar ${b}→${sNgTracker} 最終Seed ${node.seed3}<br>`;
                sLastInfo = { addr: node.address, name: node.reRollItemName }; sIdx += 3;
            } else {
                sLastInfo = { addr: node.address, name: node.itemName };
                sIdx += 2;
            }
        }
        singleRouteText.push(block);
        sRoll++;
    }

    const multiRouteText = [];
    let tIdx = 1, tRoll = 1, cycleCount = 1, tNgTracker = initialNg, tLastInfo = { addr: 'LastRoll', name: getItemNameSafe(initialLastRollId) };
    while (tIdx <= maxNodeIndex && tRoll <= tableRows) {
        const nodeInit = Nodes[tIdx - 1];
        if (!nodeInit) break;
        let cycleBlock = `<strong>【サイクル ${cycleCount}】</strong><br>実行前Seed：Seed[${tIdx - 1}] ${SEED_LIST[tIdx - 1]}<br>`;
        if (nodeInit.gDivisor > 0) cycleBlock += `確定枠のレアリティ判定：Seed[${tIdx}] ${nodeInit.seed1} % ${nodeInit.gDivisor} = ${nodeInit.gRoll} → ${nodeInit.rarityGName}(${nodeInit.rarityGId}) 最終Seed ${nodeInit.seed1}<br>`;
        cycleBlock += `==================================================<br>`;
        tIdx++;
        for (let j = 0; j < 10; j++) {
            if (tRoll > tableRows || tIdx > maxNodeIndex) break;
            const node = Nodes[tIdx - 1];
            const isGuar = !isNaN(initialNg) && tNgTracker > 0 && (tRoll >= initialNg) && ((tRoll - initialNg) % 10 === 0);
            let rollTxt = `<strong>Roll ${tRoll}${isGuar ? '[Guar]' : ''}</strong><br>実行前Seed：Seed[${tIdx - 1}] ${SEED_LIST[tIdx - 1]}<br>`;
            if (isGuar) {
                // 確定枠アイテム算出: レアリティはサイクル開始時(nodeInit)、スロットはこのロール(node)のシード
                const poolG = gacha.rarityItems[nodeInit.rarityGId] || [];
                const slotG = node.seed1 % Math.max(1, poolG.length);
                const itemIdG = poolG[slotG];
                const itemNameG = getItemNameSafe(itemIdG);

                rollTxt += `レアリティ計算：サイクルの初期シードで算出済み→${nodeInit.rarityGName}(${nodeInit.rarityGId})<br>`;
                const b = tNgTracker; tNgTracker = gCycle;
                rollTxt += `スロット計算：Seed[${tIdx}] ${node.seed1} % ${poolG.length} = ${slotG} ${itemNameG}(${itemIdG}) nextGuar ${b}→${tNgTracker} 最終Seed ${node.seed1}<br>`;
                tLastInfo = { addr: node.address + 'G', name: itemNameG }; tIdx += 1;
            } else {
                const thres = thresholds[node.rarityId];
                rollTxt += `レアリティ計算：Seed[${tIdx}] ${node.seed1} % 10000 = ${node.roll1} ＜ ${thres} → ${rarityNames[node.rarityId]}(${node.rarityId})<br>`;
                const b = tNgTracker;
                tNgTracker = (tNgTracker <= 1) ? gCycle : tNgTracker - 1;
                rollTxt += `スロット計算：Seed[${tIdx + 1}] ${node.seed2} % ${node.poolSize} = ${node.slot} ${node.itemName}(${node.itemId}) nextGuar ${b}→${tNgTracker} 最終Seed ${node.seed2}<br>`;
                rollTxt += `再抽選判定：レアリティ判定 ${rarityNames[node.rarityId]}(${node.rarityId})→${node.rarityId === 1 ? '該当' : '不該当'} 現アイテム ${node.address})${node.itemName} 前アイテム ${tLastInfo.addr})${tLastInfo.name} →${node.isMatchS2 ? '一致' : '不一致'} 再抽選判定 ${node.reRollFlag ? '実行' : 'なし'}<br>`;
                const pNode = (tIdx >= 3) ? Nodes[tIdx - 4] : null;
                const pRRName = (pNode && (pNode.reRollFlag || pNode.reRerollFlag)) ? pNode.reRollItemName : '---';
                rollTxt += `再々抽選判定：レアリティ判定 ${rarityNames[node.rarityId]}(${node.rarityId})→${node.rarityId === 1 ? '該当' : '不該当'} 現アイテム ${node.address})${node.itemName} 前アイテム ${pNode ? pNode.address : '---'})${pRRName} →${node.isMatchS3 ? '一致' : '不一致'} 再抽選判定 ${node.reRerollFlag ? '実行' : 'なし'}<br>`;
                if (node.reRollFlag || node.reRerollFlag) {
                    rollTxt += `再抽選スロット計算：Seed[${tIdx + 2}] ${node.seed3} % ${node.poolSize - 1} = ${node.reRollSlot} ${node.reRollItemName}(${node.reRollItemId}) nextGuar ${b}→${tNgTracker} 最終Seed ${node.seed3}<br>`;
                    tLastInfo = { addr: node.address, name: node.reRollItemName }; tIdx += 3;
                } else {
                    tLastInfo = { addr: node.address, name: node.itemName };
                    tIdx += 2;
                }
            }
            cycleBlock += rollTxt + `--------------------------------------------------<br>`;
            tRoll++;
        }
        multiRouteText.push(cycleBlock); cycleCount++;
    }

    const highlightInfo = generateHighlightMap(Nodes, tableRows, initialNg, initialLastRollId, gCycle, gacha);
    return { Nodes, singleRouteText, multiRouteText, highlightInfo, maxNodeIndex, SEED_LIST };
}

/**
 * ビームサーチ（動的計画法）による最適ルート探索
 */
function runGachaBeamSearch(Nodes, initialLastRollId, totalTickets, gacha, thresholds, initialNg, targetLayers = []) {
    const gCycle = gacha.guaranteedCycle || 30;
    const uFlag = gacha.uberGuaranteedFlag;
    const lFlag = gacha.legendGuaranteedFlag;

    const simulateSingleRoll = (startIdx, lastId, rollNum, currentNg, nodeInit = null) => {
        const node = Nodes[startIdx - 1];
        if (!node) return null;
        const isGuar = !isNaN(initialNg) && currentNg > 0 && (uFlag || lFlag) && (rollNum >= initialNg) && ((rollNum - initialNg) % 10 === 0);
        
        if (isGuar && nodeInit) {
            // 確定枠の計算: レアリティはサイクル開始時、スロットは現在のノード
            const poolG = gacha.rarityItems[nodeInit.rarityGId] || [];
            const slotG = node.seed1 % Math.max(1, poolG.length);
            const itemIdG = poolG[slotG];
            return { itemId: itemIdG, itemName: getItemNameSafe(itemIdG), useSeeds: 1, rarity: itemMaster[itemIdG]?.rarity || 0, nextNg: gCycle };
        } else if (isGuar) {
            // 単発ルートでの確定（通常ありえないが安全のため）
            return { itemId: node.itemGId, itemName: node.itemGName, useSeeds: 2, rarity: itemMaster[node.itemGId]?.rarity || 0, nextNg: gCycle };
        } else {
            const isMatch = (node.itemId !== -1 && node.itemId === lastId);
            const isRR = (node.rarityId === 1 && node.poolSize > 1 && isMatch) || node.reRerollFlag;
            
            let finalId = isRR ? node.reRollItemId : node.itemId;
            let finalName = isRR ? node.reRollItemName : node.itemName;
            const nextNg = (currentNg <= 1) ? gCycle : currentNg - 1;
            return { itemId: finalId, itemName: finalName, useSeeds: isRR ? 3 : 2, rarity: itemMaster[finalId]?.rarity || 0, nextNg };
        }
    };

    let dp = new Array(totalTickets + 1).fill(null).map(() => new Map());
    dp[0].set(`1_${initialLastRollId}_${initialNg}`, {
        nodeIdx: 1, lastId: initialLastRollId, currentNg: initialNg,
        layerCounts: new Array(targetLayers.length).fill(0),
        ubers: 0, legends: 0, path: [], rollCount: 1
    });

    const calculateScore = (state) => {
        let score = 0;
        for (let i = 0; i < state.layerCounts.length; i++) {
            score += state.layerCounts[i] * Math.pow(1000, targetLayers.length - i + 1);
        }
        return score + (state.ubers * 10) + state.legends;
    };

    for (let t = 0; t < totalTickets; t++) {
        const states = Array.from(dp[t].values()).sort((a, b) => calculateScore(b) - calculateScore(a)).slice(0, 200);
        for (let state of states) {
            // 1. 単発ルート
            const resS = simulateSingleRoll(state.nodeIdx, state.lastId, state.rollCount, state.currentNg);
            if (resS) {
                const newLayerCounts = [...state.layerCounts];
                targetLayers.forEach((ids, idx) => { if (ids.includes(resS.itemId)) newLayerCounts[idx]++; });
                const nextState = {
                    nodeIdx: state.nodeIdx + resS.useSeeds, lastId: resS.itemId, currentNg: resS.nextNg,
                    layerCounts: newLayerCounts, ubers: state.ubers + (resS.rarity === 3 ? 1 : 0),
                    legends: state.legends + (resS.rarity === 4 ? 1 : 0),
                    path: state.path.concat({ type: 'single', item: resS.itemName, addr: Nodes[state.nodeIdx - 1].address }),
                    rollCount: state.rollCount + 1
                };
                const key = `${nextState.nodeIdx}_${nextState.lastId}_${nextState.currentNg}`;
                if (!dp[t + 1].has(key) || calculateScore(dp[t + 1].get(key)) < calculateScore(nextState)) dp[t + 1].set(key, nextState);
            }

            // 2. 10連ルート
            if (t + 10 <= totalTickets) {
                const nodeInit = Nodes[state.nodeIdx - 1];
                if (nodeInit) {
                    let curIdx = state.nodeIdx + 1, curLastId = state.lastId, curNg = state.currentNg, curRoll = state.rollCount;
                    let items = [], ubers = 0, legends = 0, addLayer = new Array(targetLayers.length).fill(0), validCycle = true;
                    for (let j = 0; j < 10; j++) {
                        if (!Nodes[curIdx - 1]) { validCycle = false; break; }
                        const res = simulateSingleRoll(curIdx, curLastId, curRoll, curNg, nodeInit);
                        if (!res) { validCycle = false; break; }
                        items.push(res.itemName);
                        targetLayers.forEach((ids, idx) => { if (ids.includes(res.itemId)) addLayer[idx]++; });
                        if (res.rarity === 3) ubers++; if (res.rarity === 4) legends++;
                        curIdx += res.useSeeds; curLastId = res.itemId; curNg = res.nextNg; curRoll++;
                    }
                    if (validCycle) {
                        const nextStateTen = {
                            nodeIdx: curIdx, lastId: curLastId, currentNg: curNg,
                            layerCounts: state.layerCounts.map((c, idx) => c + addLayer[idx]),
                            ubers: state.ubers + ubers, legends: state.legends + legends,
                            path: state.path.concat({ type: 'ten', items: items, addr: nodeInit.address }),
                            rollCount: curRoll
                        };
                        const keyTen = `${nextStateTen.nodeIdx}_${nextStateTen.lastId}_${nextStateTen.currentNg}`;
                        if (!dp[t + 10].has(keyTen) || calculateScore(dp[t + 10].get(keyTen)) < calculateScore(nextStateTen)) dp[t + 10].set(keyTen, nextStateTen);
                    }
                }
            }
        }
    }
    let best = null;
    for (let i = totalTickets; i >= 0; i--) {
        for (let state of dp[i].values()) {
            if (!best || calculateScore(state) > calculateScore(best)) best = state;
        }
        if (best) break;
    }
    return best;
}

function generateHighlightMap(Nodes, tableRows, initialNg, initialLastRollId, gCycle, gacha) {
    const map = new Map();
    const uFlag = gacha.uberGuaranteedFlag, lFlag = gacha.legendGuaranteedFlag;
    let sIdx = 1, sLastId = initialLastRollId;
    for (let roll = 1; roll <= tableRows; roll++) {
        if (sIdx > Nodes.length) break;
        const node = Nodes[sIdx - 1];
        const isG = !isNaN(initialNg) && (uFlag || lFlag) && (roll >= initialNg) && ((roll - initialNg) % 10 === 0);
        if (isG) {
            map.set(node.address + 'G', { single: true, singleRoll: roll });
            sLastId = node.itemGId; sIdx += 2;
        } else {
            const rr = (node.rarityId === 1 && node.poolSize > 1 && node.itemId === sLastId) || node.reRerollFlag;
            map.set(node.address, { single: true, singleRoll: roll, s_reRoll: rr });
            sLastId = rr ? node.reRollItemId : node.itemId;
            sIdx += rr ? 3 : 2;
        }
    }
    let tIdx = 1, tLastId = initialLastRollId;
    for (let roll = 1; roll <= tableRows; roll++) {
        if ((roll - 1) % 10 === 0) tIdx++;
        if (tIdx > Nodes.length) break;
        const node = Nodes[tIdx - 1];
        const isG = !isNaN(initialNg) && (uFlag || lFlag) && (roll >= initialNg) && ((roll - initialNg) % 10 === 0);
        if (isG) {
            const gNode = Nodes[tIdx - 2];
            if (gNode) {
                const info = map.get(gNode.address + 'G') || {};
                info.ten = true; info.tenRoll = roll;
                map.set(gNode.address + 'G', info);
            }
            tIdx += 1;
        } else {
            const rr = (node.rarityId === 1 && node.poolSize > 1 && node.itemId === tLastId) || node.reRerollFlag;
            const info = map.get(node.address) || {};
            info.ten = true; info.tenRoll = roll; info.t_reRoll = rr;
            map.set(node.address, info);
            tLastId = rr ? node.reRollItemId : node.itemId;
            tIdx += rr ? 3 : 2;
        }
    }
    return map;
}

====================
FILE: logic-uncompleted-sim.js
====================
/**
 * 担当: 「未コンプ」ビュー用の10連ガチャシミュレーションおよび期待値計算ロジック
 * 依存関係: logic-common.js
 */

/**
 * 10連詳細（現在地からの1回分）を計算するロジック
 */
function calculateTenPullDetailedLogic(fullSeedArray, gacha, thresholds, ngVal, initialLastRollId, getAddressFunc) {
    const isGuaranteedActive = !isNaN(ngVal);
    const guaranteedCycle = gacha.guaranteedCycle || 30;
    
    let guaranteedStatus = 'none';
    let currentNgVal = ngVal;
    
    // Featured 判定で実際に消費したシードの数をトラック
    let featuredSeedPtr = 0; 
    
    if (isGuaranteedActive && currentNgVal > 0) {
        if (currentNgVal <= 10) {
            guaranteedStatus = `next guaranteed(${currentNgVal}) <= 10 → 9ロール抽選`;
        } else {
            guaranteedStatus = `next guaranteed(${currentNgVal}) >= 11 → 10ロール抽選`;
        }
    } else {
        guaranteedStatus = 'Not Guaranteed/NG Invalid → 10ロール抽選';
    }

    const featuredLog = [];
    const processLog = [];
    const results = [];
    let featuredCountInCycle = 0; 

    // 目玉判定用シード (S1～S10) の計算
    const featuredResults = [];
    for (let i = 1; i <= 10; i++) { 
        const isGuaranteedRoll = isGuaranteedActive && i === currentNgVal && currentNgVal <= 10;

        if (isGuaranteedRoll) {
             featuredLog.push(`S${i} (Skipped): Guaranteed Roll (${currentNgVal})`);
             continue;
        }
        
        const sVal = fullSeedArray[featuredSeedPtr];
        if (sVal === undefined) {
             console.error(`Seed is undefined at index ${featuredSeedPtr}.`);
             break; 
        }

        const mod = sVal % 10000;
        const isFeatured = mod < gacha.featuredItemRate;
        featuredResults.push({ index: i, isFeatured: isFeatured, seedIndex: featuredSeedPtr + 1 });
        featuredLog.push(`S${featuredSeedPtr + 1} (${sVal}) % 10000 = ${mod} < ${gacha.featuredItemRate} → ${isFeatured} (Roll ${i}用)`);
        featuredSeedPtr++;
    }

    let currentSeedIndex = featuredSeedPtr; 
    let lastItemId = initialLastRollId || -1;
    const rollCount = 10;
    let featuredIdxPtr = 0; 

    for (let r = 1; r <= rollCount; r++) {
        let label = `Roll${r}`;
        
        // 確定ロール判定
        if (isGuaranteedActive && r === currentNgVal) {
            label += `(G${r})`;
            if (currentNgVal <= 10) { 
                processLog.push(`${label} (Skipped): Guaranteed Roll`);
            } else {
                processLog.push(`${label}: Featured Item by guaranteed`); 
            }
            results.push({ label: label, name: '目玉(確定)', isGuaranteed: true, isFeatured: false, isReroll: false, preRerollName: null });
            featuredCountInCycle++; 
            continue;
        }

        // 非確定ロール判定
        const fRes = featuredResults[featuredIdxPtr];
        if (!fRes) {
             processLog.push(`${label}: **ERROR**: Featured check result missing.`);
             break;
        }
        featuredIdxPtr++; 
        
        if (fRes.isFeatured) {
            results.push({ label: label, name: '目玉', isGuaranteed: false, isFeatured: true, isReroll: false, preRerollName: null });
             processLog.push(`${label}: Featured (by S${fRes.seedIndex})`);
             lastItemId = -2;
             featuredCountInCycle++; 
        } else {
            // Continuation Seeds Consumption
            const sRarity = fullSeedArray[currentSeedIndex];
            const sSlot = fullSeedArray[currentSeedIndex+1];
            
            if (sRarity === undefined || sSlot === undefined) {
                 processLog.push(`${label}: **ERROR**: Seed array ended unexpectedly.`);
                 break; 
            }

            const rarityInfo = getRarityFromRoll(sRarity % 10000, thresholds);
            const rId = rarityInfo.id;
            const rName = rarityInfo.name;
            let logStr = `${label}: S${currentSeedIndex+1}→${rName}`;
            
            const pool = gacha.rarityItems[rId] || [];
            const poolSize = pool.length > 0 ? pool.length : 1;
            const slot = sSlot % poolSize;
            const itemId = (pool[slot] !== undefined) ? pool[slot] : -1;
            const itemName = getItemNameSafe(itemId);
            
            logStr += `, S${currentSeedIndex+2}→${itemName}`;
            
            let finalId = itemId;
            let finalName = itemName;
            let consumed = 2;
            let isReroll = false;
            let preRerollName = null;

            // Dupe Check
            if (rId === 1 && itemId !== -1 && itemId === lastItemId) {
                const sReRoll = fullSeedArray[currentSeedIndex+2];
                if (sReRoll === undefined) break;
                const rePool = pool.filter(id => id !== itemId);
                const reDiv = rePool.length;
                logStr += ` [Dupe]`;
                if (reDiv > 0) {
                    isReroll = true;
                    preRerollName = itemName;
                    const reSlot = sReRoll % reDiv;
                    finalId = rePool[reSlot];
                    finalName = getItemNameSafe(finalId);
                    logStr += `, S${currentSeedIndex+3}→${finalName}`;
                }
                consumed = 3;
            }

            processLog.push(logStr);
            results.push({ label: label, name: finalName, isGuaranteed: false, isFeatured: false, isReroll: isReroll, preRerollName: preRerollName });
            currentSeedIndex += consumed;
            lastItemId = finalId;
        }
    }

    const nextSeedVal = fullSeedArray[currentSeedIndex]; 
    const nextIndex = currentSeedIndex + 1;
    const nextAddress = (fullSeedArray.length > currentSeedIndex) ? getAddressFunc(nextIndex) : 'End';
    const nextNgVal = isGuaranteedActive ? currentNgVal : NaN;
    const seedsConsumedCorrectly = currentSeedIndex; 

    return {
        guaranteedStatus, featuredLog, processLog, results, featuredCountInCycle,
        transition: { consumedCount: seedsConsumedCorrectly, nextIndex: nextIndex, nextAddress: nextAddress, nextSeed: nextSeedVal, lastItemId: lastItemId, nextNgVal: nextNgVal }
    };
}

/**
 * nサイクル分の10連計算を実行
 */
function calculateTenPullsOverCycles(initialFullSeedArray, gacha, thresholds, initialNgVal, initialLastRollId, nCycles = 10) {
    const getAddress = (n) => getAddressStringGeneric(n, 3);
    const guaranteedCycle = gacha.guaranteedCycle || 30; // 確定サイクルの値を取得
    let currentSeedArray = [...initialFullSeedArray];
    let currentLastRollId = initialLastRollId;
    let currentNgVal = initialNgVal;
    
    const cycleResults = [];
    const maxSeedsInTenPull = 40; 

    for (let c = 1; c <= nCycles; c++) {
        if (currentSeedArray.length < 1) break;
        const tenPullSeedSlice = currentSeedArray.slice(0, maxSeedsInTenPull); 
        const cycleResult = calculateTenPullDetailedLogic(tenPullSeedSlice, gacha, thresholds, currentNgVal, currentLastRollId, getAddress);
        
        cycleResults.push({ cycle: c, ...cycleResult, startNgVal: currentNgVal, startLastRollId: currentLastRollId });

        const consumedCount = cycleResult.transition.consumedCount;
        currentSeedArray = currentSeedArray.slice(consumedCount);
        currentLastRollId = cycleResult.transition.lastItemId;
        let nextNgValFromLogic = cycleResult.transition.nextNgVal; // logicから返されたNG値

        // 10連が終わった時点で10ロール分マイナスする
        if (!isNaN(nextNgValFromLogic)) {
                currentNgVal = nextNgValFromLogic - 10;
            // 確定サイクルをまたいだ場合の処理
            if (currentNgVal <= 0) {
                 currentNgVal = guaranteedCycle + currentNgVal;
            }
        } else {
            // 確定システムが無効な場合はそのまま NaN を維持
            currentNgVal = nextNgValFromLogic;
        }
    }
    return cycleResults;
}

/**
 * 単発Nロール後の10連目玉獲得数期待値の計算ロジック
 */
function calculateExpectedFeaturedCounts(initialFullSeedArray, gacha, thresholds, nRollsArray, initialNgVal, initialLastRollId) {
    const results = {};
    const guaranteedCycle = gacha.guaranteedCycle || 30;
    const tenPullSimulationLength = 40; 
    
    // Nロール後の状態をシミュレーション
    const simulateSingleRollsAndGetState = (n, seedArray, initialNg, initialLastRoll) => {
        let currentSeedIndex = 0;
        let currentNg = !isNaN(initialNg) && initialNg > 0 ? initialNg : guaranteedCycle;
        let lastItemId = initialLastRoll || -1;
        
        for (let r = 1; r <= n; r++) {
            if (currentSeedIndex >= seedArray.length) break;
            const isFeatured = (seedArray[currentSeedIndex] % 10000) < gacha.featuredItemRate;
            const isGuaranteedRoll = (currentNg === 1);
            let usedSeeds = 0;

            if (isGuaranteedRoll) {
                usedSeeds = 1; currentNg = guaranteedCycle; lastItemId = -2;
            } else if (isFeatured) {
                usedSeeds = 1; currentNg = currentNg - 1;
                if (currentNg <= 0) currentNg = guaranteedCycle;
                lastItemId = -2;
            } else {
                const sRarity = seedArray[currentSeedIndex+1];
                const sSlot = seedArray[currentSeedIndex+2];
                if (sRarity === undefined || sSlot === undefined) { usedSeeds = 3; break; }
                const rarityInfo = getRarityFromRoll(sRarity % 10000, thresholds);
                const rId = rarityInfo.id;
                const pool = gacha.rarityItems[rId] || [];
                const itemId = (pool[sSlot % (pool.length||1)] !== undefined) ? pool[sSlot % (pool.length||1)] : -1;
                usedSeeds = 3;
                let finalId = itemId;

                if (rId === 1 && itemId !== -1 && itemId === lastItemId) {
                    const sReRoll = seedArray[currentSeedIndex+3];
                    if (sReRoll !== undefined) {
                        const rePool = pool.filter(id => id !== itemId);
                        if (rePool.length > 0) {
                            finalId = rePool[sReRoll % rePool.length];
                            usedSeeds = 4;
                        }
                    }
                }
                currentNg = currentNg - 1;
                if (currentNg <= 0) currentNg = guaranteedCycle;
                lastItemId = finalId;
            }
            currentSeedIndex += usedSeeds;
        }
        return { nextSeedIndex: currentSeedIndex, nextNg: currentNg, nextLastRollId: lastItemId };
    };

    for (const n of nRollsArray) {
        if (n < 0) continue;
        const { nextSeedIndex, nextNg, nextLastRollId } = simulateSingleRollsAndGetState(n, initialFullSeedArray, initialNgVal, initialLastRollId);
        const tenPullSeedArray = initialFullSeedArray.slice(nextSeedIndex, nextSeedIndex + tenPullSimulationLength);

        if (tenPullSeedArray.length < 9) {
             results[n] = 0; continue;
        }
        const tenPullResult = calculateTenPullDetailedLogic(tenPullSeedArray, gacha, thresholds, nextNg, nextLastRollId, (addr) => `S${nextSeedIndex + addr}`);
        results[n] = tenPullResult.featuredCountInCycle;
    }
    return results;
}

====================
FILE: logic-uncompleted.js
====================
/**
 * 担当: 「未コンプ」ビューにおけるメインテーブル用のノード計算
 * 依存関係: logic-common.js, logic-uncompleted-sim.js
 */

/**
 * 未コンプ（分割）ビュー用のデータを計算する関数
 */
function calculateUncompletedData(initialSeed, gacha, tableRows, thresholds, initialLastRollId, params) {
    // 1. シード生成
    const maxSeedsNeeded = tableRows * 10 + 1000; 
    const SEED = generateSeedList(initialSeed, maxSeedsNeeded);
    const getAddress = (n) => getAddressStringGeneric(n, 3);
    
    // 2. 全ノード計算 (メインテーブル用)
    const Nodes = [];
    const maxNodes = tableRows * 3 + 20; 
    const highlightInfo = new Map(); 

    const ngVal = parseInt(params.get('ng'), 10);
    const initialFs = parseInt(params.get('fs'), 10) || 0; 
    const guaranteedCycle = gacha.guaranteedCycle || 30;
    
    for (let i = 1; i <= maxNodes; i++) {
        const seedStartIdx = i; 
        const s1 = SEED[seedStartIdx];     
        const s2 = SEED[seedStartIdx + 1]; 
        const s3 = SEED[seedStartIdx + 2]; 
        const s4 = SEED[seedStartIdx + 3]; 
        let prevSeedVal = SEED[seedStartIdx - 1];

        const node = {
            index: i, address: getAddress(i),
            seed1: s1, seed2: s2, seed3: s3, seed4: s4,
            prevSeed1: prevSeedVal,
            isFeatured: (s1 % 10000) < gacha.featuredItemRate,
            singleRoll: null, singleUseSeeds: null, singleNextAddr: null,
            guaranteedNextNgVal: ngVal,
            isFeaturedUsedFs: false,
        };

        node.featuredNextAddress = getAddress(i + 1); 
        node.normalNextAddress = getAddress(i + 3);   
        node.reRollNextAddress = getAddress(i + 4);   

        node.rarity = getRarityFromRoll(s2 % 10000, thresholds);
        node.rarityId = node.rarity.id;
        node.rarityName = node.rarity.name; 
        
        // レアリティ範囲表示用
        let lowerBound = 0, upperBound = 10000;
        const rarityIds = Object.keys(thresholds).map(Number).sort((a, b) => a - b);
        for(const id of rarityIds) {
            if (id < node.rarityId) lowerBound = thresholds[id];
            if (id === node.rarityId) { upperBound = thresholds[id]; break; }
        }
        node.rarityRateRangeDisplay = `${lowerBound}<=${s2 % 10000}<${upperBound}`;
        
        const pool = gacha.rarityItems[node.rarityId] || [];
        node.poolSize = pool.length;
        if (pool.length > 0) {
            node.slot = s3 % pool.length;
            node.itemId = pool[node.slot];
            node.itemName = getItemNameSafe(node.itemId);
        } else {
            node.slot = 0; node.itemId = -1; node.itemName = '---';
        }
        
        const isRare = (node.rarityId === 1);
        if (isRare && pool.length > 1) {
            const reRollPool = pool.filter(id => id !== node.itemId);
            if (reRollPool.length > 0) {
                node.reRollSlot = s4 % reRollPool.length;
                node.reRollItemId = reRollPool[node.reRollSlot];
                node.reRollItemName = getItemNameSafe(node.reRollItemId);
            } else { node.reRollItemId = -1; node.reRollItemName = '---'; }
        } else { node.reRollItemId = -1; node.reRollItemName = '---'; }

        // Dupe判定用
        let compareId3Node = -1, compareId4Node = -1;
        let compareName3Node = '---', compareName4Node = '---';
        
        if (i <= 1) { 
            compareId3Node = initialLastRollId || -1;
            compareName3Node = getItemNameSafe(initialLastRollId || -1);
        } else {
            const pNode3 = (i > 3) ? Nodes[i-4] : null; 
            if (pNode3 && pNode3.singleUseSeeds === 3) {
                 compareId3Node = pNode3.itemId; compareName3Node = pNode3.itemName;
            } else if (i <= 3) {
                compareId3Node = initialLastRollId || -1; compareName3Node = getItemNameSafe(initialLastRollId || -1);
            }
            const pNode4 = (i > 4) ? Nodes[i-5] : null;
            if (pNode4 && pNode4.singleUseSeeds === 4 && pNode4.reRollItemId !== -1) {
                 compareId4Node = pNode4.reRollItemId; compareName4Node = pNode4.reRollItemName;
            }
        }
        
        const currentId = node.itemId;
        const isDupe3 = (currentId !== -1 && currentId === compareId3Node);
        const isDupe4 = (compareId4Node !== -1 && currentId === compareId4Node); 
        node.isDupe = (node.rarityId === 1 && (isDupe3 || isDupe4)); 

        if (node.rarityId === 1) {
            const id3 = compareId3Node !== -1 ? compareName3Node : '-';
            const id4 = compareId4Node !== -1 ? compareName4Node : '';
            node.dupeCompareTargets = `${id3}${id4 ? '/' + id4 : ''}`; 
        } else { node.dupeCompareTargets = node.rarityName; }

        Nodes.push(node);
    }
    
    // 3. 単発ルート計算
    let sIdx = 1; 
    let sLastActualItemId = initialLastRollId || -1; 
    let sCurrentFs = initialFs;
    const singleRoutePath = new Map();
    const hasGuaranteed = !isNaN(ngVal);
    let currentNg = hasGuaranteed ? ngVal : -1;

    for (let roll = 1; roll <= tableRows; roll++) {
        if (sIdx > maxNodes) break;
        const node = Nodes[sIdx - 1];
        if (!node) break;
        
        const isGuaranteedRoll = hasGuaranteed && (currentNg === 1); 
        node.singleCompareItemName = getItemNameSafe(sLastActualItemId);
        node.singleCompareItemId = sLastActualItemId; 

            let usedSeeds = 0;
            let finalId = -1;
            
            if (node.isFeatured) {
                usedSeeds = 1; finalId = -2; 
                node.singleRoll = roll;
                node.singleUseSeeds = usedSeeds;
                node.singleNextAddr = node.featuredNextAddress; 
                if (sCurrentFs > 0) { sCurrentFs -= 1; node.isFeaturedUsedFs = true; }
            } else {
                const poolSize = gacha.rarityItems[1] ? gacha.rarityItems[1].length : 0;
                const currentId = Number(node.itemId);
                const lastId = Number(sLastActualItemId);
                const isMatch = (currentId !== -1 && lastId !== -1 && currentId === lastId);
                const isReroll = (node.rarityId === 1) && isMatch && poolSize > 1; 
                
                finalId = isReroll ? node.reRollItemId : node.itemId;
                usedSeeds = isReroll ? 4 : 3;
                
                node.singleIsReroll = isReroll; 
                node.singleRoll = roll;
                node.singleUseSeeds = usedSeeds;
                node.singleNextAddr = isReroll ? node.reRollNextAddress : node.normalNextAddress; 
            }
            sLastActualItemId = finalId; 
            if (hasGuaranteed) {
                currentNg = currentNg - 1;
                if (currentNg <= 0) currentNg = guaranteedCycle;
            }
        if (isGuaranteedRoll) {
            node.singleRoll = `${roll}g`;
            //node.singleUseSeeds = 0; 
            //node.singleNextAddr = node.featuredNextAddress;
            //node.singleIsReroll = false; 
            node.isGuaranteedRoll = true; // フラグ
            currentNg = guaranteedCycle; 
            sLastActualItemId = -2; 
        }
        singleRoutePath.set(sIdx, roll);
        sIdx = sIdx + (node.singleUseSeeds === 0 ? 0 : node.singleUseSeeds || 3); 
    }

    // 4. Highlight Info 生成 (単発ルート)
    sIdx = 1; 
    for (let roll = 1; roll <= tableRows; roll++) {
        if (sIdx > maxNodes) break;
        const node = Nodes[sIdx - 1];
        if (!node || node.singleRoll === null) break;
        const addressKey = node.address;
        
        const info = highlightInfo.get(addressKey) || {};
        info.single = true; info.singleRoll = roll; 

        if (node.singleRoll.toString().endsWith('g')) {
             info.s_guaranteed = true;
        } else if (node.isFeatured) {
             info.s_featured = true; info.s_reRoll = false;
        } else if (node.rarityId !== 1) { 
             info.s_featured = false; info.s_reRoll = false; 
             info.s_normalName = node.rarityName; 
        } else {
             info.s_featured = false;
             info.s_reRoll = node.singleIsReroll; 
             info.s_currentId = node.itemId;
             if (info.s_reRoll) {
                 info.s_normalName = node.itemName; 
                 info.s_reRollName = node.reRollItemName;
             }
        }
        highlightInfo.set(addressKey, info);
        sIdx += node.singleUseSeeds || 3; 
    }
    
    // 5. Simロジック委譲: 10連サイクル計算 & 期待値計算
    const tenPullCyclesData = calculateTenPullsOverCycles(SEED, gacha, thresholds, ngVal, initialLastRollId, 10);
    const nRollsArray = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    const expectedFeaturedCounts = calculateExpectedFeaturedCounts(SEED, gacha, thresholds, nRollsArray, ngVal, initialLastRollId);

    return { Nodes, highlightInfo, maxNodes, singleRoutePath, tenPullCyclesData, expectedFeaturedCounts };
}

====================
FILE: main.js
====================
/**
 * 担当: アプリケーションの起動、URLパラメータ管理、DOMイベントリスナーの制御
 * 依存関係: master.js, logic-*.js, view-*.js (全機能の統括)
 */

/**
 * 【データ相関・アプリケーションフロー図】
 * * [ Entry Point ]
 * index.html (構造定義・外部スクリプト読込)
 * ↓
 * [ Master Data ]
 * master.js (ガチャ設定・アイテムリスト)
 * ↓
 * [ Helpers & Common ]
 * utils.js (URL生成・シード生成・共通パーツ)
 * logic-common.js (レアリティ判定・アドレス計算共通)
 * ↓
 * [ Controller ]
 * main.js (URLパラメータ取得・ビューの切り替え・イベント管理)
 * │
 * ├─→ <コンプ済み (Completed) ビュー表示時>
 * │     │
 * │     ├─ [Logic] logic-completed.js (全ルートのノード計算)
 * │     └─ [View]  view-completed.js (統合テーブル・計算詳細描画)
 * │
 * └─→ <未コンプ (Uncompleted) ビュー表示時>
 * │
 * ├─ [Logic] logic-uncompleted.js (メインノード計算)
 * │     └─ logic-uncompleted-sim.js (10連シミュレーション・期待値計算)
 * │
 * └─ [View]  view-uncompleted.js (描画統括)
 * ├─ view-uncompleted-table.js (メインテーブル・期待値表示)
 * └─ view-uncompleted-details.js (単発計算過程・10連詳細表示)
 * * [ Styling ]
 * style.css (全画面のレイアウト・ハイライト色定義)
 */

// --- グローバル変数 ---
const DEFAULT_PARAMS = {
    gacha: '45',
    seed: '123456789',
    ng: 'none',
    fs: 'none',
    lr: null,
    comp: false,
    tx: false,
    roll: 100,
    displaySeed: '0'
};

// ハイライト状態管理
let currentHighlightMode = 'all'; // 'all', 'single', 'multi'
let activeGachaId;
let forceRerollMode = false;

// グローバルスコープへ公開（viewスクリプトからの参照用）
window.activeGachaId = activeGachaId;
window.forceRerollMode = forceRerollMode;

// --- ディスパッチャー & メイン ---

function runSimulationAndDisplay(options = {}) {
    const { hideSeedInput = false, uiOverrides = {} } = options;
    const params = new URLSearchParams(window.location.search);
    const latestGachaId = Object.keys(gachaMaster).reduce((a, b) => parseInt(a) > parseInt(b) ? a : b);
    
    const p = {};
    ['gacha', 'seed', 'ng', 'fs', 'lr', 'comp', 'tx', 'roll', 'displaySeed'].forEach(k => {
        p[k] = params.get(k);
    });
    if (!p.gacha || !gachaMaster[p.gacha]) p.gacha = latestGachaId;
    if (!p.seed) p.seed = DEFAULT_PARAMS.seed;
    if (!p.roll) p.roll = DEFAULT_PARAMS.roll;
    if (!p.ng) p.ng = DEFAULT_PARAMS.ng;
    if (p.tx === 'true') p.tx = '1'; else if (p.tx === 'false') p.tx = '0';
    if (!p.tx && DEFAULT_PARAMS.tx) p.tx = '1';
    if (p.comp === '1') p.comp = 'true'; else if (p.comp === '0') p.comp = 'false';
    
    if (uiOverrides.seed !== undefined) p.seed = uiOverrides.seed;
    if (uiOverrides.guaranteedRolls !== undefined) p.ng = uiOverrides.guaranteedRolls;
    if (uiOverrides.featuredStock !== undefined) p.fs = uiOverrides.featuredStock;
    if (uiOverrides.isComplete !== undefined) p.comp = uiOverrides.isComplete ? 'true' : 'false';
    
    activeGachaId = p.gacha;
    window.activeGachaId = activeGachaId; // 更新
    
    const gacha = gachaMaster[p.gacha];
    
    document.getElementById('seedInput').value = p.seed;
    const isComplete = (p.comp === 'true');
    document.getElementById('featuredCompleteCheckbox').checked = isComplete;
    
    if (gacha.featuredItemStock === 0) {
        document.getElementById('featuredCompleteCheckbox').checked = true;
        document.getElementById('featuredCompleteCheckbox').parentElement.classList.add('hidden-control');
    } else {
        document.getElementById('featuredCompleteCheckbox').parentElement.classList.remove('hidden-control');
    }
    
    const isComp = document.getElementById('featuredCompleteCheckbox').checked;
    const stockControl = document.getElementById('stockControl');
    const guaranteedControl = document.getElementById('guaranteedControl');
    const legendDisplay = document.getElementById('legendDisplay');

    populateFeaturedStockInput(p.gacha, p.fs);

    const legendCommon = document.getElementById('legendCommon');
    if (isComp) {
        stockControl.classList.add('hidden-control');
        if (gacha.uberGuaranteedFlag || gacha.legendGuaranteedFlag) {
            guaranteedControl.classList.remove('hidden-control');
            legendDisplay.classList.remove('hidden-control');
            populateGuaranteedRolls(10, p.ng);
        } else {
            guaranteedControl.classList.add('hidden-control');
            legendDisplay.classList.add('hidden-control');
        }
        legendCommon.style.display = 'inline-block';
    } else {
        stockControl.classList.remove('hidden-control');
        guaranteedControl.classList.remove('hidden-control');
        legendDisplay.classList.remove('hidden-control');
        populateGuaranteedRolls(gacha.guaranteedCycle || 30, p.ng);
        legendCommon.style.display = 'none'; 
    }

    const lastRollDisplay = document.getElementById('lastRollDisplay');
    if (p.lr && itemMaster[p.lr]) {
        lastRollDisplay.textContent = `LastRoll: ${itemMaster[p.lr].name}`;
    } else {
        lastRollDisplay.textContent = '';
    }

    const newParams = {
        gacha: p.gacha, seed: p.seed, ng: p.ng, fs: p.fs, lr: p.lr,
        comp: isComp ? 'true' : 'false',
        tx: (p.tx === '1' || (!hideSeedInput && document.getElementById('seedRow').classList.contains('hidden-control') === false)) ? '1' : '0',
        roll: p.roll, displaySeed: p.displaySeed
    };
    if (!hideSeedInput && document.getElementById('seedRow').style.display === 'flex') newParams.tx = '1';

    const newQuery = generateUrlQuery(newParams);
    window.history.replaceState({ path: newQuery }, '', `${window.location.pathname}${newQuery}`);

    const seedValue = parseInt(p.seed, 10);
    const lastRollId = p.lr ? parseInt(p.lr, 10) : null;
    const rows = parseInt(p.roll, 10);
    const thresholds = {
        '0': gacha.rarityRates['0'],
        '1': gacha.rarityRates['0'] + gacha.rarityRates['1'],
        '2': gacha.rarityRates['0'] + gacha.rarityRates['1'] + gacha.rarityRates['2'],
        '3': gacha.rarityRates['0'] + gacha.rarityRates['1'] + gacha.rarityRates['2'] + gacha.rarityRates['3'],
        '4': 10000
    };

    if (isComp) {
        createAndDisplayCompletedSeedView(seedValue, gacha, rows, thresholds, lastRollId, p.displaySeed, new URLSearchParams(newQuery), p.ng);
    } else {
        createAndDisplayUncompletedSeedView(seedValue, gacha, rows, thresholds, lastRollId, p.displaySeed, new URLSearchParams(newQuery));
    }
}

function populateGuaranteedRolls(max, currentVal) {
    const input = document.getElementById('guaranteedRollsInput');
    input.innerHTML = '';
    const unsetOption = document.createElement('option');
    unsetOption.value = 'none'; unsetOption.textContent = '未設定'; input.appendChild(unsetOption);
    for (let i = 1; i <= max; i++) {
        const option = document.createElement('option'); option.value = i; option.textContent = i; input.appendChild(option);
    }
    if (currentVal && input.querySelector(`option[value="${currentVal}"]`)) {
        input.value = currentVal;
    } else {
        input.value = 'none';
    }
}
function populateFeaturedStockInput(gachaId, preferredValue) {
    const gacha = gachaMaster[gachaId];
    const input = document.getElementById('featuredStockInput');
    if (!gacha) return;
    input.innerHTML = '';
    const unsetOption = document.createElement('option');
    unsetOption.value = 'none'; unsetOption.textContent = '-'; input.appendChild(unsetOption);
    for (let i = 1; i <= gacha.featuredItemStock; i++) {
        const option = document.createElement('option'); option.value = i; option.textContent = i; input.appendChild(option);
    }
    if (preferredValue && preferredValue !== 'none' && input.querySelector(`option[value="${preferredValue}"]`)) {
        input.value = preferredValue;
    } else {
        input.value = 'none';
    }
}

function toggleSeedInput() {
    const seedRow = document.getElementById('seedRow');
    if (seedRow.classList.contains('hidden-control')) {
        seedRow.classList.remove('hidden-control');
    } else {
        seedRow.classList.add('hidden-control');
    }
}

// イベントリスナー設定
document.addEventListener('DOMContentLoaded', () => {
    setupGachaRarityItems(); // from utils.js

    document.getElementById('executeButton').addEventListener('click', () => runSimulationAndDisplay({ hideSeedInput: true, uiOverrides: { seed: document.getElementById('seedInput').value } }));
    document.getElementById('guaranteedRollsInput').addEventListener('change', (e) => runSimulationAndDisplay({ uiOverrides: { guaranteedRolls: e.target.value } }));
    document.getElementById('featuredStockInput').addEventListener('change', (e) => runSimulationAndDisplay({ uiOverrides: { featuredStock: e.target.value } }));
    document.getElementById('featuredCompleteCheckbox').addEventListener('change', () => runSimulationAndDisplay({ uiOverrides: { isComplete: document.getElementById('featuredCompleteCheckbox').checked } }));
    document.getElementById('copySeedLink').addEventListener('click', (event) => {
        event.preventDefault();
        const seedToCopy = new URLSearchParams(window.location.search).get('seed');
        if (seedToCopy && navigator.clipboard) {
            navigator.clipboard.writeText(seedToCopy).then(() => {
                const originalText = event.target.textContent;
                event.target.textContent = 'Copied!';
                setTimeout(() => { event.target.textContent = originalText; }, 1500);
            });
        }
    });
    document.getElementById('result-table-container').addEventListener('click', (event) => {
        if (event.target.id === 'forceRerollToggle') {
            window.forceRerollMode = !window.forceRerollMode;
            runSimulationAndDisplay();
        }
    });

    document.getElementById('showSeedInputLink').addEventListener('click', (e) => {
        e.preventDefault();
        toggleSeedInput();
    });

    const applyHighlightMode = () => {
         const table = document.querySelector('#result-table-container table');
         if (!table) return;
         table.classList.remove('mode-single', 'mode-multi');
         if (currentHighlightMode === 'single') table.classList.add('mode-single');
         if (currentHighlightMode === 'multi') table.classList.add('mode-multi');
    };

    document.getElementById('legendSingle').addEventListener('click', () => {
        if (document.getElementById('featuredCompleteCheckbox').checked) {
            currentHighlightMode = (currentHighlightMode === 'single') ? 'all' : 'single';
            applyHighlightMode();
        }
    });
    document.getElementById('legendMulti').addEventListener('click', () => {
        if (document.getElementById('featuredCompleteCheckbox').checked) {
            currentHighlightMode = (currentHighlightMode === 'multi') ? 'all' : 'multi';
            applyHighlightMode();
        }
    });

    document.getElementById('scrollToSingle').addEventListener('click', () => {
        const h2s = document.querySelectorAll('#calculation-details h2');
        for (const h2 of h2s) {
            if (h2.textContent.includes('＜単発ルート＞')) {
                h2.scrollIntoView({ behavior: 'smooth' });
                break;
            }
        }
    });

    document.getElementById('scrollToMulti').addEventListener('click', () => {
        const h2s = document.querySelectorAll('#calculation-details h2');
        for (const h2 of h2s) {
            if (h2.textContent.includes('＜10連ルート＞')) {
                h2.scrollIntoView({ behavior: 'smooth' });
                break;
            }
        }
    });

    runSimulationAndDisplay();
});

====================
FILE: master.js
====================
/**
 * 担当: ガチャ設定およびアイテム情報のマスターデータ定義
 * 依存関係: なし
 */

// --- マスターデータ ---
const gachaMaster = {
    '34': { name: '(旧)ハロウィン',
            featuredItemRate: 600,
            featuredItemStock: 5,
            guaranteedCycle: 30,
            uberGuaranteedFlag: false,
            legendGuaranteedFlag: false,
            rarityRates: { '0': 2000, '1': 5000, '2': 3000, '3': 0, '4': 0 },
            pool: [0, 2, 3, 4, 5, 10, 11, 12, 14] },

    '42': { name: '1.1億DL記念',
            featuredItemRate: 500,
            featuredItemStock: 5,
            guaranteedCycle: 30,
            uberGuaranteedFlag: false,
            legendGuaranteedFlag: false,
            rarityRates: { '0': 1000, '1': 5000, '2': 3000, '3': 1000, '4': 0 },
            pool: [0, 2, 3, 4, 5, 10, 11, 12, 14, 375, 381, 689] },

    '44': { name: 'ハロウィン',
            featuredItemRate: 500,
            featuredItemStock: 8,
            guaranteedCycle: 30,
            uberGuaranteedFlag: false,
            legendGuaranteedFlag: false,
            rarityRates: { '0': 2000, '1': 4900, '2': 3000, '3': 0, '4': 100 },
            pool: [0, 2, 3, 4, 5, 10, 11, 12, 14, 18] },
            
    '45': { name: 'にゃんこレンジャー',
            featuredItemRate: 0,
            featuredItemStock: 0,
            guaranteedCycle: 10,
            uberGuaranteedFlag: true,
            legendGuaranteedFlag: false,
            rarityRates: { '0': 0, '1': 7000, '2': 2300, '3': 500, '4': 200 },
            pool: [0,2,3,4,5,11,12,14,197,184,375,726,831] }
};

const itemMaster = {
    0: { name: "スピダ", rarity: 1 },
    2: { name: "ネコボン", rarity: 2 },
    3: { name: "ニャンピュ", rarity: 1 },
    4: { name: "おかめ", rarity: 2 },
    5: { name: "スニャ", rarity: 2 },
    10: { name: "5千XP", rarity: 0 },
    11: { name: "1万XP", rarity: 1 },
    12: { name: "3万XP", rarity: 1 },
    14: { name: "10万XP", rarity: 2 },
    18: { name: "200万XP", rarity: 4 },
    197: { name: "100万XP", rarity: 4 },
    184: { name: "ミスターニンジャ", rarity: 3 },
    375: { name: "記念ネコ", rarity: 3 },
    381: { name: "ねこ農家", rarity: 3 },
    689: { name: "石の上にも10年ネコ", rarity: 3 },
    726: { name: "ネコメダル王", rarity: 3 },
    831: { name: "スカーフにゃんこ", rarity: 3 }
};

====================
FILE: style.css
====================
/**
 * 担当: テーブルレイアウト、ハイライト色、UI要素のスタイリング定義
 * 依存関係: なし
 */
 
 body {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
    line-height: 1.2;
    padding: 5px;
    max-width: 1200px;
    margin: 0 auto;
    background-color: #f4f7f9;
    color: #333;
    font-size: 9px;
}
.container {
    background: #fff;
    padding: 5px;
    border-radius: 12px;
    box-shadow: 0 6px 15px rgba(0, 0, 0, 0.1);
}
h1 {
    color: #004085;
    font-size: 0.9rem;
    border-bottom: 1px solid #e9ecef;
    padding-bottom: 3px;
    margin-top: 0;
    text-align: center;
}
.controls {
    display: flex;
    flex-direction: column;
    gap: 5px;
    margin-bottom: 10px;
    padding: 4px;
    background-color: #f9fbfd;
    border-radius: 4px;
}
.row {
    display: flex;
    flex-wrap: wrap;
    justify-content: space-between;
    gap: 5px;
    align-items: center;
}
.control-group-left, .control-group-right {
    display: flex;
    align-items: center;
    gap: 15px;
}
.input-item {
    flex: 0 1 auto;
    display: flex;
    flex-direction: row;
    align-items: center;
    gap: 3px;
}
.input-item-display-only {
    flex: 0 1 auto;
    display: flex;
    align-items: center;
    font-size: 0.7rem;
    color: #555;
    padding: 0 5px;
}
.input-item-seed {
    display: flex;
    flex-direction: row;
    align-items: center;
    gap: 3px;
}
.seed-input-group {
    display: flex;
    align-items: center;
    gap: 5px;
    flex: 1 1 200px;
}
label {
    font-weight: 600;
    color: #555;
}
input[type="number"],
select {
    padding: 3px;
    border: 1px solid #ccc;
    border-radius: 3px;
    font-size: 0.8rem;
    width: 100%;
    box-sizing: border-box;
    transition: border-color 0.3s;
}
input[type="number"]:focus,
select:focus {
    outline: none;
    border-color: #007bff;
}
button {
    flex-shrink: 0;
    width: auto;
    padding: 5px 10px;
    background-color: #007bff;
    color: #fff;
    border: none;
    border-radius: 3px;
    cursor: pointer;
    font-size: 0.8rem;
    font-weight: bold;
    transition: background-color 0.3s ease, transform 0.2s ease;
}
.hidden-control {
    display: none !important;
}
#showSeedInputLink {
    color: #007bff;
    text-decoration: underline;
    cursor: pointer;
    padding: 0 5px;
    font-weight: bold;
}
#copySeedLink {
    color: #007bff;
    text-decoration: underline;
    cursor: pointer;
    white-space: nowrap;
}

button:hover {
    background-color: #0056b3;
    transform: translateY(-2px);
}
#result-container {
    margin-top: 15px;
}
#result-table-container {
    overflow-x: auto;
    border: 1px solid #e0e0e0;
    border-radius: 8px;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
}
table {
    width: 100%;
    border-collapse: collapse;
}
th, td {
    padding: 3px;
    text-align: center;
    border: 1px solid #e0e0e0;
    word-break: break-word;
    font-size: 0.8rem;
    min-width: 25px;
}
th {
    background-color: #f0f4f7;
    color: #444;
    font-weight: 600;
    position: sticky;
    top: 0;
    z-index: 1;
}
thead th:first-child {
    z-index: 2;
}
td {
    background-color: #fff;
}
.row-number-header {
    font-family: Arial, sans-serif;
    font-weight: bold;
    width: 25px;
    cursor: pointer;
}
.col-no {
    width: 25px;
}

/* アイテム装飾 */
.featuredItem-text {
    color: #d9534f; /* 赤 #d9534f*/
    font-weight: bold;
    text-decoration: none; /* ← 下線を非表示にします */
}
.legendItem-text {
    color: #0000ff; /* 青 */
    font-weight: bold;
}

#result-table-container td a {
    color: inherit;
    text-decoration: none;
}

/* 凡例 */
.legend-box {
    padding: 2px 5px;
    border-radius: 3px;
    margin-left: 5px;
    cursor: pointer;
    border: 1px solid transparent;
}
.legend-box:hover {
    border: 1px solid #999;
}
.legend-single { background-color: #e0f7ff; }
.legend-multi { background-color: #ffffe0; }
.legend-common { background-color: #dfffb0; }

/* ハイライト用CSS (通常) */
.highlight-roll { background-color: #e0f7ff !important; } /* 単発 (青) */
.highlight-roll-10pull { background-color: #ffffe0 !important; } /* 10連 (黄) */
.highlight-roll-overlap { background-color: #dfffb0 !important; } /* 重複 (緑) */

/* ハイライト用CSS (10ロールごとの鮮やかな色) */
.highlight-roll-dark { background-color: #80d8ff !important; } /* 鮮やかな青 (Light Blue A100) */
.highlight-roll-10pull-dark { background-color: #ffff8d !important; } /* 鮮やかな黄 (Yellow A100) */
.highlight-roll-overlap-dark { background-color: #b9f6ca !important; } /* 鮮やかな緑 (Green A100) */

/* モード別表示用 */
/* Single Mode */
.mode-single .highlight-roll { background-color: #e0f7ff !important; }
.mode-single .highlight-roll-dark { background-color: #80d8ff !important; }
.mode-single .highlight-roll-overlap { background-color: #e0f7ff !important; } 
.mode-single .highlight-roll-overlap-dark { background-color: #80d8ff !important; }

.mode-single .highlight-roll-10pull,
.mode-single .highlight-roll-10pull-dark { background-color: #fff !important; }

/* Multi Mode */
.mode-multi .highlight-roll-10pull { background-color: #ffffe0 !important; }
.mode-multi .highlight-roll-10pull-dark { background-color: #ffff8d !important; }
.mode-multi .highlight-roll-overlap { background-color: #ffffe0 !important; }
.mode-multi .highlight-roll-overlap-dark { background-color: #ffff8d !important; }

.mode-multi .highlight-roll,
.mode-multi .highlight-roll-dark { background-color: #fff !important; }

#calculation-details {
    font-family: monospace;
    font-size: 11px;
    line-height: 1.4;
    margin-top: 15px;
    padding: 10px;
    border: 1px solid #ccc;
    border-radius: 5px;
    background: #f9f9f9;
}
#calculation-details h2 {
    font-size: 1.1rem;
    margin-top: 20px;
    margin-bottom: 5px;
    border-bottom: 1px solid #ccc;
    padding-bottom: 3px;
}
#toggleDetailsBtn {
    background-color: #6c757d;
}
#toggleDetailsBtn:hover {
    background-color: #5a6268;
}
#details-controls {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-top: 10px;
}
.scroll-buttons {
    display: flex;
    gap: 10px;
}
.scroll-buttons button {
    font-size: 0.75rem;
    background-color: #28a745;
}
.scroll-buttons button:hover {
    background-color: #218838;
}

====================
FILE: utils.js
====================
/**
 * 担当: URLクエリ生成、乱数生成、共有の表示補助等の汎用ユーティリティ関数
 * 依存関係: master.js (itemMaster/gachaMasterの参照)
 */

// --- ユーティリティ関数 ---

function generateUrlQuery(p) {
    const query = new URLSearchParams();
    // DEFAULT_PARAMSはmain.jsで定義されますが、参照エラーを防ぐため
    // ここでチェックするか、呼び出し側で制御します。
    // 今回は単純化のため、呼び出し側でフィルタリング済みのオブジェクトを受け取る想定、
    // もしくは単純な変換を行います。
    for (const key in p) {
        if (p[key] !== null && p[key] !== undefined) query.set(key, p[key]);
    }
    return '?' + query.toString();
}

function xorshift32(seed) {
    let x = seed;
    x ^= x << 13; x ^= x >>> 17; x ^= x << 15;
    return x >>> 0;
}

function setupGachaRarityItems() {
    for (const gachaId in gachaMaster) {
        const gacha = gachaMaster[gachaId];
        if (gacha && gacha.pool) {
            gacha.rarityItems = { '0': [], '1': [], '2': [], '3': [], '4': [] };
            for (const itemId of gacha.pool) {
                const item = itemMaster[itemId];
                if (item && gacha.rarityItems[item.rarity] !== undefined) {
                    gacha.rarityItems[item.rarity].push(itemId);
                }
            }
            for (const rarity in gacha.rarityItems) gacha.rarityItems[rarity].sort((a, b) => a - b);
        }
    }
}

function generateMasterInfoHtml(gacha) {
    let html = `<h2>＜マスター情報＞</h2>`;
    // activeGachaIdはグローバル変数としてmain.jsで管理される想定
    html += `(ガチャ) ${gacha.name}(ID:${window.activeGachaId || '?'})<br>`;
    html += `(目玉) ${gacha.featuredItemRate > 0}(レート:${gacha.featuredItemRate}, 初期残数:${gacha.featuredItemStock})<br>`;
    html += `(確定) 超激:${gacha.uberGuaranteedFlag}, 伝説:${gacha.legendGuaranteedFlag}<br>`;
    
    const r = gacha.rarityRates;
    const r0 = r['0'];
    const t1 = r0;
    const t2 = r0 + r['1'];
    const t3 = t2 + r['2'];
    const t4 = t3 + r['3'];
    
    let rateStr = `(レート) `;
    if (r0 === 0) rateStr += `0(ノーマル)-, `;
    else rateStr += `0(ノーマル)～${t1-1}, `;
    
    rateStr += `1(レア)～${t2-1}, `;
    rateStr += `2(激レア)～${t3-1}, `;
    rateStr += `3(超激レア)～${t4-1}, `;
    rateStr += `4(伝説レア)～9999`;
    html += rateStr + `<br>`;
    
    html += `(各レアリティ別アイテム)<br>`;
    const rarities = ['0.ノーマル', '1.レア', '2.激レア', '3.超激レア', '4.伝説レア'];
    for (let i = 0; i <= 4; i++) {
        const pool = gacha.rarityItems[i.toString()];
        if (pool && pool.length > 0) {
            const itemsStr = pool.map(id => `${itemMaster[id].name}(ID:${id})`).join(', ');
            html += `${rarities[i]}(${pool.length}種) ${itemsStr}<br>`;
        }
    }
    return html + '<br>';
}

function getFormattedItemComparison(nodeItemName, nodeItemId, nodeRarityId, prevItemId, comparisonTargetName) {
    const rComp = (nodeRarityId === 1) ? '1=1' : `${nodeRarityId}≠1`;
    let idComp = '';
    let targetDisplay = '';

    if (comparisonTargetName) {
         targetDisplay = comparisonTargetName;
    } else {
         targetDisplay = (prevItemId === -1) ? 'Null' : `${prevItemId}`;
    }

    if (prevItemId === -1) {
         idComp = (nodeItemId === -1) ? '=Null' : '≠Null'; 
    } else {
         idComp = (nodeItemId === prevItemId) ? `=${targetDisplay}` : `≠${targetDisplay}`;
    }
    
    const text = `${nodeItemName}(${nodeItemId}(${rComp})${idComp})`;
    return { text, isDupe: (nodeRarityId === 1 && nodeItemId !== -1 && nodeItemId === prevItemId) };
}

/**
 * アイテムリンク生成ヘルパー
 * fs: 現在の残り目玉数 (指定がない場合はnull/undefined)
 * ng: 次の確定までの回数 (指定がない場合は計算しない、またはnone)
 */
function generateItemLink(newSeed, newItemId, ngVal, rollNumberInSequence, isCompleted, fsVal) {
    // グローバルの activeGachaId を参照
    const gId = window.activeGachaId; 
    const currentParams = new URLSearchParams(window.location.search);
    const paramsForQuery = {};
    for (const [key, value] of currentParams.entries()) paramsForQuery[key] = value;
    if (!paramsForQuery.gacha) paramsForQuery.gacha = gId;

    paramsForQuery.seed = newSeed;
    if (newItemId !== undefined) paramsForQuery.lr = newItemId;

    // fsパラメータの設定
    if (fsVal !== undefined && fsVal !== null && !isNaN(fsVal)) {
        paramsForQuery.fs = fsVal;
    }

    // ngパラメータの設定
    // 引数で明示的に渡された場合のみ設定する方針
    if (ngVal !== undefined && ngVal !== null) {
        if (ngVal === 'none') {
             paramsForQuery.ng = 'none';
        } else {
             paramsForQuery.ng = ngVal.toString();
        }
    } else {
        // 既存ロジック互換（今回は使用しないが念のため残す）
        const initialInputNg = paramsForQuery.ng; // 元のクエリから取得
        // ...既存の計算ロジックが必要ならここに記述...
        // 今回は呼び出し元で計算した値を渡すため、ここはスルー
    }
    
    return generateUrlQuery(paramsForQuery);
}

====================
FILE: view-completed-details-render.js
====================
/**
 * 担当: 「コンプ済み」ビューにおける計算過程詳細（Step1-3およびルートログ）の描画
 * 依存関係: logic-common.js, utils.js
 */

/**
 * 計算詳細画面を構築し、指定のDOM（calculation-details）に挿入する
 */
function renderCompletedDetails(Nodes, SEED_LIST, gacha, tableRows, thresholds, initialLastRollId, initialNg, maxNodeIndex) {
    const rarityNames = ["ノーマル", "レア", "激レア", "超激レア", "伝説レア"];
    const gCycle = gacha.guaranteedCycle || 30;

    // マスター情報の生成
    let detailsHtml = generateMasterInfoHtml(gacha);

    // インラインで実行されるトグル関数（続きを表示ボタン用）
    const toggleScript = `
        window.toggleTableSection = function(id, btnId) {
            const body = document.getElementById(id);
            const btn = document.getElementById(btnId);
            if (body) {
                if (body.tagName === 'TBODY') body.style.display = 'table-row-group';
                else body.style.display = 'block';
                if (btn) btn.style.display = 'none';
            }
        };
    `;

    /**
     * ヘルパー: 行数制限（デフォルト30行）付きのテーブルHTMLを生成する
     */
    const createTableWithLimit = (idPrefix, headers, rowDataArray, title) => {
        let html = `<h2>${title}</h2>`;
        html += '<table style="table-layout: auto; width: auto; min-width: 100%; font-size: 9px; border-collapse: collapse;"><thead>';
        html += '<tr style="background-color: #f2f2f2;">';
        headers.forEach(h => {
            html += `<th style="border: 1px solid #ccc; padding: 5px; white-space: nowrap; text-align: center;">${h}</th>`;
        });
        html += '</tr></thead>';

        let visibleRows = '<tbody>';
        let hiddenRows = `<tbody id="${idPrefix}-more" style="display: none;">`;
        rowDataArray.forEach((row, idx) => {
            if (idx < 30) visibleRows += row;
            else hiddenRows += row;
        });
        html += visibleRows + '</tbody>' + hiddenRows + '</tbody></table>';
        if (rowDataArray.length > 30) {
            html += `<div id="${idPrefix}-btn" style="color: #007bff; cursor: pointer; text-decoration: underline; font-size: 10px; margin: 5px 0;"
                onclick="toggleTableSection('${idPrefix}-more', '${idPrefix}-btn')">続きを表示 (${rowDataArray.length - 30}行)</div>`;
        }
        return html + '<br>';
    };

    // 1. ＜step1(1) 通常抽選アイテム算出（再抽選前）＞
    const headers1 = ["No.", "Address", "Seed[n]", "Seed[n+1]", "rarity計算", "rarity", "Slot計算", "Item", "next guar", "最終Seed"];
    const rows1 = Nodes.map(node => {
        const threshold = thresholds[node.rarityId];
        const rarityCalc = `${node.seed1} % 10000 = ${node.roll1} ＜ ${threshold}`;
        const rarityNameNum = `${rarityNames[node.rarityId]}(${node.rarityId})`;
        const slotCalc = node.itemId !== -1 ? `${node.seed2} % ${node.poolSize} = ${node.slot}` : '-';
        
        let ngText = "---";
        if (!isNaN(initialNg) && initialNg > 0) {
            const offset = Math.floor((node.index - 1) / 2);
            let bNG = ((initialNg - 1 - offset) % gCycle + gCycle) % gCycle + 1;
            let aNG = ((initialNg - 2 - offset) % gCycle + gCycle) % gCycle + 1;
            ngText = `${bNG} → ${aNG}`;
        }

        return `<tr>
            <td style="border: 1px solid #ccc; padding: 5px; text-align: center;">${node.index}</td>
            <td style="border: 1px solid #ccc; padding: 5px; text-align: center;">${node.address}</td>
            <td style="border: 1px solid #ccc; padding: 5px; text-align: center; font-family: monospace; white-space: nowrap;">Seed[${node.index}]<br>${node.seed1}</td>
            <td style="border: 1px solid #ccc; padding: 5px; text-align: center; font-family: monospace; white-space: nowrap;">Seed[${node.index + 1}]<br>${node.seed2}</td>
            <td style="border: 1px solid #ccc; padding: 5px; text-align: center; white-space: nowrap;">${rarityCalc}</td>
            <td style="border: 1px solid #ccc; padding: 5px; text-align: center; white-space: nowrap;">${rarityNameNum}</td>
            <td style="border: 1px solid #ccc; padding: 5px; text-align: center; white-space: nowrap;">${slotCalc}</td>
            <td style="border: 1px solid #ccc; padding: 5px; text-align: center;">${node.itemId !== -1 ? node.itemName : '-'}</td>
            <td style="border: 1px solid #ccc; padding: 5px; text-align: center; white-space: nowrap;">${ngText}</td>
            <td style="border: 1px solid #ccc; padding: 5px; text-align: center; font-family: monospace;">${node.seed2}</td>
        </tr>`;
    });
    detailsHtml += createTableWithLimit("sec-step1-1", headers1, rows1, "ノード計算詳細 (No.1～)<br>＜step1(1) 通常抽選アイテム算出（再抽選前）＞");

    // 2. ＜step1(2) 確定アイテム算出（再抽選前）＞
    const headers2 = ["No.", "Address", "Seed[n]", "Seed[n+1]", "rarityG計算", "rarityG", "SlotG計算", "Item", "next guar", "最終Seed"];
    const rows2 = Nodes.map(node => {
        let ngText = "---";
        if (!isNaN(initialNg) && initialNg > 0) {
            const offset = Math.floor((node.index - 1) / 2);
            let bNG = ((initialNg - 1 - offset) % gCycle + gCycle) % gCycle + 1;
            let aNG = ((initialNg - 2 - offset) % gCycle + gCycle) % gCycle + 1;
            ngText = `${bNG} → ${aNG}`;
        }
        const uFlag = gacha.uberGuaranteedFlag, lFlag = gacha.legendGuaranteedFlag;
        const uRate = uFlag ? (gacha.rarityRates['3'] || 500) : 0, lRate = lFlag ? (gacha.rarityRates['4'] || 200) : 0;
        const totalG = uRate + lRate;
        
        let rGCalc = "---", rGName = "-";
        if (totalG > 0) {
            const res = node.seed1 % totalG;
            const isUber = (node.rarityGId === '3');
            rGCalc = `${node.seed1} % ${totalG} = ${res} (${isUber ? '0～' + (uRate - 1) : uRate + '～' + (totalG - 1)})`;
            rGName = isUber ? `超激レア(3)` : `伝説レア(4)`;
        }
        
        const slotGCalc = node.itemGId !== -1 ? `${node.seed2} % ${node.poolGSize} = ${node.slotG}` : '-';

        return `<tr>
            <td style="border: 1px solid #ccc; padding: 5px; text-align: center;">${node.index}</td>
            <td style="border: 1px solid #ccc; padding: 5px; text-align: center;">${node.address}</td>
            <td style="border: 1px solid #ccc; padding: 5px; text-align: center; font-family: monospace; white-space: nowrap;">Seed[${node.index}]<br>${node.seed1}</td>
            <td style="border: 1px solid #ccc; padding: 5px; text-align: center; font-family: monospace; white-space: nowrap;">Seed[${node.index + 1}]<br>${node.seed2}</td>
            <td style="border: 1px solid #ccc; padding: 5px; text-align: center; white-space: nowrap;">${rGCalc}</td>
            <td style="border: 1px solid #ccc; padding: 5px; text-align: center; white-space: nowrap;">${rGName}</td>
            <td style="border: 1px solid #ccc; padding: 5px; text-align: center; white-space: nowrap;">${slotGCalc}</td>
            <td style="border: 1px solid #ccc; padding: 5px; text-align: center;">${node.itemGId !== -1 ? node.itemGName : '-'}</td>
            <td style="border: 1px solid #ccc; padding: 5px; text-align: center; white-space: nowrap;">${ngText}</td>
            <td style="border: 1px solid #ccc; padding: 5px; text-align: center; font-family: monospace;">${node.seed2}</td>
        </tr>`;
    });
    detailsHtml += createTableWithLimit("sec-step1-2", headers2, rows2, "＜step1(2) 確定アイテム算出（再抽選前）＞");

    // 3. ＜step2 再抽選判定及び再抽選アイテム算出＞
    const headers3 = ["No.", "Address", "Seed[n]", "Seed[n+3]", "rarity計算", "rarity判定", "現アイテム", "前アイテム", "一致判定", "再抽選判定", "Slot計算", "再抽選後アイテム", "next guar", "最終Seed"];
    const rows3 = Nodes.map((node, i) => {
        const threshold = thresholds[node.rarityId];
        const rCalc = `${node.seed1} % 10000 <br> = ${node.roll1} ＜ ${threshold}`;
        const isRare = (node.rarityId === 1), r判定 = `${rarityNames[node.rarityId]}(${node.rarityId})<br>${isRare ? '該当' : '不該当'}`;
        const prevNode = (i >= 2) ? Nodes[i - 3] : null;
        const prevItemName = prevNode ? (prevNode.reRollFlag ? prevNode.reRollItemName : prevNode.itemName) : getItemNameSafe(initialLastRollId);
       
        const isMatch = (node.itemName === prevItemName), isReroll = (isRare && node.poolSize > 1 && isMatch);
        const rerollSlotCalc = node.reRollFlag ? `${node.seed3} <br> % ${node.poolSize - 1} = ${node.reRollSlot}` : '-';
        
        let ngText = "---";
        if (!isNaN(initialNg) && initialNg > 0) {
            const offset = Math.floor((node.index - 1) / 2), bNG = ((initialNg - 1 - offset) % gCycle + gCycle) % gCycle + 1, aNG = ((initialNg - 2 - offset) % gCycle + gCycle) % gCycle + 1;
            ngText = `${bNG} → ${aNG}`;
        }
        
        return `<tr>
            <td style="border: 1px solid #ccc; padding: 5px; text-align: center;">${node.index}</td>
            <td style="border: 1px solid #ccc; padding: 5px; text-align: center;">${node.address}</td>
            <td style="border: 1px solid #ccc; padding: 5px; text-align: center; font-family: monospace; white-space: nowrap;">Seed[${node.index}]<br>${node.seed1}</td>
            <td style="border: 1px solid #ccc; padding: 5px; text-align: center; font-family: monospace; white-space: nowrap;">Seed[${node.index + 3}]<br>${Nodes[node.index + 2]?.seed1 || '---'}</td>
            <td style="border: 1px solid #ccc; padding: 5px; text-align: center; white-space: nowrap;">${rCalc}</td>
            <td style="border: 1px solid #ccc; padding: 5px; text-align: center; white-space: nowrap;">${r判定}</td>
            <td style="border: 1px solid #ccc; padding: 5px; text-align: center;">${node.address}<br>${node.itemName}</td>
            <td style="border: 1px solid #ccc; padding: 5px; text-align: center;">${prevNode ? prevNode.address + '<br>' : ''}${prevItemName}</td>
            <td style="border: 1px solid #ccc; padding: 5px; text-align: center;">${isMatch ? '一致' : '不一致'}</td>
            <td style="border: 1px solid #ccc; padding: 5px; text-align: center;"><b>${isReroll ? '実行' : 'なし'}</b></td>
            <td style="border: 1px solid #ccc; padding: 5px; text-align: center; white-space: nowrap;">${rerollSlotCalc}</td>
            <td style="border: 1px solid #ccc; padding: 5px; text-align: center;">${node.reRollFlag ? node.reRollItemName : '-'}</td>
            <td style="border: 1px solid #ccc; padding: 5px; text-align: center; white-space: nowrap;">${ngText}</td>
            <td style="border: 1px solid #ccc; padding: 5px; text-align: center; font-family: monospace;">${node.reRollFlag ? node.seed3 : node.seed2}</td>
        </tr>`;
    });
    detailsHtml += createTableWithLimit("sec-step2", headers3, rows3, "＜step2 再抽選判定及び再抽選アイテム算出＞");

    // 4. ＜step3 再々抽選判定及び再々抽選アイテム算出＞
    const headers4 = ["No.", "Address", "Seed[n]", "Seed[n+2]", "rarity計算", "rarity判定", "現アイテム", "前アイテム(ReRollのみ)", "一致判定", "再々抽選判定", "Slot計算", "再々抽選後アイテム", "next guar", "最終Seed"];
    const rows4 = Nodes.map((node, i) => {
        const threshold = thresholds[node.rarityId], rCalc = `${node.seed1} % 10000 <br> = ${node.roll1} ＜ ${threshold}`;
        const isRare = (node.rarityId === 1), r判定 = `${rarityNames[node.rarityId]}(${node.rarityId})<br>${isRare ? '該当' : '不該当'}`;
        const pNode = (i >= 3) ? Nodes[i - 4] : null, prevRerollItem = (pNode && pNode.reRollFlag) ? pNode.reRollItemName : '---';
        const isMatch = (prevRerollItem !== '---' && node.itemName === prevRerollItem), isReReroll = (isRare && isMatch);
        
        const poolDiv = Math.max(1, node.poolSize - 1);
        const calcSlot = node.seed3 % poolDiv;
        let reRerollName = "-";
        if (isReReroll) {
            const pool = gacha.rarityItems[node.rarityId] || [];
            const filtered = pool.filter(id => id !== node.itemId);
            if (filtered.length > 0) reRerollName = getItemNameSafe(filtered[calcSlot % filtered.length]);
        }

        let ngText = "---";
        if (!isNaN(initialNg) && initialNg > 0) {
            const offset = Math.floor((node.index - 1) / 2), bNG = ((initialNg - 1 - offset) % gCycle + gCycle) % gCycle + 1, aNG = ((initialNg - 2 - offset) % gCycle + gCycle) % gCycle + 1;
            ngText = `${bNG} → ${aNG}`;
        }
        
        return `<tr>
            <td style="border: 1px solid #ccc; padding: 5px; text-align: center;">${node.index}</td>
            <td style="border: 1px solid #ccc; padding: 5px; text-align: center;">${node.address}</td>
            <td style="border: 1px solid #ccc; padding: 5px; text-align: center; font-family: monospace; white-space: nowrap;">Seed[${node.index}]<br>${node.seed1}</td>
            <td style="border: 1px solid #ccc; padding: 5px; text-align: center; font-family: monospace; white-space: nowrap;">Seed[${node.index + 2}]<br>${node.seed3}</td>
            <td style="border: 1px solid #ccc; padding: 5px; text-align: center; white-space: nowrap;">${rCalc}</td>
            <td style="border: 1px solid #ccc; padding: 5px; text-align: center; white-space: nowrap;">${r判定}</td>
            <td style="border: 1px solid #ccc; padding: 5px; text-align: center;">${node.address}<br>${node.itemName}</td>
            <td style="border: 1px solid #ccc; padding: 5px; text-align: center;">${(pNode && pNode.reRollFlag) ? pNode.address + '<br>' : ''}${prevRerollItem}</td>
            <td style="border: 1px solid #ccc; padding: 5px; text-align: center;">${isMatch ? '一致' : '不一致'}</td>
            <td style="border: 1px solid #ccc; padding: 5px; text-align: center;"><b>${isReReroll ? '実行' : 'なし'}</b></td>
            <td style="border: 1px solid #ccc; padding: 5px; text-align: center; white-space: nowrap;">${isReReroll ? `${node.seed3} % ${poolDiv} = ${calcSlot}` : '-'}</td>
            <td style="border: 1px solid #ccc; padding: 5px; text-align: center;">${reRerollName}</td>
            <td style="border: 1px solid #ccc; padding: 5px; text-align: center; white-space: nowrap;">${ngText}</td>
            <td style="border: 1px solid #ccc; padding: 5px; text-align: center; font-family: monospace;">${node.reRollFlag ? node.seed3 : node.seed2}</td>
        </tr>`;
    });
    detailsHtml += createTableWithLimit("sec-step3", headers4, rows4, "＜step3 再々抽選判定及び再々抽選アイテム算出＞");

    // 5. ＜単発ルート（ハイライト）計算ログ＞
    detailsHtml += '<h2>＜単発ルート（ハイライト）計算＞</h2>';
    let sIdx = 1, sRoll = 1, sNgTracker = initialNg;
    let sLastInfo = { addr: 'LastRoll', name: getItemNameSafe(initialLastRollId) };
    let sDetailsText = '<div id="sec-route-s-text" style="font-size: 12px; line-height: 1.6; font-family: monospace; background: #fdfdfd; padding: 15px; border: 1px solid #ddd;">';
    let sVisibleText = '', sHiddenText = '<div id="sec-route-s-more" style="display: none;">';

    while (sIdx <= maxNodeIndex && sRoll <= tableRows) {
        const node = Nodes[sIdx - 1]; if (!node) break;
        const isGuar = !isNaN(initialNg) && initialNg > 0 && (gacha.uberGuaranteedFlag || gacha.legendGuaranteedFlag) && (sRoll >= initialNg) && ((sRoll - initialNg) % 10 === 0);
        let block = `<strong>Roll ${sRoll}${isGuar ? '[Guar]' : ''}</strong><br>実行前SEED：Seed[${sIdx - 1}] ${SEED_LIST[sIdx - 1]}<br>`;
        
        if (isGuar) {
            block += `レアリティ計算：Seed[${sIdx}] ${node.seed1} % ${node.gDivisor} = ${node.gRoll} → ${node.rarityGName}(${node.rarityGId})<br>`;
            const b = sNgTracker; sNgTracker = gCycle;
            block += `スロット計算：Seed[${sIdx + 1}] ${node.seed2} % ${node.poolGSize} = ${node.slotG} ${node.itemGName}(${node.itemGId}) nextGuar ${b}→${sNgTracker} 最終Seed ${node.seed2}<br>`;
            sLastInfo = { addr: node.address + 'G', name: node.itemGName }; sIdx += 2;
        } else {
            const thres = thresholds[node.rarityId];
            block += `レアリティ計算：Seed[${sIdx}] ${node.seed1} % 10000 = ${node.roll1} ＜ ${thres} → ${rarityNames[node.rarityId]}(${node.rarityId})<br>`;
            const b = sNgTracker; sNgTracker = (sNgTracker <= 1) ? gCycle : sNgTracker - 1;
            block += `スロット計算：Seed[${sIdx + 1}] ${node.seed2} % ${node.poolSize} = ${node.slot} ${node.itemName}(${node.itemId}) nextGuar ${b}→${sNgTracker} 最終Seed ${node.seed2}<br>`;
            
            const isMatch = (node.itemName === sLastInfo.name), isRR = (node.rarityId === 1 && node.poolSize > 1 && isMatch);
            block += `再抽選判定：レアリティ判定 ${rarityNames[node.rarityId]}→${node.rarityId === 1 ? '該当' : '不該当'} 一致:${isMatch} → 再抽選:${isRR ? '実行' : 'なし'}<br>`;
            
            const pNode = (sIdx >= 3) ? Nodes[sIdx - 4] : null, pRRName = (pNode && pNode.reRollFlag) ? pNode.reRollItemName : '---';
            const isMatchRe = (pRRName !== '---' && node.itemName === pRRName), isReRR = (node.rarityId === 1 && isMatchRe);
            block += `再々抽選判定：前々再抽選:${pRRName} 一致:${isMatchRe} → 再抽選:${isReRR ? '実行' : 'なし'}<br>`;
            
            if (isRR || isReRR) {
                block += `再抽選スロット計算：Seed[${sIdx + 2}] % ${node.poolSize - 1} = ${node.reRollSlot} ${node.reRollItemName} 最終Seed ${node.seed3}<br>`;
                sLastInfo = { addr: node.address, name: node.reRollItemName }; sIdx += 3;
            } else {
                sLastInfo = { addr: node.address, name: node.itemName }; sIdx += 2;
            }
        }
        block += `----------------------------------------------------------------------------------------------------<br>`;
        if (sRoll <= 30) sVisibleText += block; else sHiddenText += block;
        sRoll++;
    }
    sDetailsText += sVisibleText + sHiddenText + '</div></div>';
    if (sRoll > 31) sDetailsText += `<div id="sec-route-s-btn" style="color: #007bff; cursor: pointer; text-decoration: underline; font-size: 11px; margin: 10px 0;"
        onclick="toggleTableSection('sec-route-s-more', 'sec-route-s-btn')">続きを表示 (${sRoll - 31}ロール)</div>`;
    detailsHtml += sDetailsText + '<br>';

    // 6. ＜10連ルート（ハイライト）計算ログ＞
    detailsHtml += '<h2>＜10連ルート（ハイライト）計算＞</h2>';
    let tIdx = 1, tRoll = 1, cycleCount = 1, tNgTracker = initialNg;
    let tLastInfo = { addr: 'LastRoll', name: getItemNameSafe(initialLastRollId) };
    let tDetailsText = '<div id="sec-route-t-text" style="font-size: 12px; line-height: 1.6; font-family: monospace; background: #f5faff; padding: 15px; border: 1px solid #b8d4f5;">';
    let tVisibleText = '', tHiddenText = '<div id="sec-route-t-more" style="display: none;">';

    while (tIdx <= maxNodeIndex && tRoll <= tableRows) {
        let cycleBlock = `<strong>【サイクル ${cycleCount}】</strong><br>実行前Seed：Seed[${tIdx - 1}] ${SEED_LIST[tIdx - 1]}<br>`;
        const nodeInit = Nodes[tIdx - 1]; if (!nodeInit) break;
        const uFlag = gacha.uberGuaranteedFlag, lFlag = gacha.legendGuaranteedFlag;
        const uRate = uFlag ? (gacha.rarityRates['3'] || 500) : 0, lRate = lFlag ? (gacha.rarityRates['4'] || 200) : 0;
        const totalG = uRate + lRate;
        
        if (totalG > 0) {
            const res = nodeInit.seed1 % totalG;
            cycleBlock += `確定枠のレアリティ判定：Seed[${tIdx}] % ${totalG} = ${res} → ${rarityNames[(res < uRate) ? '3' : '4']} 最終Seed ${nodeInit.seed1}<br>`;
        }
        cycleBlock += `====================================================================================================<br>`;
        tIdx++;
        for (let j = 0; j < 10; j++) {
            if (tRoll > tableRows || tIdx > maxNodeIndex) break;
            const node = Nodes[tIdx - 1];
            const isGuar = !isNaN(initialNg) && initialNg > 0 && (uFlag || lFlag) && (tRoll >= initialNg) && ((tRoll - initialNg) % 10 === 0);
            
            if (isGuar) {
                const poolG = gacha.rarityItems[nodeInit.rarityGId] || [];
                const slotG = node.seed1 % Math.max(1, poolG.length);
                const itemNameG = getItemNameSafe(poolG[slotG]);
                cycleBlock += `<strong>Roll ${tRoll}[Guar]</strong><br>実行前Seed：Seed[${tIdx - 1}] ${SEED_LIST[tIdx - 1]}<br>レアリティ：算出済み→${nodeInit.rarityGName}<br>`;
                const b = tNgTracker; tNgTracker = gCycle;
                cycleBlock += `スロット：Seed[${tIdx}] % ${poolG.length} = ${slotG} ${itemNameG} nextGuar ${b}→${tNgTracker} 最終Seed ${node.seed1}<br>`;
                tLastInfo = { addr: node.address + 'G', name: itemNameG }; tIdx += 1;
            } else {
                cycleBlock += `<strong>Roll ${tRoll}</strong><br>実行前Seed：Seed[${tIdx - 1}] ${SEED_LIST[tIdx - 1]}<br>`;
                const thres = thresholds[node.rarityId];
                cycleBlock += `レアリティ：Seed[${tIdx}] % 10000 = ${node.roll1} ＜ ${thres} → ${rarityNames[node.rarityId]}<br>`;
                const b = tNgTracker; tNgTracker = (tNgTracker <= 1) ? gCycle : tNgTracker - 1;
                cycleBlock += `スロット：Seed[${tIdx + 1}] % ${node.poolSize} = ${node.slot} ${node.itemName} nextGuar ${b}→${tNgTracker} 最終Seed ${node.seed2}<br>`;
                
                const isMatch = (node.itemName === tLastInfo.name), isRR = (node.rarityId === 1 && node.poolSize > 1 && isMatch);
                cycleBlock += `再抽選判定：一致:${isMatch} → 再抽選:${isRR ? '実行' : 'なし'}<br>`;
                
                const pNode = (tIdx >= 3) ? Nodes[tIdx - 4] : null, pRRName = (pNode && pNode.reRollFlag) ? pNode.reRollItemName : '---';
                const isMatchRe = (pRRName !== '---' && node.itemName === pRRName), isReRR = (node.rarityId === 1 && isMatchRe);
                cycleBlock += `再々抽選判定：一致:${isMatchRe} → 再抽選:${isReRR ? '実行' : 'なし'}<br>`;
                
                if (isRR || isReRR) {
                    cycleBlock += `再抽選スロット：Seed[${tIdx + 2}] % ${node.poolSize - 1} = ${node.reRollSlot} ${node.reRollItemName} 最終Seed ${node.seed3}<br>`;
                    tLastInfo = { addr: node.address, name: node.reRollItemName }; tIdx += 3;
                } else {
                    tLastInfo = { addr: node.address, name: node.itemName }; tIdx += 2;
                }
            }
            cycleBlock += `----------------------------------------------------------------------------------------------------<br>`;
            tRoll++;
        }
        if (cycleCount <= 3) tVisibleText += cycleBlock; else tHiddenText += cycleBlock;
        cycleCount++;
    }
    tDetailsText += tVisibleText + tHiddenText + '</div></div>';
    if (cycleCount > 4) tDetailsText += `<div id="sec-route-t-btn" style="color: #007bff; cursor: pointer; text-decoration: underline; font-size: 11px; margin: 10px 0;"
        onclick="toggleTableSection('sec-route-t-more', 'sec-route-t-btn')">続きを表示 (残り ${cycleCount - 4}サイクル)</div>`;
    detailsHtml += tDetailsText + `<script>${toggleScript}</script>`;

    // DOMへの挿入
    const detailsDiv = document.getElementById('calculation-details');
    detailsDiv.innerHTML = detailsHtml;

    // トグルボタンの状態制御
    const toggleBtn = document.getElementById('toggleDetailsBtn');
    document.getElementById('details-controls').style.display = 'flex';
    toggleBtn.onclick = () => {
        const isH = detailsDiv.style.display === 'none';
        detailsDiv.style.display = isH ? 'block' : 'none';
        toggleBtn.textContent = isH ? '計算過程を非表示' : '計算過程を表示';
    };
}

====================
FILE: view-completed-main.js
====================
/**
 * 担当: 「コンプ済み」ビューの全体制御とメイン結果テーブルの描画
 * 依存関係: logic-completed.js, view-completed-details-render.js, view-completed-path-sim.js
 */

function createAndDisplayCompletedSeedView(initialSeed, gacha, tableRows, thresholds, initialLastRollId, displaySeed, params, initialNg) {
    // データの計算
    const { Nodes, highlightInfo, maxNodeIndex } = calculateCompletedData(
        initialSeed, gacha, tableRows, thresholds, initialLastRollId, initialNg
    );

    // シードリストの生成
    const totalSeedsNeeded = maxNodeIndex * 5 + 100;
    const SEED_LIST = generateSeedList(initialSeed, totalSeedsNeeded);

    // --- 1. 計算詳細（ログ）の描画を委譲 ---
    if (typeof renderCompletedDetails === 'function') {
        renderCompletedDetails(Nodes, SEED_LIST, gacha, tableRows, thresholds, initialLastRollId, initialNg, maxNodeIndex);
    }

    // --- 2. メイン表示テーブルの構築 ---
    let table = `<table style="table-layout: fixed;"
        class="${currentHighlightMode === 'single' ? 'mode-single' : (currentHighlightMode === 'multi' ? 'mode-multi' : '')}"><thead>`;
    table += `<tr><th id="forceRerollToggle" class="col-no" style="cursor: pointer;">${window.forceRerollMode ? '☑' : '□'}</th><th>A</th><th>AG</th><th>B</th><th>BG</th></tr>`;
    table += '</thead><tbody>';

    for (let r = 1; r <= tableRows; r++) {
        const nodeIdxA = (r - 1) * 2 + 1, nodeIdxB = (r - 1) * 2 + 2;
        const nodeA = Nodes[nodeIdxA - 1], nodeB = Nodes[nodeIdxB - 1];
        if (!nodeA || !nodeB) break;

        table += `<tr><td class="col-no" style="text-align: center;">${r}</td>`;
        
        const renderCell = (node, suffix) => {
            const address = node.address + suffix, info = highlightInfo.get(address), isGuaranteed = (suffix === 'G');
            const itemId = isGuaranteed ? node.itemGId : node.itemId, itemName = isGuaranteed ? node.itemGName : node.itemName;
            let cellContent = '---';

            if (itemId !== -1) {
                let showReRoll = (info && !isGuaranteed && ((info.single && info.s_reRoll) || (info.ten && info.t_reRoll))) ||
                                (!isGuaranteed && (node.reRollFlag || node.reRerollFlag || (window.forceRerollMode && node.rarityId === 1 && node.poolSize > 1)));
                
                const seedToUse = showReRoll ? node.seed3 : node.seed2;
                const href = generateItemLink(seedToUse, itemId, initialNg, r, true);

                if (showReRoll) {
                    let rrId = node.reRollItemId;
                    let rrName = node.reRollItemName;
                    
                    if (rrId === -1 && (node.reRollFlag || node.reRerollFlag)) {
                        const poolDiv = Math.max(1, node.poolSize - 1);
                        const calcSlot = node.seed3 % poolDiv;
                        const pool = gacha.rarityItems[node.rarityId] || [];
                        const fPool = pool.filter(id => id !== node.itemId);
                        if (fPool.length > 0) {
                            rrId = fPool[calcSlot % fPool.length];
                            rrName = getItemNameSafe(rrId);
                        }
                    }

                    const rrNextAddr = getAddressStringGeneric(node.index + 3, 2);
                    const hrefRe = generateItemLink(node.seed3, rrId, initialNg, r, true);
                    const hrefNorm = generateItemLink(node.seed2, node.itemId, initialNg, r, true);
                    cellContent = `<a href="${hrefNorm}">${node.itemName}</a><br>(${rrNextAddr})<a href="${hrefRe}">${rrName}</a>`;
                } else {
                    cellContent = `<a href="${href}">${itemName}</a>`;
                }
            }
            
            let cls = determineHighlightClass(info);
            return { html: `<td${cls ? ' class="' + cls + '"' : ''} style="text-align: center;">${cellContent}</td>` };
        };

        table += renderCell(nodeA, '').html + renderCell(nodeA, 'G').html + renderCell(nodeB, '').html + renderCell(nodeB, 'G').html + '</tr>';
    }
    table += '</tbody></table>';
    document.getElementById('result-table-container').innerHTML = table;

    // --- 3. 最適ルートシミュレーションUIのセットアップを委譲 ---
    if (typeof setupPathSimulationUI === 'function') {
        setupPathSimulationUI(Nodes, gacha, thresholds, initialLastRollId, initialNg);
    }
}

====================
FILE: view-completed-path-sim.js
====================
/**
 * 担当: 「コンプ済み」ビューにおける最適ルート探索（ビームサーチ）とシミュレーションUI
 * 依存関係: logic-common.js, utils.js
 */

/**
 * 修正版ビームサーチ（動的計画法）による最適ルート探索
 * Step 3 (再々抽選) および 10連確定枠の計算ロジックを完全に反映
 */
function runGachaBeamSearchCorrected(Nodes, initialLastRollId, totalTickets, gacha, thresholds, initialNg, targetLayers = []) {
    const gCycle = gacha.guaranteedCycle || 30;
    const uFlag = gacha.uberGuaranteedFlag;
    const lFlag = gacha.legendGuaranteedFlag;

    /**
     * 内部ヘルパー: 単一ロールのシミュレーション
     * nodeInitが渡された場合は、10連サイクル内の確定枠として計算する
     */
    const simulateSingleRoll = (startIdx, lastId, rollNum, currentNg, nodeInit = null) => {
        const node = Nodes[startIdx - 1];
        if (!node) return null;
        
        const isGuar = !isNaN(initialNg) && currentNg > 0 && (uFlag || lFlag) && (rollNum >= initialNg) && ((rollNum - initialNg) % 10 === 0);

        if (isGuar && nodeInit) {
            const poolG = gacha.rarityItems[nodeInit.rarityGId] || [];
            const slotG = node.seed1 % Math.max(1, poolG.length);
            const itemIdG = poolG[slotG];
            return { 
                itemId: itemIdG, 
                itemName: getItemNameSafe(itemIdG), 
                useSeeds: 1, 
                rarity: itemMaster[itemIdG]?.rarity || 0, 
                nextNg: gCycle 
            };
        } else if (isGuar) {
            return { 
                itemId: node.itemGId, 
                itemName: node.itemGName, 
                useSeeds: 2, 
                rarity: itemMaster[node.itemGId]?.rarity || 0, 
                nextNg: gCycle 
            };
        } else {
            const isMatch = (node.itemId !== -1 && node.itemId === lastId);
            const isRR = (node.rarityId === 1 && node.poolSize > 1 && isMatch) || node.reRerollFlag;
            
            let finalId = node.itemId;
            let finalName = node.itemName;

            if (isRR) {
                const pool = gacha.rarityItems[node.rarityId] || [];
                const filtered = pool.filter(id => id !== node.itemId);
                if (filtered.length > 0) {
                    const slot = node.seed3 % Math.max(1, filtered.length);
                    finalId = filtered[slot];
                    finalName = getItemNameSafe(finalId);
                }
            }
            const nextNg = (currentNg <= 1) ? gCycle : currentNg - 1;
            return { 
                itemId: finalId, 
                itemName: finalName, 
                useSeeds: isRR ? 3 : 2, 
                rarity: itemMaster[finalId]?.rarity || 0, 
                nextNg 
            };
        }
    };

    let dp = new Array(totalTickets + 1).fill(null).map(() => new Map());
    
    dp[0].set(`1_${initialLastRollId}_${initialNg}`, {
        nodeIdx: 1, 
        lastId: initialLastRollId, 
        currentNg: initialNg,
        layerCounts: new Array(targetLayers.length).fill(0),
        ubers: 0, 
        legends: 0, 
        path: [], 
        rollCount: 1
    });

    const calculateScore = (state) => {
        let score = 0;
        for (let i = 0; i < state.layerCounts.length; i++) {
            score += state.layerCounts[i] * Math.pow(1000, targetLayers.length - i + 1);
        }
        return score + (state.ubers * 10) + state.legends;
    };

    for (let t = 0; t < totalTickets; t++) {
        const states = Array.from(dp[t].values())
            .sort((a, b) => calculateScore(b) - calculateScore(a))
            .slice(0, 200);

        for (let state of states) {
            const resS = simulateSingleRoll(state.nodeIdx, state.lastId, state.rollCount, state.currentNg);
            if (resS) {
                const newLayerCounts = [...state.layerCounts];
                targetLayers.forEach((ids, idx) => { 
                    if (ids.includes(resS.itemId)) newLayerCounts[idx]++; 
                });

                const nextState = {
                    nodeIdx: state.nodeIdx + resS.useSeeds, 
                    lastId: resS.itemId, 
                    currentNg: resS.nextNg,
                    layerCounts: newLayerCounts, 
                    ubers: state.ubers + (resS.rarity === 3 ? 1 : 0),
                    legends: state.legends + (resS.rarity === 4 ? 1 : 0),
                    path: state.path.concat({ 
                        type: 'single', 
                        item: resS.itemName, 
                        addr: Nodes[state.nodeIdx - 1]?.address || '---'
                    }),
                    rollCount: state.rollCount + 1
                };

                const key = `${nextState.nodeIdx}_${nextState.lastId}_${nextState.currentNg}`;
                if (!dp[t + 1].has(key) || calculateScore(dp[t + 1].get(key)) < calculateScore(nextState)) {
                    dp[t + 1].set(key, nextState);
                }
            }

            if (t + 10 <= totalTickets) {
                const nodeInit = Nodes[state.nodeIdx - 1];
                if (nodeInit) {
                    let curIdx = state.nodeIdx + 1, curLastId = state.lastId, curNg = state.currentNg, curRoll = state.rollCount;
                    let items = [], ubers = 0, legends = 0, addLayer = new Array(targetLayers.length).fill(0), validCycle = true;

                    for (let j = 0; j < 10; j++) {
                        if (!Nodes[curIdx - 1]) { validCycle = false; break; }
                        const res = simulateSingleRoll(curIdx, curLastId, curRoll, curNg, nodeInit);
                        if (!res) { validCycle = false; break; }
                        items.push(res.itemName);
                        targetLayers.forEach((ids, idx) => { if (ids.includes(res.itemId)) addLayer[idx]++; });
                        if (res.rarity === 3) ubers++;
                        if (res.rarity === 4) legends++;
                        curIdx += res.useSeeds; curLastId = res.itemId; curNg = res.nextNg; curRoll++;
                    }

                    if (validCycle) {
                        const nextStateTen = {
                            nodeIdx: curIdx, 
                            lastId: curLastId, 
                            currentNg: curNg,
                            layerCounts: state.layerCounts.map((c, idx) => c + addLayer[idx]),
                            ubers: state.ubers + ubers, 
                            legends: state.legends + legends,
                            path: state.path.concat({ 
                                type: 'ten', 
                                items: items, 
                                addr: nodeInit.address 
                            }),
                            rollCount: curRoll
                        };
                        const keyTen = `${nextStateTen.nodeIdx}_${nextStateTen.lastId}_${nextStateTen.currentNg}`;
                        if (!dp[t + 10].has(keyTen) || calculateScore(dp[t + 10].get(keyTen)) < calculateScore(nextStateTen)) {
                            dp[t + 10].set(keyTen, nextStateTen);
                        }
                    }
                }
            }
        }
    }
    let best = null;
    for (let i = totalTickets; i >= 0; i--) {
        for (let state of dp[i].values()) {
            if (!best || calculateScore(state) > calculateScore(best)) best = state;
        }
        if (best) break;
    }
    return best;
}

/**
 * シミュレーション用UIの構築
 */
function setupPathSimulationUI(Nodes, gacha, thresholds, initialLastRollId, initialNg) {
    const detailsControls = document.getElementById('details-controls');
    let simGroup = document.getElementById('sim-ui-group');
    let resultDisplay = document.getElementById('sim-result-text');

    // アイテム彩色ヘルパー
    const getColoredItemHtml = (name) => {
        const itemEntry = Object.values(itemMaster).find(it => it.name === name);
        if (!itemEntry) return name;
        if (itemEntry.rarity === 3) return `<span style="color: #ff0000; font-weight: bold;">${name}</span>`;
        if (itemEntry.rarity === 4) return `<span style="color: #0000ff; font-weight: bold;">${name}</span>`;
        return name;
    };

    // UIが未生成の場合のみ枠組みを作成
    if (!simGroup) {
        simGroup = document.createElement('div');
        simGroup.id = 'sim-ui-group';
        simGroup.style = 'display:block; margin-left:12px; padding:10px; background:#eef6ff; border-radius:6px; border:1px solid #bdd7ff;';
        
        simGroup.innerHTML = `
            <div style="display:flex; align-items:center; gap:10px; margin-bottom:8px;">
                <div>
                    <label style="font-size: 0.7rem;">チケット:</label>
                    <input type="number" id="simTicketInput" value="30" min="1" max="1000" style="width:50px; padding:4px; border:1px solid #ccc; border-radius:4px;">
                </div>
                <div id="selectedTargetStatus" style="font-size:0.7rem; color:#0056b3; font-weight:bold; background:#fff; padding:4px 8px; border-radius:4px; border:1px solid #bdd7ff;">階層: 1</div>
                <button id="runSimBtn" style="background-color:#28a745; color:white; border:none; padding:6px 12px; border-radius:4px; cursor:pointer;">開始</button>
                <button id="copySimResultBtn" style="background-color:#6c757d; color:white; border:none; padding:6px 12px; border-radius:4px; cursor:pointer;">コピー</button>
            </div>
            <div id="targetLayersContainer"></div>
            <button id="addPriorityLayerBtn" style="margin-top:8px; font-size:0.7rem; padding:4px 8px; cursor:pointer;">＋ 次順位を追加</button>
        `;
        detailsControls.appendChild(simGroup);

        const layersContainer = document.getElementById('targetLayersContainer');
        const createLayerUI = (priority) => {
            const wrapper = document.createElement('div');
            wrapper.style.marginTop = '10px';
            wrapper.innerHTML = `<div style="font-size:0.7rem; font-weight:bold; margin-bottom:3px;">【第 ${priority} 優先ターゲット】</div>`;
            const area = document.createElement('div');
            area.className = 'layer-selection-area';
            area.style = 'display:flex; flex-wrap:wrap; gap:8px; background:#fff; padding:6px; border-radius:4px; border:1px solid #ccc; max-height:100px; overflow-y:auto;';
            const targetPool = [];
            Object.keys(gacha.rarityItems).forEach(rid => { if (gacha.rarityItems[rid]) targetPool.push(...gacha.rarityItems[rid]); });
            Array.from(new Set(targetPool)).forEach(id => {
                const item = itemMaster[id]; if (!item) return;
                const label = document.createElement('label'); label.style = 'font-size:0.7rem; display:flex; align-items:center; cursor:pointer;';
                let col = item.rarity === 2 ? '#c0a000' : (item.rarity === 3 ? '#d9534f' : (item.rarity === 4 ? '#0000ff' : '#333'));
                label.innerHTML = `<input type="checkbox" class="layer-target-checkbox" value="${id}" style="margin-right:3px;"><span style="color: ${col};">${item.name}</span>`;
                area.appendChild(label);
            });
            wrapper.appendChild(area); layersContainer.appendChild(wrapper);
            document.getElementById('selectedTargetStatus').textContent = `階層: ${layersContainer.children.length}`;
        };
        createLayerUI(1);
        document.getElementById('addPriorityLayerBtn').onclick = () => createLayerUI(layersContainer.children.length + 1);

        resultDisplay = document.createElement('div');
        resultDisplay.id = 'sim-result-text';
        resultDisplay.style = 'margin-top:20px; padding:15px; border:1px dashed #28a745; background-color:#fafffa; white-space:pre-wrap; font-family:monospace; font-size:0.8rem; display:none;';
        document.getElementById('result-container').appendChild(resultDisplay);
    }

    // ★重要: データが更新されるたびに onclick ハンドラを再設定し、最新の Nodes を参照させる
    document.getElementById('runSimBtn').onclick = () => {
        const tickets = parseInt(document.getElementById('simTicketInput').value);
        if (isNaN(tickets) || tickets <= 0) return alert("枚数を入力してください");

        const layers = document.querySelectorAll('.layer-selection-area');
        const targetLayers = Array.from(layers).map(area => {
            const checked = area.querySelectorAll('.layer-target-checkbox:checked');
            return Array.from(new Set(Array.from(checked).map(cb => parseInt(cb.value))));
        });

        const result = runGachaBeamSearchCorrected(Nodes, initialLastRollId, tickets, gacha, thresholds, initialNg, targetLayers);
        const display = document.getElementById('sim-result-text');

        if (!result) {
            display.textContent = "条件に合うルートが見つかりませんでした。";
            window.lastSimText = "";
        } else {
            display.innerHTML = "";
            const hdr = document.createElement('div');
            hdr.style = 'font-weight: bold; margin-bottom: 10px;';
            let statusT = result.layerCounts.map((c, i) => `P${i + 1}:${c}`).join(', ');
            hdr.textContent = `【最適ルート】(${statusT}, 超激:${result.ubers}, 伝説:${result.legends})`;
            display.appendChild(hdr);

            let plainText = `【最適ルートシミュレーション結果】(${statusT}, 超激:${result.ubers}, 伝説:${result.legends})\n\n`;

            // 単発ロールをまとめて表示するロジック
            let path = result.path, i = 0;
            while (i < path.length) {
                const rowC = document.createElement('div');
                rowC.style = 'display:flex; gap:5px; margin-bottom:4px;';
                const cb = document.createElement('input'); cb.type = 'checkbox'; cb.style.marginTop = '4px';
                const span = document.createElement('span');
                let rh = "", rHtml = "", rp = "";

                if (path[i].type === 'single') {
                    let j = i, iHtml = [], iP = [];
                    while (j < path.length && path[j].type === 'single') {
                        iHtml.push(getColoredItemHtml(path[j].item));
                        iP.push(path[j].item);
                        j++;
                    }
                    rh = `[単発ロール] ${j - i} Roll / ${path[i].addr} => `;
                    rHtml = iHtml.join('、');
                    rp = rh + iP.join('、');
                    i = j;
                } else {
                    rh = `[10連ロール] / ${path[i].addr} => `;
                    rHtml = path[i].items.map(n => getColoredItemHtml(n)).join('、');
                    rp = rh + path[i].items.join('、');
                    i++;
                }
                span.innerHTML = rh + rHtml;
                plainText += rp + "\n";
                cb.onchange = () => {
                    span.style.color = cb.checked ? '#888' : '';
                    span.style.textDecoration = cb.checked ? 'line-through' : '';
                };
                rowC.appendChild(cb); rowC.appendChild(span); display.appendChild(rowC);
            }
            window.lastSimText = plainText;
        }
        display.style.display = 'block';
    };

    document.getElementById('copySimResultBtn').onclick = () => {
        if (window.lastSimText && navigator.clipboard) {
            navigator.clipboard.writeText(window.lastSimText).then(() => {
                alert("結果をコピーしました");
            });
        }
    };
}

====================
FILE: view-uncompleted-details.js
====================
/**
 * 担当: 「未コンプ」ビューの下部に表示される計算過程および10連詳細のHTML描画
 * 依存関係: utils.js (generateItemLinkの利用)
 */

/**
 * 詳細テーブル（計算過程）と10連詳細のHTMLを生成してDOMに挿入
 */
function renderUncompletedDetails(Nodes, highlightInfo, maxNodes, tenPullCyclesData, gacha, initialLastRollId, params) {
    const ngVal = parseInt(params.get('ng'), 10);
    const initialFs = parseInt(params.get('fs'), 10) || 0;
    const guaranteedCycle = gacha.guaranteedCycle || 30;
    let ngTrackerDetail = !isNaN(ngVal) && ngVal > 0 ? ngVal : guaranteedCycle;

    // --- 1. 計算詳細 (単発ガチャ詳細) のHTML組み立て ---
    let html = generateMasterInfoHtml(gacha);
    
    let lastRollText = 'Null';
    if (initialLastRollId && itemMaster[initialLastRollId]) {
        lastRollText = `${itemMaster[initialLastRollId].name}(${initialLastRollId}(${itemMaster[initialLastRollId].rarity}))`;
    }

    html += '<h2>＜ノード計算詳細 (No.1～)＞</h2>';
    html += `LastRoll：${lastRollText}<br><br>単発ガチャ詳細<br>`;
    html += '<table style="table-layout: fixed; width: auto; font-size: 9px; border-collapse: collapse;"><thead>';
    html += '<tr style="background-color: #f2f2f2;">';
    html += '<th style="border: 1px solid #ccc; padding: 5px;">No.<br>Address</th><th style="border: 1px solid #ccc; padding: 5px;">Seed<br>(Sn)</th><th style="border: 1px solid #ccc; padding: 5px;">Featured<br>(Sn)</th><th style="border: 1px solid #ccc; padding: 5px;">Rarity<br>(Sn+1)</th><th style="border: 1px solid #ccc; padding: 5px;">Item<br>(Sn+2)</th><th style="border: 1px solid #ccc; padding: 5px;">Reroll<br>(Sn+3)</th><th style="border: 1px solid #ccc; padding: 5px;">ReRollFlag<br>Crnt vs Prev</th><th style="border: 1px solid #ccc; padding: 5px;">Roll<br>(next)</th><th style="border: 1px solid #ccc; padding: 5px;">NextGuar<br>aftRoll</th>'; 
    html += '</tr></thead><tbody>'; 

    for (let i = 1; i <= maxNodes; i++) {
        const node = Nodes[i-1];
        if (!node) continue;
        
        // NGカウンター更新
        let ngContentDetail = '-';
        if (node.singleRoll !== null) {
            let nextNg = ngTrackerDetail - 1;
            if (ngTrackerDetail === 1) { 
                 const nextStartNg = guaranteedCycle - 1; 
                 ngContentDetail = `目玉(確定)<br>${guaranteedCycle}→${nextStartNg}`;
                 ngTrackerDetail = nextStartNg;
            } else if (ngTrackerDetail > 1) {
                ngContentDetail = nextNg.toString();
                ngTrackerDetail = nextNg;
            }
        }
        
        // Highlight logic
        const itemInfo = highlightInfo.get(node.address);
        const baseCls = determineHighlightClass(itemInfo);
        let featuredClsAttr = '', itemClsForNormal = '', itemClsForReroll = '';

        if (itemInfo) {
            if (itemInfo.single && itemInfo.s_featured) featuredClsAttr = ` class="${baseCls}"`; 
            if ((itemInfo.single && !itemInfo.s_reRoll && !itemInfo.s_featured) || (itemInfo.ten && !itemInfo.t_reRoll)) itemClsForNormal = baseCls; 
            if ((itemInfo.single && itemInfo.s_reRoll) || (itemInfo.ten && itemInfo.t_reRoll)) itemClsForReroll = baseCls; 
        }

        // 修正箇所: 変数定義を追加
        const itemClsAttr = itemClsForNormal ? ` class="${itemClsForNormal}"` : '';
        const rerollClsAttr = itemClsForReroll ? ` class="${itemClsForReroll}"` : '';

        // Columns Content
        let singleDisplay = node.singleRoll !== null ? node.singleRoll.toString() : '';
        if (node.singleRoll !== null && node.singleUseSeeds !== null) {
             singleDisplay += `<br>${node.index}+${node.singleUseSeeds}<br>${node.index + node.singleUseSeeds}(${node.singleNextAddr})`;
        }

        // Featured Content
        let featuredContent = node.isFeatured ? 'True' : 'False';
        if (node.isFeatured) {
             const fHref = generateItemLink(node.seed1, -2, node.guaranteedNextNgVal || ngVal, node.index, false, initialFs);
             featuredContent = `<a href="${fHref}" style="text-decoration: none; color: inherit;">True</a>`;
        }
        featuredContent += `<br>S${node.index}%10000<br>${node.seed1 % 10000}${node.isFeatured ? '<' : '>='}${gacha.featuredItemRate}`;

        // Rarity Content
        let rarityContent = `${node.rarityId}(${node.rarity.name})<br>S${node.index + 1}%10000<br><span style="font-size: 80%;">${node.rarityRateRangeDisplay}</span>`;

        // Item & Reroll Content
        let itemContent = '-';
        if (node.itemId !== -1) {
             const nextNg = node.isGuaranteedRoll ? (guaranteedCycle - 1) : ngTrackerDetail;
             const iHref = generateItemLink(node.seed3, node.itemId, nextNg, node.index + 1, false, initialFs);
             let style = node.isFeatured && itemInfo && itemInfo.single ? "color: red; font-weight: bold;" : "";
             if (node.isGuaranteedRoll) {
                 const gHref = generateItemLink(node.prevSeed1, node.singleCompareItemId, guaranteedCycle, node.index, false, initialFs);
                 itemContent = `<a href="${gHref}" class="featuredItem-text">目玉(確定)</a> / <a href="${iHref}">${node.itemName}</a>`;
             } else {
                 itemContent = `<a href="${iHref}" style="${style}">${node.itemName}</a>`;
             }
             itemContent += `<br>S${node.index+2}%${node.poolSize}<br>${node.slot}→ID:${node.itemId}`;
        }

        let rerollContent = '-';
        if (node.reRollItemId !== -1) {
             const nextNg = node.isGuaranteedRoll ? (guaranteedCycle - 1) : ngTrackerDetail;
             const rHref = generateItemLink(node.seed4, node.reRollItemId, nextNg, node.index + 1, false, initialFs);
             rerollContent = `<a href="${rHref}">${node.reRollItemName}</a><br>S${node.index+3}%${node.poolSize>1?node.poolSize-1:0}<br>${node.reRollSlot}→ID:${node.reRollItemId}`;
        }

        // ReRoll Flag (Simplified)
        let reRollFlagContent = node.reRollFlag || '-'; 
        if (!node.reRollFlag && node.singleRoll) {
             reRollFlagContent = node.singleIsReroll ? 'True' : 'False';
             if (node.rarityId===1 && !node.isFeatured) reRollFlagContent += `<br>レア→Yes<br>${node.itemId}vs${node.singleCompareItemId}`;
             else if (node.isFeatured) reRollFlagContent += '<br>目玉→No';
             else reRollFlagContent += '<br>Other→No';
        }

        html += `<tr>
            <td style="border: 1px solid #ccc; padding: 5px; text-align: center;">${node.index}<br>${node.address}</td>
            <td style="border: 1px solid #ccc; padding: 5px; text-align: center; font-family: monospace;">S${node.index}<br>${node.seed1}</td>
            <td style="border: 1px solid #ccc; padding: 5px; text-align: center;"${featuredClsAttr}>${featuredContent}</td>
            <td style="border: 1px solid #ccc; padding: 5px; text-align: center;">${rarityContent}</td>
            <td style="border: 1px solid #ccc; padding: 5px; text-align: center;"${itemClsAttr}>${itemContent}</td>
            <td style="border: 1px solid #ccc; padding: 5px; text-align: center;"${rerollClsAttr}>${rerollContent}</td>
            <td style="border: 1px solid #ccc; padding: 5px; text-align: center;">${reRollFlagContent}</td>
            <td style="border: 1px solid #ccc; padding: 5px; text-align: center;">${singleDisplay}</td>
            <td style="border: 1px solid #ccc; padding: 5px; text-align: center;">${ngContentDetail}</td>
        </tr>`;
    }
    html += '</tbody></table>';

    // --- 2. 10連詳細セクション ---
    if (tenPullCyclesData && tenPullCyclesData.length > 0) {
        html += '<h2 style="margin-top:20px;">＜10連詳細 (現在地からのシミュレーション / 10サイクル)＞</h2>';
        let cumulativeFs = initialFs;
        
        tenPullCyclesData.forEach((cycle, idx) => {
            const count = cycle.featuredCountInCycle || 0;
            cumulativeFs -= count;
            
            html += `<div style="margin-top: 15px; border: 1px solid #000; padding: 10px; background-color: #fcfcfc;">`;
            html += `<h3>【Cycle ${idx + 1}】 (目玉: ${count})</h3>`;
            html += `<p>NG開始: ${cycle.startNgVal}, LastRoll: ${getItemNameSafe(cycle.startLastRollId)}</p>`;
            html += `<p>判定: ${cycle.guaranteedStatus}</p>`;
            
            html += '<h4>[Log]</h4><ul>';
            cycle.processLog.forEach(l => html += `<li style="font-size: 0.8rem;">${l}</li>`);
            html += '</ul>';

            html += '<h4>[Result]</h4><table style="border-collapse: collapse;">';
            cycle.results.forEach(res => {
                const style = res.isGuaranteed || res.isFeatured ? 'color: #d9534f; font-weight: bold;' : '';
                html += `<tr><td style="border: 1px solid #eee;">${res.label}</td><td style="border: 1px solid #eee; ${style}">${res.name}</td></tr>`;
            });
            html += '</table>';

            const linkUrl = generateItemLink(cycle.transition.nextSeed, cycle.transition.lastItemId, cycle.transition.nextNgVal, cycle.transition.nextIndex, false, cumulativeFs);
            html += `<p>Next: ${cycle.transition.nextIndex}(${cycle.transition.nextAddress}) → <a href="${linkUrl}" style="font-weight: bold; color: blue;">遷移する</a></p>`;
            html += '</div>';
        });
    }

    // DOM挿入
    const detailsDiv = document.getElementById('calculation-details'); 
    detailsDiv.innerHTML = html;
}

====================
FILE: view-uncompleted-table.js
====================
/**
 * 担当: 「未コンプ」ビューのメインテーブルおよび期待値情報のHTML描画
 * 依存関係: utils.js (generateItemLinkの利用)
 */

/**
 * 未コンプビューのメインテーブル（期待値表示含む）を生成してDOMに挿入する関数
 * @param {Array} Nodes - 計算済みの全ノードデータ
 * @param {Map} highlightInfo - ハイライト情報（単発ルート、10連ルートの判定用）
 * @param {Array} tenPullCyclesData - 10連シミュレーションの結果データ
 * @param {Object} expectedFeaturedCounts - 期待値データ
 * @param {number} tableRows - 表示する行数
 * @param {string} displaySeed - '1'なら詳細表示、それ以外は通常表示
 * @param {number} initialNg - 初期のNext Guaranteed値
 * @param {number} initialFs - 初期のFeatured Stock値
 * @param {number} guaranteedCycle - 確定周期（通常30）
 */
function renderUncompletedMainTable(Nodes, highlightInfo, tenPullCyclesData, expectedFeaturedCounts, tableRows, displaySeed, initialNg, initialFs, guaranteedCycle) {
    
    // --- ヘルパー関数: アイテムCSS決定 ---
    function determineItemCss(itemId) {
        if (!itemMaster[itemId]) return '';
        if (itemMaster[itemId].rarity === 4) return 'legendItem-text';
        if (itemMaster[itemId].rarity >= 3) return 'featuredItem-text';
        return '';
    }

    // --- 期待値表示エリア ---
    let expectedValueHtml = '<div>';
    if (expectedFeaturedCounts) {
        expectedValueHtml += '<h3>＜単発Nroll後の10連での目玉獲得数予測＞</h3>'; 
        const expectedKeys = Object.keys(expectedFeaturedCounts).sort((a, b) => parseInt(a) - parseInt(b));
        
        const expectedValueText = expectedKeys.map(n => {
            const m = expectedFeaturedCounts[n];
            const rollNum = parseInt(n) + 1; 
            return `${rollNum}roll:<span style="font-weight: bold;">${Math.floor(m)}個</span>`;
        }).join(', ');
        
        expectedValueHtml += `<p style="font-size: 1.1em;">${expectedValueText}</p>`;
    } else {
        expectedValueHtml += '<p>期待値データが見つかりませんでした。</p>';
    }
    expectedValueHtml += '</div><br>';

    // --- テーブルヘッダー生成 ---
    let table = expectedValueHtml;
    table += '<table style="table-layout: fixed;"><thead>';
    
    let header1 = `<tr><th rowspan="${displaySeed === '1' ? 2 : 1}" id="forceRerollToggle" class="col-no" style="cursor: pointer;">${window.forceRerollMode ? '☑' : '□'}</th>`;
    let header2 = '<tr>';

    if (displaySeed === '1') {
        header1 += '<th colspan="5">A</th><th colspan="5">B</th><th colspan="5">C</th><th colspan="5">G</th>';
        const subHeaders = ['S1<br>Feat', 'S2<br>Rare', 'S3<br>Slot', 'S4<br>Re', 'Item'];
        for(let i=0; i<4; i++) header2 += subHeaders.map(h => `<th>${h}</th>`).join('');
    } else {
        header1 += '<th>A</th><th>B</th><th>C</th><th>G</th>';
    }
    header1 += '</tr>';
    
    if (displaySeed === '1') { header2 += '</tr>'; table += header1 + header2; } else { table += header1; }
    table += '</thead><tbody>';

    // --- メインループ変数の初期化 ---
    let currentNgVal = !isNaN(initialNg) ? initialNg : -1;
    let currentFsVal = initialFs;

    // --- メインループ (各行の生成) ---
    for (let r = 0; r < tableRows; r++) {
        table += `<tr><td class="col-no">${r + 1}</td>`;
        const nodeIndices = [r * 3 + 1, r * 3 + 2, r * 3 + 3]; // 1行あたりA, B, Cの3ノード
        
        // --- A, B, C 列の処理 ---
        nodeIndices.forEach((idx, colIndex) => {
            const node = Nodes[idx - 1];
            if (!node) {
                table += displaySeed === '1' ? '<td colspan="5"></td>' : '<td></td>';
                return;
            }

            const info = highlightInfo.get(node.address);
            let cls = determineHighlightClass(info);
            
            const isSingleRouteNode = info && info.single; // 単発ガチャのルートに存在するノードか
            const isGuaranteedNode = isSingleRouteNode && node.isGuaranteedRoll; // 単発ルートで確定ロールか

            let content = '';
            let linkFs = currentFsVal;
            
            // ReRollFlagの取得
            const nodeReRollFlag = node.reRollFlag; // logic側で計算済みと仮定

            // ----------------------------------------------------------------
            // Case 1: Single Route Logic (単発ガチャルート上のノード)
            // ----------------------------------------------------------------
            if (isSingleRouteNode) {
                 if (isGuaranteedNode) {
                     // 1-A. Guaranteed Roll Processing (確定ノード)
                     // Next NG resets to guaranteedCycle - 1 (例: 29)
                     const nextNg = guaranteedCycle - 1; 

                     // 目玉(確定)リンク (前の状態への遷移、NG=30)
                     const guaranteedLinkSeed = node.prevSeed1; 
                     const guaranteedLinkNg = guaranteedCycle; 
                     const guaranteedLinkFs = initialFs; // FSは減らない(仕様による)
                     const guaranteedHref = generateItemLink(guaranteedLinkSeed, node.singleCompareItemId, guaranteedLinkNg, node.index, false, guaranteedLinkFs);
                     const guaranteedLinkStyle = `text-decoration: none; color: inherit; font-weight: bold;`;
                     const guaranteedLink = `<a href="${guaranteedHref}" class="featuredItem-text" style="${guaranteedLinkStyle}">目玉(確定)</a>`; 

                     // アイテム名リンク (確定ロール後の状態への遷移、NG=29)
                     const itemDisplayName = node.itemName;
                     const itemLinkSeed = node.seed3; // S(n+2)
                     const itemLinkNg = guaranteedCycle - 1; 
                     const itemLinkFs = initialFs;
                     const itemHref = generateItemLink(itemLinkSeed, node.itemId, itemLinkNg, r+1, false, itemLinkFs);
                     const itemLinkStyle = `text-decoration: none; color: inherit; font-weight: normal;"`;
                     const itemNameLink = `<a href="${itemHref}" style="${itemLinkStyle}">${itemDisplayName}</a>`;

                     content = `${guaranteedLink} / ${itemNameLink}`;
                     
                     // 状態更新
                     currentNgVal = guaranteedCycle - 1; // 次のNG値をリセット
                     currentFsVal = linkFs; 

                 } else {
                     // 1-B. Normal Single Route Node (非確定ノード)
                     // 次のノードの開始NG値
                     let nextNg = (currentNgVal !== -1) ? currentNgVal - 1 : 'none';
                     if (nextNg !== 'none' && nextNg <= 0) nextNg = guaranteedCycle;
                     
                     if (node.isFeatured) {
                         // 目玉アイテムの場合
                         linkFs = currentFsVal - 1;
                         const currentSeedVal = node.seed1; 
                         const hrefFeatured = generateItemLink(currentSeedVal, -2, nextNg, r+1, false, linkFs);
                         content = `${node.featuredNextAddress})<a href="${hrefFeatured}"><span class="featuredItem-text">目玉</span></a>`;
                         currentFsVal -= 1; // FSカウンターを減らす
                     } else {
                        // 通常アイテム
                        const isRerollHighlight = info ? info.s_reRoll : false;
                        
                        if (isRerollHighlight) {
                             // 再抽選が行われたケース
                             const preRerollName = node.itemName; 
                             const postRerollId = node.reRollItemId;
                             const postRerollName = node.reRollItemName;
                             
                             // Pre-Reroll Link: S(n+2)
                             const preSeed = node.seed3; 
                             const preHref = generateItemLink(preSeed, node.itemId, nextNg, r+1, false, linkFs);
                             let preCss = determineItemCss(node.itemId);

                             // Post-Reroll Link: S(n+3)
                             const postSeed = node.seed4; 
                             const postHref = generateItemLink(postSeed, postRerollId, nextNg, r+1, false, linkFs);
                             let postCss = determineItemCss(postRerollId);

                             content = `<a href="${preHref}" class="${preCss}">${preRerollName}</a><br>${node.reRollNextAddress})<a href="${postHref}" class="${postCss}">${postRerollName}</a>`;

                        } else {
                             // 通常排出のケース
                             // Item Link: S(n+2)
                             const nextSeed = node.seed3; 
                             const finalId = node.itemId; 
                             const href = generateItemLink(nextSeed, finalId, nextNg, r+1, false, linkFs);
                             let css = determineItemCss(finalId);
                             content = `<a href="${href}" class="${css}">${node.itemName}</a>`;

                             // 再抽選候補リンク (ReRollFlagがTrueの場合、または強制再抽選モードの場合)
                             if (node.reRollItemId !== -1) { 
                                 if (node.singleIsReroll || window.forceRerollMode) { // node.singleIsReroll を参照
                                     // ReRoll Link: S(n+3)
                                     const rrHref = generateItemLink(node.seed4, node.reRollItemId, nextNg, r+1, false, linkFs); 
                                     let rrName = node.reRollItemName;
                                     let rrCss = determineItemCss(node.reRollItemId);
                                     content += `<br>${node.reRollNextAddress})<a href="${rrHref}" class="${rrCss}">${rrName}</a>`;
                                 }
                             }
                        }
                     }
                     // 状態更新
                     if (currentNgVal !== -1) {
                         currentNgVal -= 1; // 通常時は1減らす
                         if (currentNgVal <= 0) currentNgVal = guaranteedCycle;
                     }
                 }
            } else {
                // ----------------------------------------------------------------
                // Case 2: Off-Route Logic (ルート外の共通ロジック)
                // ----------------------------------------------------------------
                // リンクNG値は「次のロールの開始NG値」
                let linkNgVal = (initialNg !== -1) ? initialNg - (r + 1) : 'none';
                if (linkNgVal !== 'none' && linkNgVal <= 0) {
                    // 0以下になった場合、次のロールの開始NG値は guaranteedCycle - 1
                    // (ここでの計算は簡易的なため、厳密なNG追跡が必要ならLogic側で計算してNodeに持たせるのが理想)
                    linkNgVal = guaranteedCycle - 1;
                }
                const linkFsVal = initialFs; 
                
                if (node.isFeatured) {
                    // 目玉アイテムの場合
                    const currentSeed = node.seed1; 
                    const hrefFeatured = generateItemLink(currentSeed, -2, linkNgVal, r+1, false, linkFsVal);
                    content = `${node.featuredNextAddress})<a href="${hrefFeatured}"><span class="featuredItem-text">目玉</span></a>`;
                    
                } else {
                    const finalId = node.itemId;
                    const preRerollName = node.itemName; 
                    
                    // 1. Pre-Reroll / Normal Link: S(n+2)
                    const nextSeedNormal = node.seed3; 
                    const hrefNormal = generateItemLink(nextSeedNormal, finalId, linkNgVal, r+1, false, linkFsVal);
                    let cssNormal = determineItemCss(finalId);

                    content = `<a href="${hrefNormal}" class="${cssNormal}">${preRerollName}</a>`;
                    
                    // 再抽選リンク (重複再抽選フラグがTrueの場合、または強制再抽選モードの場合)
                    if (node.reRollItemId !== -1 && node.isDupe) {
                        if (window.forceRerollMode || (info && info.ten && info.t_reRoll)) { // 10連ルートの再抽選判定などを考慮
                            // 2. Post-Reroll Link: S(n+3)
                            const nextSeedReroll = node.seed4; 
                            const rrId = node.reRollItemId;
                            const rrName = node.reRollItemName;
                            const rrHref = generateItemLink(nextSeedReroll, rrId, linkNgVal, r+1, false, linkFsVal);
                            let rrCss = determineItemCss(rrId);
                            
                            content += `<br>${node.reRollNextAddress})<a href="${rrHref}" class="${rrCss}">${rrName}</a>`;
                        }
                    }
                }
            }

            // --- セルHTML生成 ---
            if (displaySeed === '1') {
                const sub1 = `(S${(idx-1)*3+1})${node.seed1}<br>${node.seed1%10000}<br>${node.isFeatured}`;
                const sub2 = `(S${(idx-1)*3+2})${node.seed2}<br>${node.seed2%10000}<br>${node.rarity.name}`;
                const sub3 = `(S${(idx-1)*3+3})${node.seed3}<br>${node.poolSize}<br>${node.slot}`;
                let sub4 = '---';
                if (!node.isFeatured && node.reRollItemId !== -1) {
                    sub4 = `(S${(idx-1)*3+4})${node.seed4}<br>ReRoll`;
                }
                table += `<td${cls ? ' class="'+cls+'"' : ''}>${sub1}</td><td${cls ? ' class="'+cls+'"' : ''}>${sub2}</td><td${cls ? ' class="'+cls+'"' : ''}>${sub3}</td><td${cls ? ' class="'+cls+'"' : ''}>${sub4}</td><td${cls ? ' class="'+cls+'"' : ''}>${content}</td>`;
            } else {
                table += `<td${cls ? ' class="'+cls+'"' : ''}>${content}</td>`;
            }
        });

        // --- G Column Logic (10連ガチャシミュレーション結果) ---
        let gContent = '-';
        let gStyle = '';
        
        const cycleIndex = Math.floor(r / 10);
        const rollIndex = r % 10;
        
        const tenPullDetailData = tenPullCyclesData ? tenPullCyclesData[cycleIndex] : null; 
        
        if (rollIndex < 9) { gStyle = 'background-color: #ffffe0;'; } else if (rollIndex === 9) { gStyle = 'background-color: #ffff8d;'; }

        if (tenPullDetailData && rollIndex < 10) {
            const res = tenPullDetailData.results[rollIndex];
            if (res) {
                let cellName = res.name;
                if (res.isReroll && res.preRerollName) {
                    cellName = `（${res.preRerollName}↓）<br>${cellName}`;
                }
                if (res.isGuaranteed) {
                    cellName = `<span class="featuredItem-text">${cellName}</span>`;
                } else if (res.isFeatured) {
                    cellName = `<span class="featuredItem-text">${cellName}</span>`;
                }

                if (rollIndex === 9) {
                    const addressStr = tenPullDetailData.transition.nextAddress;
                    let nextNg = tenPullDetailData.transition.nextNgVal;
                    
                    if (isNaN(nextNg) || nextNg <= 0) {
                        nextNg = guaranteedCycle - 1; 
                    }
                    
                    let usedFs = tenPullDetailData.featuredCountInCycle || 0;
                    let nextFs = initialFs - usedFs; // ※累積計算は簡易的（このサイクル分のみ減算）

                    const href10 = generateItemLink(
                        tenPullDetailData.transition.nextSeed,
                        tenPullDetailData.transition.lastItemId,
                        nextNg,
                        tenPullDetailData.transition.nextIndex, 
                        false, 
                        nextFs
                    );
                    gContent = `${addressStr})<a href="${href10}">${cellName}</a>`;
                } else {
                    gContent = cellName;
                }
            }
        }
        
        if (displaySeed === '1') table += `<td colspan="5" style="${gStyle}">${gContent}</td>`;
        else table += `<td style="${gStyle}">${gContent}</td>`;
        table += '</tr>';
    }
    table += '</tbody></table>';

    // DOMへの挿入
    document.getElementById('result-table-container').innerHTML = table;
}

====================
FILE: view-uncompleted.js
====================
/**
 * 担当: 「未コンプ」ビュー全体の描画制御および各コンポーネントの呼び出し
 * 依存関係: logic-uncompleted.js, view-uncompleted-table.js, view-uncompleted-details.js
 */

function createAndDisplayUncompletedSeedView(initialSeed, gacha, tableRows, thresholds, initialLastRollId, displaySeed, params) {
    // 1. データ計算 (Logic)
    const { 
        Nodes, highlightInfo, maxNodes, singleRoutePath, 
        tenPullCyclesData, expectedFeaturedCounts 
    } = calculateUncompletedData(initialSeed, gacha, tableRows, thresholds, initialLastRollId, params);
    
    // デバッグ出力
    console.log("Uncompleted Data Calculated:", { Nodes: Nodes.length, tenPullCyclesData, expectedFeaturedCounts });

    // パラメータ取得
    const ngVal = parseInt(params.get('ng'), 10);
    const initialFs = parseInt(params.get('fs'), 10) || 0; 
    const guaranteedCycle = gacha.guaranteedCycle || 30;
    let initialNg = !isNaN(ngVal) && ngVal > 0 ? ngVal : guaranteedCycle;

    // 2. 詳細画面 (Debug View) のレンダリング
    renderUncompletedDetails(Nodes, highlightInfo, maxNodes, tenPullCyclesData, gacha, initialLastRollId, params);

    // 3. メインテーブル (Main View) のレンダリング
    // 注意: view-uncompleted-table.js 内の関数です。元の view-uncompleted.js の複雑なリンク生成ロジックは
    // そちらに移動している前提です。
    renderUncompletedMainTable(Nodes, highlightInfo, tenPullCyclesData, expectedFeaturedCounts, tableRows, displaySeed, initialNg, initialFs, guaranteedCycle);

    // 4. 詳細表示トグルの制御
    const detailsDiv = document.getElementById('calculation-details');
    const detailsControls = document.getElementById('details-controls');
    const toggleBtn = document.getElementById('toggleDetailsBtn');
    const scrollButtons = detailsControls.querySelector('.scroll-buttons');
    if (scrollButtons) scrollButtons.remove();
    
    detailsControls.style.display = 'flex';
    toggleBtn.style.display = 'inline-block'; 
    toggleBtn.onclick = () => {
        if (detailsDiv.style.display === 'none') {
            detailsDiv.style.display = 'block';
            toggleBtn.textContent = '計算過程を非表示';
        } else {
            detailsDiv.style.display = 'none';
            toggleBtn.textContent = '計算過程を表示';
        }
    };
}

