====================
FILE: index.html
====================
<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>イベントガチャロールズ</title>
    <link rel="stylesheet" href="style.css">
    <link rel="icon" href="data:,">
</head>
<body>

<div class="container">
    <h1>イベントガチャロールズ</h1>
    <div class="input-group">
        <div class="controls">
            <div class="row">
                <div class="control-group-left">
                    <div class="input-item">
                         <a id="showSeedInputLink" href="#">SEED入力</a>
                    </div>
                    <div class="input-item" id="guaranteedControl">
                        <label for="guaranteedRollsInput">next guaranteed</label>
                        <select id="guaranteedRollsInput"></select>
                    </div>
                    <div class="input-item" id="legendDisplay" style="font-size: 0.7rem;">
                        <span id="legendSingle" class="legend-box legend-single">単発ルート</span>
                        <span id="legendMulti" class="legend-box legend-multi">10連ルート</span>
                        <span id="legendCommon" class="legend-box legend-common">共通ルート</span>
                    </div>
                    <div id="lastRollDisplay" class="input-item-display-only"></div>
                </div>
                <div class="control-group-right">
                    <div class="input-item">
                        <label for="featuredCompleteCheckbox">コンプ済み</label>
                        <input type="checkbox" id="featuredCompleteCheckbox">
                    </div>
                    <div class="input-item" id="stockControl">
                        <label for="featuredStockInput">目玉残数</label>
                        <select id="featuredStockInput"></select>
                    </div>
                    <a id="copySeedLink" href="#">Copy SEED</a>
                </div>
            </div>

            <div class="row hidden-control" id="seedRow">
                <div class="input-item-seed">
                    <label for="seedInput">SEED</label>
                    <div class="seed-input-group">
                        <input type="number" id="seedInput" value="12345">
                        <button id="executeButton">更新</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="result-container">
        <div id="output"></div>
        <div id="result-table-container"></div>

        <div id="toggle-buttons-container" class="row" style="margin-top: 10px; justify-content: flex-start; gap: 10px;">
            <button id="toggleSeedBtn">SEEDを表示</button>
            <button id="toggleSimBtn">シミュレーションを表示</button>
       </div>

        <div id="sim-ui-container" style="display: none; margin-bottom: 15px;"></div>

        <div id="details-controls" style="display:none; margin-top: 10px; gap: 10px; align-items: center;">
            <button id="toggleDetailsBtn">計算過程を表示</button>
        </div>

        <div id="calculation-details" style="display:none;"></div>
    </div>
</div>

<div id="seed-popup-overlay" class="popup-overlay">
    <div class="popup-modal">
        <span class="popup-close-btn">&times;</span>
        <div id="popup-content"></div>
        <div style="margin-top: 15px; text-align: right;">
            <button id="copy-popup-content-btn">内容をコピー</button>
        </div>
    </div>
</div>

<script src="master.js"></script>
<script src="utils.js"></script>
<script src="logic-common.js"></script>
<script src="logic-completed-helpers.js"></script>
<script src="logic-completed-popup.js"></script>
<script src="logic-completed-search.js"></script>
<script src="logic-completed-highlight.js"></script>
<script src="logic-completed.js"></script>
<script src="logic-uncompleted-sim.js"></script>
<script src="logic-uncompleted.js"></script>
<script src="view-completed.js"></script>
<script src="view-uncompleted-details.js"></script>
<script src="view-uncompleted-table.js"></script>
<script src="view-uncompleted-main.js"></script>
<script src="view-uncompleted-ui.js"></script>
<script src="view-simulation-ui.js"></script>
<script src="view-simulation-layer.js"></script>
<script src="view-simulation-result.js"></script>
<script src="view-simulation-main.js"></script>
<script src="main.js"></script>

</body>
</html>

====================
FILE: logic-common.js
====================
/**
 * 担当: シード配列生成、レアリティ判定、アドレス計算等の共通計算ロジック
 * 依存関係: utils.js (getItemNameSafe等の利用)
 */

// --- 共通ロジック ---

/**
 * シード配列を一括生成する
 */
function generateSeedList(initialSeed, count) {
    const seeds = [initialSeed];
    for (let i = 1; i < count; i++) {
        seeds[i] = xorshift32(seeds[i - 1]);
    }
    return seeds;
}

/**
 * ロール値と閾値からレアリティ情報を取得する
 */
function getRarityFromRoll(roll, thresholds) {
    if (roll < thresholds['0']) return { id: 0, name: 'ノーマル' };
    if (roll < thresholds['1']) return { id: 1, name: 'レア' };
    if (roll < thresholds['2']) return { id: 2, name: '激レア' };
    if (roll < thresholds['3']) return { id: 3, name: '超激レア' };
    return { id: 4, name: '伝説レア' };
}

/**
 * アドレス文字列 (A1, B1, A2...) を生成する
 * cols: 列数 (completed=2, uncompleted=3)
 * 修正: 番地表示を [行][列] から [列][行] (例: B15) に変更
 */
function getAddressStringGeneric(n, cols) {
    if (n <= 0) return '';
    const zeroBasedIndex = n - 1;
    const col_char = String.fromCharCode('A'.charCodeAt(0) + (zeroBasedIndex % cols));
    const row_num = Math.floor(zeroBasedIndex / cols) + 1;
    return `${col_char}${row_num}`;
}

/**
 * アイテム名を取得する安全なヘルパー
 */
function getItemNameSafe(itemId) {
    if (itemId === -1 || itemId === undefined) return '---';
    return itemMaster[itemId]?.name || '---';
}

/**
 * ハイライトクラス判定ロジック
 */
function determineHighlightClass(info) {
    if (!info) return '';
    let cls = '';
    const isSingle10 = info.single && (info.singleRoll % 10 === 0);
    const isTen10 = info.ten && (info.tenRoll % 10 === 0);
    if (info.single && info.ten) {
        cls = (isSingle10 || isTen10) ?
            'highlight-roll-overlap-dark' : 'highlight-roll-overlap';
    } else if (info.single) {
        cls = isSingle10 ?
            'highlight-roll-dark' : 'highlight-roll';
    } else if (info.ten) {
        cls = isTen10 ?
            'highlight-roll-10pull-dark' : 'highlight-roll-10pull';
    }
    return cls;
}

====================
FILE: logic-completed-helpers.js
====================
/**
 * 担当: コンプ済みデータの基本計算ロジック、単発/10連ルートの詳細シミュレーション
 * 特殊仕様: 10連ルートの確定枠レアリティ判定(サイクル先頭)とスロット判定(到達時点)を分離
 */

// =================================================================================
// ヘルパー関数: ノード初期化
// =================================================================================

function initializeNodes(SEED_LIST, maxNodeIndex, gacha, thresholds) {
    const Nodes = [];
    const getAddress = (n) => getAddressStringGeneric(n, 2);
    const uFlag = gacha.uberGuaranteedFlag;
    const lFlag = gacha.legendGuaranteedFlag;
    const uRate = uFlag ?
        (gacha.rarityRates['3'] || 500) : 0;
    const lRate = lFlag ? (gacha.rarityRates['4'] || 200) : 0;
    const gDivisor = uRate + lRate;

    for (let i = 1; i <= maxNodeIndex; i++) {
        const node = {
            index: i,
            address: getAddress(i),
            seed1: SEED_LIST[i],
            seed2: SEED_LIST[i + 1],
            seed3: SEED_LIST[i + 2],
            seed4: SEED_LIST[i + 3],
            prevSeed1: SEED_LIST[i - 1]
        };
        // 通常枠計算
        node.roll1 = node.seed1 % 10000;
        node.rarityId = getRarityFromRoll(node.roll1, thresholds).id;
        const pool = gacha.rarityItems[node.rarityId] || [];
        node.poolSize = pool.length;
        if (pool.length > 0) {
            node.slot = node.seed2 % pool.length;
            node.itemId = pool[node.slot];
            node.itemName = getItemNameSafe(node.itemId);
        } else {
            node.itemId = -1;
            node.itemName = '---';
        }
        // 確定枠基本計算 (通常時/単発用)
        node.gDivisor = gDivisor;
        if (gDivisor > 0) {
            node.gRoll = node.seed1 % gDivisor;
            node.rarityGId = (node.gRoll < uRate) ? '3' : '4';
            node.rarityGName = (node.rarityGId === '3') ? '超激レア' : '伝説レア';
            const poolG = gacha.rarityItems[node.rarityGId] || [];
            node.poolGSize = poolG.length;
            node.slotG = node.seed2 % Math.max(1, poolG.length); 
            node.itemGId = poolG[node.slotG];
            node.itemGName = getItemNameSafe(node.itemGId);
        }
        Nodes.push(node);
    }
    return Nodes;
}

/**
 * 基本的なレア被り判定
 * 1行目(index 0, 1)は initialLastRollId と比較を行う
 */
function calculateRerolls(Nodes, initialLastRollId, gacha) {
    Nodes.forEach((node, i) => {
        // prevNode2は2つ前のノード。存在しない(1行目のA, B列など)場合は initialLastRollId を参照
        const prevNode2 = (i >= 2) ? Nodes[i - 2] : null;
        const prevId2 = prevNode2 ? prevNode2.itemId : (initialLastRollId || -1);
        
        // レア(rarityId=1)かつアイテムIDが直前と一致する場合に再抽選フラグを立てる
        node.reRollFlag = (node.rarityId === 1 && node.poolSize > 1 && node.itemId === prevId2);
        
        const prevNode3 = (i >= 3) ? Nodes[i - 3] : null;
        const prevRerollId3 = (prevNode3 && (prevNode3.reRollFlag || prevNode3.reRerollFlag)) ? prevNode3.reRollItemId : -1;
        node.reRerollFlag = (node.rarityId === 1 && node.itemId === prevRerollId3);

        if (node.reRollFlag || node.reRerollFlag) {
            const rrPool = (gacha.rarityItems[1] || []).filter(id => id !== node.itemId);
            if (rrPool.length > 0) {
                node.reRollSlot = node.seed3 % rrPool.length;
                node.reRollItemId = rrPool[node.reRollSlot];
                node.reRollItemName = getItemNameSafe(node.reRollItemId);
            }
        }
    });
}

// =================================================================================
// 内部パス計算: 単発ルート
// =================================================================================

function calculateSingleRollRoute(Nodes, tableRows, initialNg, initialLastRollId, gacha, thresholds, SEED_LIST) {
    const singleRouteText = [];
    const rarityNames = ["ノーマル", "レア", "激レア", "超激レア", "伝説レア"];
    const gCycle = gacha.guaranteedCycle || 30;
    let sIdx = 1, sRoll = 1, sNgTracker = parseInt(initialNg, 10), sLastId = initialLastRollId;

    while (sIdx <= Nodes.length && sRoll <= tableRows) {
        const node = Nodes[sIdx - 1];
        const isG = (sNgTracker === 1);
        
        let block = `<strong>Roll ${sRoll}${isG ? '[Guar]' : ''}</strong><br>`;
        if (isG) {
            block += `確定枠: Seed[${sIdx}] ${node.seed1} % ${node.gDivisor} → ${node.rarityGName}<br>`;
            block += `アイテム: ${node.itemGName}<br>`;
            sLastId = node.itemGId;
            sIdx += 2;
            sNgTracker = gCycle;
        } else {
            const isMatch = (node.itemId === sLastId);
            const isRR = (node.rarityId === 1 && node.poolSize > 1 && isMatch) || node.reRerollFlag;
            block += `通常: ${rarityNames[node.rarityId]} → ${isRR ? node.reRollItemName : node.itemName}<br>`;
            sLastId = isRR ? node.reRollItemId : node.itemId;
            sIdx += isRR ? 3 : 2;
            if (sNgTracker > 1) sNgTracker--;
        }
        singleRouteText.push(block);
        sRoll++;
    }
    return singleRouteText;
}

// =================================================================================
// 内部パス計算: 10連ルート (特殊ポインタ管理)
// =================================================================================

function calculateMultiRollRoute(Nodes, tableRows, initialNg, initialLastRollId, gacha, thresholds, SEED_LIST) {
    const multiRouteText = [];
    const gCycle = gacha.guaranteedCycle || 30;
    const uRate = gacha.uberGuaranteedFlag ? (gacha.rarityRates['3'] || 500) : 0;
    const lRate = gacha.legendGuaranteedFlag ? (gacha.rarityRates['4'] || 200) : 0;
    const gDiv = uRate + lRate;
    let tIdx = 1, tRoll = 1, tNgTracker = parseInt(initialNg, 10), tLastId = initialLastRollId;

    while (tIdx <= Nodes.length && tRoll <= tableRows) {
        const cycleHeadIdx = tIdx;
        const cycleHeadSeed = SEED_LIST[cycleHeadIdx];
        let cycleBlock = `<strong>【サイクル】</strong>先頭Seed: Seed[${cycleHeadIdx}]<br>`;
        
        let gIndex = -1;
        if (tNgTracker > 0 && tNgTracker <= 10) {
            gIndex = tNgTracker - 1;
        }

        let gRarityId = null;
        if (gIndex !== -1 && gDiv > 0) {
            const gRoll = cycleHeadSeed % gDiv;
            gRarityId = (gRoll < uRate) ? '3' : '4';
            tIdx++;
            // 確定枠レアリティ判定に1消費
        }

        for (let j = 0; j < 10; j++) {
            if (tRoll > tableRows || tIdx > Nodes.length) break;
            const node = Nodes[tIdx - 1];

            if (j === gIndex) {
                const poolG = gacha.rarityItems[gRarityId] || [];
                const itemIdG = poolG[node.seed1 % Math.max(1, poolG.length)];
                cycleBlock += `R${tRoll}[G]: ${getItemNameSafe(itemIdG)}<br>`;
                tLastId = itemIdG;
                tIdx += 1;
                // 確定枠スロットに1消費
                tNgTracker = gCycle;
            } else {
                const isMatch = (node.itemId === tLastId);
                const isRR = (node.rarityId === 1 && node.poolSize > 1 && isMatch) || node.reRerollFlag;
                cycleBlock += `R${tRoll}: ${isRR ? node.reRollItemName : node.itemName}<br>`;
                tLastId = isRR ? node.reRollItemId : node.itemId;
                tIdx += isRR ? 3 : 2;
                if (tNgTracker > 1) tNgTracker--;
            }
            tRoll++;
        }
        multiRouteText.push(cycleBlock);
    }
    return multiRouteText;
}

====================
FILE: logic-completed-highlight.js
====================
/**
 * 担当: ハイライトマップ（単発ルート・10連ルートの経路情報）の生成
 * 10連ガチャの特殊仕様（シード消費順序、確定枠の判定位置、トラック遷移）に対応
 */

function generateHighlightMap(Nodes, tableRows, initialNg, initialLastRollId, gCycle, gacha) {
    const map = new Map();
    const uFlag = gacha.uberGuaranteedFlag;
    const lFlag = gacha.legendGuaranteedFlag;
    const uRate = uFlag ? (gacha.rarityRates['3'] || 500) : 0;
    const lRate = lFlag ? (gacha.rarityRates['4'] || 200) : 0;
    const gDiv = uRate + lRate;
    const getAddr = (n) => getAddressStringGeneric(n, 2);

    // --- 1. 単発ルートのハイライト ---
    let sIdx = 1;
    let sLastId = initialLastRollId;
    let sNgTracker = parseInt(initialNg, 10);
    if (isNaN(sNgTracker)) sNgTracker = 0;

    for (let roll = 1; roll <= tableRows && sIdx <= Nodes.length; roll++) {
        const node = Nodes[sIdx - 1];
        if (!node) break;
        
        const isG = (sNgTracker === 1) && (uFlag || lFlag);
        let addr;

        if (isG) {
            addr = node.address + 'G';
            const existing = map.get(addr) || {};
            map.set(addr, { ...existing, single: true, singleRoll: roll });
            
            sIdx += 2;
            sNgTracker = gCycle;
            sLastId = node.itemGId;
        } else {
            addr = node.address;
            const isMatch = (node.itemId !== -1 && node.itemId === sLastId);
            const isRR = (node.rarityId === 1 && node.poolSize > 1 && isMatch) || node.reRerollFlag;
            
            const existing = map.get(addr) || {};
            map.set(addr, { ...existing, single: true, singleRoll: roll });
            
            sLastId = isRR ? node.reRollItemId : node.itemId;
            sIdx += isRR ? 3 : 2;
            
            if (sNgTracker > 1) sNgTracker--;
            else if (sNgTracker === 1) sNgTracker = gCycle;
        }
    }

    // --- 2. 10連ルートのハイライト ---
    let tIdx = 1;
    let tLastId = initialLastRollId;
    let tNgTracker = parseInt(initialNg, 10);
    if (isNaN(tNgTracker)) tNgTracker = 0;
    let tRollNum = 1;

    while (tIdx <= Nodes.length && tRollNum <= tableRows) {
        const cycleStartIdx = tIdx;
        let gRollInCycle = -1;

        if (tNgTracker > 0 && tNgTracker <= 10) {
            gRollInCycle = tNgTracker - 1;
        }
        
        let ptr = cycleStartIdx;

        // 確定枠がある場合、サイクル先頭の1SEEDをレアリティ判定に消費 (Seed[1])
        if (gRollInCycle !== -1 && gDiv > 0) {
            ptr++;
        }

        // 10連開始時のトラックを判定
        let currentTrack = getAddr(ptr).includes('A') ? 'A' : 'B';

        for (let j = 0; j < 10; j++) {
            const currentRollCount = tRollNum + j;
            if (currentRollCount > tableRows || ptr > Nodes.length) break;
            
            if (j === gRollInCycle) {
                // 確定枠の処理 (例: Seed[9])
                // 仕様: 確定枠は「スロット判定」に使用しているセル（現在のptr）をハイライト
                // ただし、トラックは確定枠直前のロールの反対側に配置される（住所計算）
                const node = Nodes[ptr - 1];
                const oppositeTrack = (currentTrack === 'A' ? 'B' : 'A');
                const addr = node.address.replace(/[AB]/, oppositeTrack) + 'G';
                
                const existing = map.get(addr) || {};
                map.set(addr, { 
                    ...existing, 
                    ten: true, 
                    tenRoll: currentRollCount,
                    tenIndex: ptr
                });

                ptr += 1; // 確定枠はスロット判定で1消費
                tNgTracker = gCycle;
                // 確定枠通過後、トラックを正式に反転
                currentTrack = oppositeTrack;
            } else {
                // 通常枠の処理
                // 仕様: レアリティ判定に使用しているセル（現在のptr）をハイライト
                const node = Nodes[ptr - 1];
                const addr = node.address.replace(/[AB]/, currentTrack);
                
                const isMatch = (node.itemId !== -1 && node.itemId === tLastId);
                const isRR = (node.rarityId === 1 && node.poolSize > 1 && isMatch) || node.reRerollFlag;
                
                const existing = map.get(addr) || {};
                map.set(addr, { 
                    ...existing, 
                    ten: true, 
                    tenRoll: currentRollCount,
                    t_reRoll: isRR,
                    tenIndex: ptr
                });

                tLastId = isRR ? node.reRollItemId : node.itemId;
                ptr += isRR ? 3 : 2;
                if (tNgTracker > 1) tNgTracker--;
            }
        }
        tIdx = ptr;
        tRollNum += 10;
    }

    return map;
}

====================
FILE: logic-completed-popup.js
====================
/**
 * 担当: ポップアップ（計算詳細）内の表示HTML生成
 * 仕様: テーブルの番地に基づいた静的な計算過程を表示
 */

function generateGachaInfoHeaderHtml(thresholds, gacha, isGuaranteedColumn) {
    const names = ["ノーマル", "レア", "激レア", "超激レア", "伝説レア"];
    let html = '<h4>ガチャ情報</h4><p style="font-size: 0.8rem; background: #eee; padding: 5px;">';
    if (isGuaranteedColumn && (gacha.uberGuaranteedFlag || gacha.legendGuaranteedFlag)) {
        let p = [];
        if (gacha.uberGuaranteedFlag) p.push(names[3]);
        if (gacha.legendGuaranteedFlag) p.push(names[4]);
        html += "確定枠対象: " + p.join(' / ');
    } else {
        Object.keys(thresholds).forEach(id => {
            html += `${names[id]}: ${thresholds[id]}${id < 4 ? ' / ' : ''}`;
        });
    }
    return html + '</p>';
}

/**
 * SEED情報表示の生成
 * 修正: 直前SEEDを削除し、ラベルを「最終SEED」に変更
 */
function generateSeedInfoHtml(node, isGuaranteedColumn, linkSeeds) {
    let html = `<h3>${node.address}${isGuaranteedColumn ? 'G' : ''} の詳細計算</h3><h4>SEED情報</h4><ul>`;
    html += `<li>対象SEED (S1): Index[${node.index}] : ${node.seed1}</li>`;
    
    const cmp = (calc, link, label, idx) => {
        if (!link) return `<li>${label}: 該当なし</li>`;
        const match = (calc.toString() === link.toString());
        const s = match ? '<span style="color:green;">(一致)</span>' : `<span style="color:red;">⚠️不一致: ${link}</span>`;
        return `<li>${label}: Index[${idx}] : ${calc} ${s}</li>`;
    };

    if (isGuaranteedColumn) {
        html += cmp(node.seed2, linkSeeds.avoid, "最終SEED(通常)", node.index + 1);
        html += cmp(node.seed3, linkSeeds.reroll, "最終SEED(再抽選)", node.index + 2);
    } else {
        html += cmp(node.seed2, linkSeeds.normal, "最終SEED(通常)", node.index + 1);
        html += cmp(node.seed3, linkSeeds.reroll, "最終SEED(再抽選)", node.index + 2);
    }
    return html + '</ul>';
}

function generateNodeCalculationDetailsHtml(node, gacha, thresholds, initialLastRollId, Nodes, linkSeeds, isGuar) {
    const names = ["ノーマル", "レア", "激レア", "超激レア", "伝説レア"];
    let html = '<div class="popup-details">';
    
    html += generateGachaInfoHeaderHtml(thresholds, gacha, isGuar);
    html += generateSeedInfoHtml(node, isGuar, linkSeeds);
    if (isGuar) {
        // AG/BG列（確定枠）の静的計算
        const uRate = gacha.uberGuaranteedFlag ?
            (gacha.rarityRates['3'] || 500) : 0;
        const lRate = gacha.legendGuaranteedFlag ? (gacha.rarityRates['4'] || 200) : 0;
        const gDiv = uRate + lRate;

        html += '<h4>確定枠計算 (通常)</h4>';
        if (gDiv > 0) {
            const gRoll = node.seed1 % gDiv;
            const rId = (gRoll < uRate) ? '3' : '4';
            const pool = (gacha.rarityItems[rId] || []);
            const slot = node.seed2 % Math.max(1, pool.length);
            
            html += `<p>Rarity: Seed[${node.index}] ${node.seed1} % ${gDiv} = ${gRoll} → ${names[rId]}</p>`;
            html += `<p>Slot: Seed[${node.index+1}] ${node.seed2} % ${pool.length} = ${slot} → ${getItemNameSafe(pool[slot])}</p>`;
        }

        if (node.reRollFlag || node.reRerollFlag) {
            html += '<h4>確定枠計算 (再抽選経由)</h4>';
            if (gDiv > 0) {
                const gRoll_RR = node.seed2 % gDiv;
                const rId_RR = (gRoll_RR < uRate) ? '3' : '4';
                const pool_RR = (gacha.rarityItems[rId_RR] || []);
                const slot_RR = node.seed3 % Math.max(1, pool_RR.length);
                
                html += `<p>Rarity: Seed[${node.index+1}] ${node.seed2} % ${gDiv} = ${gRoll_RR} → ${names[rId_RR]}</p>`;
                html += `<p>Slot: Seed[${node.index+2}] ${node.seed3} % ${pool_RR.length} = ${slot_RR} → ${getItemNameSafe(pool_RR[slot_RR])}</p>`;
            }
        }
    } else {
        // A/B列（通常枠）の静制計算
        html += '<h4>通常計算</h4>';
        html += `<p>Rarity: Seed[${node.index}] ${node.seed1} % 10000 = ${node.roll1} → ${names[node.rarityId]}</p>`;
        html += `<p>Slot: Seed[${node.index+1}] ${node.seed2} % ${node.poolSize} = ${node.slot} → ${node.itemName}</p>`;

        const prevN2 = (node.index >= 3) ?
            Nodes[node.index - 3] : null;
        const prevId2 = prevN2 ? prevN2.itemId : (initialLastRollId || -1);
        const match = (node.itemId !== -1 && node.itemId === prevId2);
        
        html += '<h4>被り判定</h4>';
        html += `<div style="font-size:0.8rem; border:1px solid #ddd; padding:8px; background:#fafafa;">`;
        html += `直前アイテム: ${getItemNameSafe(prevId2)}<br>`;
        html += `一致判定: <b>${match ? '一致' : '不一致'}</b><br>`;
        html += `再抽選実行: <b>${node.reRollFlag ? '実行' : 'なし'}</b>`;
        html += `</div>`;
        if (node.reRollFlag || node.reRerollFlag) {
            html += '<h4>再抽選詳細</h4>';
            html += `<p>Slot: Seed[${node.index+2}] ${node.seed3} % ${node.poolSize-1} = ${node.reRollSlot} → ${node.reRollItemName}</p>`;
        }
    }
    return html + '</div>';
}

====================
FILE: logic-completed-search.js
====================
// =================================================================================
// 最適ルート探索（ビームサーチ）
// =================================================================================

/**
 * 単発ガチャを1回シミュレートする
 */
function simulateSingleRoll(startIdx, lastId, rollNum, currentNg, gacha, Nodes) {
    const node = Nodes[startIdx - 1];
    if (!node) return null;

    const gCycle = gacha.guaranteedCycle || 30;
    // isGuar: あと1回で確定枠の時
    const isGuar = !isNaN(currentNg) && currentNg !== 'none' && currentNg > 0 && (gacha.uberGuaranteedFlag || gacha.legendGuaranteedFlag) && (currentNg <= 1);
    
    if (isGuar) {
        // 確定枠を消費する
        return { items: [{itemId: node.itemGId, rarity: itemMaster[node.itemGId]?.rarity || 0}], useSeeds: 2, nextLastId: node.itemGId, nextNg: gCycle };
    } else {
        // 通常ロール
        const isMatch = (node.itemId !== -1 && node.itemId === lastId);
        // レア被り再抽選判定
        const isRR = (node.rarityId === 1 && node.poolSize > 1 && isMatch) || node.reRerollFlag;
        let finalId = node.itemId;
        if (isRR && node.reRollItemId !== undefined) {
            finalId = node.reRollItemId;
        }
        const useSeeds = isRR ? 3 : 2;
        // 確定枠ではないので、カウンターを1減らす
        const nextNg = (isNaN(currentNg) || currentNg === 'none') ? 'none' : (currentNg - 1);
        return { items: [{itemId: finalId, rarity: itemMaster[finalId]?.rarity || 0}], useSeeds, nextLastId: finalId, nextNg };
    }
}


/**
 * 10連ガチャを1回シミュレートする
 * ユーザー指定の特殊なSeed消費ロジックを実装
 */
function simulateTenRoll(startIdx, lastId, rollNum, currentNg, gacha, Nodes) {
    const gCycle = gacha.guaranteedCycle || 30;

    // 1. 確定枠がこの10連に含まれるか、そのインデックス(0-9)を特定
    let guaranteedRollIndex = -1;
    // `currentNg` が 1-10 の間なら、この10連に確定枠が含まれる
    if (!isNaN(currentNg) && currentNg !== 'none' && currentNg > 0 && currentNg <= 10 && (gacha.uberGuaranteedFlag || gacha.legendGuaranteedFlag)) {
        guaranteedRollIndex = currentNg - 1;
    }

    // 2. 確定枠の「レアリティ」を最初のSeedから決定
    let guaranteedRarityId = null;
    let raritySeedConsumed = 0;
    if (guaranteedRollIndex !== -1) {
        const rarityNode = Nodes[startIdx - 1];
        if (!rarityNode) return null; // 探索不能
        guaranteedRarityId = rarityNode.rarityGId;
        raritySeedConsumed = 1; // レアリティ判定で1消費
    }

    // 3. 各ロールで消費するSeed数と開始インデックスを事前計算
    const rollInfos = [];
    let currentSeedIdx = startIdx + raritySeedConsumed;
    let tempLastId = lastId;

    // まず通常ロール9回分(または10回分)のSeed消費を計算
    for (let i = 0; i < 10; i++) {
        if (i === guaranteedRollIndex) {
            rollInfos.push(null); // 確定枠は後で計算
            continue;
        }
        const node = Nodes[currentSeedIdx - 1];
        if (!node) return null;
        
        const isMatch = (node.itemId !== -1 && node.itemId === tempLastId);
        const isRR = (node.rarityId === 1 && node.poolSize > 1 && isMatch) || node.reRerollFlag;
        const useSeeds = isRR ? 3 : 2;

        let finalId = node.itemId;
        if (isRR && node.reRollItemId !== undefined) {
            finalId = node.reRollItemId;
        }
        
        rollInfos.push({ type: 'normal', seed: currentSeedIdx, use: useSeeds, itemId: finalId, rarity: itemMaster[finalId]?.rarity || 0 });
        currentSeedIdx += useSeeds;
        tempLastId = finalId;
    }

    // 4. 最後に確定枠の「スロット」用のSeedを割り当てる
    if (guaranteedRollIndex !== -1) {
        const slotNode = Nodes[currentSeedIdx - 1];
        if (!slotNode) return null;
        
        const poolG = gacha.rarityItems[guaranteedRarityId] || [];
        const slotG = slotNode.seed1 % Math.max(1, poolG.length);
        const itemIdG = poolG[slotG];

        rollInfos[guaranteedRollIndex] = { type: 'guaranteed', seed: currentSeedIdx, use: 1, itemId: itemIdG, rarity: itemMaster[itemIdG]?.rarity || 0 };
        currentSeedIdx += 1;
    }

    // 5. 結果を組み立て
    const items = [];
    let nextLastId = lastId;
    
    for (let i = 0; i < 10; i++) {
        const roll = rollInfos[i];
        items.push({ itemId: roll.itemId, rarity: roll.rarity });
        nextLastId = roll.itemId;
    }
    
    // 10連後の最終的な nextNg を計算
    let nextNg;
    if (guaranteedRollIndex !== -1) {
        // 確定枠を消費したので、gCycleにリセットされる
        nextNg = gCycle;
    } else {
        // 確定枠を消費していないので、10回分カウンターを減らす
        nextNg = (isNaN(currentNg) || currentNg === 'none') ? 'none' : (currentNg - 10);
    }

    const totalSeedsConsumed = currentSeedIdx - startIdx;
    return { items, useSeeds: totalSeedsConsumed, nextLastId, nextNg };
}


/**
 * 探索の最終結果から最良のものを選択する
 * totalTicketsを使い切った状態から優先的に探す
 */
function findBestBeamSearchResult(dp, totalTickets, calculateScore) {
    // 指定されたチケット数を使い切った状態から逆順に探す
    for (let t = totalTickets; t >= 1; t--) {
        const statesInTier = dp[t];
        if (!statesInTier || statesInTier.size === 0) {
            continue; // このチケット数の状態がなければ次へ
        }

        // このチケット数で有効なルートが見つかったので、この中からベストを探して返す
        let bestStateInTier = null;
        let bestScoreInTier = -1;

        for (const state of statesInTier.values()) {
            const score = calculateScore(state);
            if (score > bestScoreInTier) {
                bestScoreInTier = score;
                bestStateInTier = state;
            }
        }
        return bestStateInTier;
    }
    return null; // 有効なルートが一つも見つからなかった場合
}


function runGachaSearch(Nodes, initialLastRollId, totalTickets, gacha, thresholds, initialNg, targetLayers = []) {
    // 渡された targetLayers が実際に有効なターゲットを含んでいるかチェック
    const hasValidLayers = targetLayers && targetLayers.some(layer => Array.isArray(layer) && layer.length > 0);
    const effectiveLayers = hasValidLayers ? targetLayers : [];

    // dp[t] はチケットを t 枚消費した時点での状態を保持するMap
    const dp = new Array(totalTickets + 1).fill(null).map(() => new Map());

    // 初期状態 (チケット0枚)
    dp[0].set(`1_${initialLastRollId}_${initialNg}`, {
        nodeIdx: 1,
        lastId: initialLastRollId,
        currentNg: initialNg,
        layerCounts: new Array(effectiveLayers.length).fill(0),
        ubers: 0,
        legends: 0,
        path: [],
        rollCount: 1,
        tickets: 0
    });

    /**
     * 状態を評価するスコア関数
     * @param {object} state 状態
     * @returns {number} スコア
     */
    const calculateScore = (state) => {
        let score = 0;
        // 有効なターゲットレイヤーがある場合のみ、そのスコアを加算
        if (hasValidLayers) {
            for (let i = 0; i < state.layerCounts.length; i++) {
                score += state.layerCounts[i] * Math.pow(50, effectiveLayers.length - i);
            }
        }
        // 超激レア・伝説レアにも高い価値を与える
        score += state.ubers * 100;
        score += state.legends * 5000;

        return score;
    };

    for (let t = 0; t < totalTickets; t++) {
        if (!dp[t] || dp[t].size === 0) continue;

        // ビームサーチの絞り込みをせず、全状態を探索する
        const states = Array.from(dp[t].values());

        for (const state of states) {
            // --- 単発ガチャ (Single Roll) ---
            if (t + 1 <= totalTickets) {
                const resS = simulateSingleRoll(state.nodeIdx, state.lastId, state.rollCount, state.currentNg, gacha, Nodes);
                if (resS) {
                    const newLayerCounts = [...state.layerCounts];
                    // 有効なターゲットがある場合のみカウント
                    if (hasValidLayers) {
                        const item = resS.items[0];
                        effectiveLayers.forEach((ids, idx) => { if (ids.includes(item.itemId)) newLayerCounts[idx]++; });
                    }
                    
                    const nextState = {
                        nodeIdx: state.nodeIdx + resS.useSeeds,
                        lastId: resS.nextLastId,
                        currentNg: resS.nextNg,
                        layerCounts: newLayerCounts,
                        ubers: state.ubers + (resS.items[0].rarity === 3 ? 1 : 0),
                        legends: state.legends + (resS.items[0].rarity === 4 ? 1 : 0),
                        path: state.path.concat({ type: 'single', item: getItemNameSafe(resS.items[0].itemId), addr: Nodes[state.nodeIdx - 1]?.address || '?' }),
                        rollCount: state.rollCount + 1,
                        tickets: t + 1
                    };
                    
                    const key = `${nextState.nodeIdx}_${nextState.lastId}_${nextState.currentNg}`;
                    const existing = dp[t + 1].get(key);
                    if (!existing || calculateScore(existing) < calculateScore(nextState)) {
                        dp[t + 1].set(key, nextState);
                    }
                }
            }

            // --- 10連ガチャ (10-Roll) ---
            if (t + 10 <= totalTickets) {
                const resTen = simulateTenRoll(state.nodeIdx, state.lastId, state.rollCount, state.currentNg, gacha, Nodes);
                if (resTen) {
                    const addLayer = new Array(effectiveLayers.length).fill(0);
                    let ubers = 0;
                    let legends = 0;
                    let itemNames = [];
                    
                    resTen.items.forEach(item => {
                        // 有効なターゲットがある場合のみカウント
                        if (hasValidLayers) {
                            effectiveLayers.forEach((ids, idx) => { if (ids.includes(item.itemId)) addLayer[idx]++; });
                        }
                        if (item.rarity === 3) ubers++;
                        if (item.rarity === 4) legends++;
                        itemNames.push(getItemNameSafe(item.itemId));
                    });

                    const nextStateTen = {
                        nodeIdx: state.nodeIdx + resTen.useSeeds,
                        lastId: resTen.nextLastId,
                        currentNg: resTen.nextNg,
                        layerCounts: state.layerCounts.map((c, idx) => c + addLayer[idx]),
                        ubers: state.ubers + ubers,
                        legends: state.legends + legends,
                        path: state.path.concat({ type: 'ten', items: itemNames, addr: Nodes[state.nodeIdx - 1]?.address || '?' }),
                        rollCount: state.rollCount + 10,
                        tickets: t + 10
                    };

                    const keyTen = `${nextStateTen.nodeIdx}_${nextStateTen.lastId}_${nextStateTen.currentNg}`;
                    const existingTen = dp[t + 10].get(keyTen);
                    if (!existingTen || calculateScore(existingTen) < calculateScore(nextStateTen)) {
                        dp[t + 10].set(keyTen, nextStateTen);
                    }
                }
            }
        }
    }
    
    // 最終的に最もスコアの高い状態を見つける
    return findBestBeamSearchResult(dp, totalTickets, calculateScore);
}

====================
FILE: logic-completed.js
====================
/**
 * 担当: 「コンプ済み」ビューにおける全アイテムの計算ロジック
 * 構成:
 * 1. メイン計算関数 `calculateCompletedData`
 *    - `initializeNodes`: 全ノードの基本情報を算出
 *    - `calculateRerolls`: 再抽選・再々抽選の判定
 *    - `calculateSingleRollRoute`: 単発ルートのテキストを生成
 *    - `calculateMultiRollRoute`: 10連ルートのテキストを生成
 * 2. ポップアップHTML生成 `generateNodeCalculationDetailsHtml`
 *    - 各種ヘルパー関数
 * 3. 最適ルート探索 `runGachaBeamSearchCorrected`
 *    - `simulateSingleRoll`: 1回分のガチャをシミュレート
 *    - その他ヘルパー関数
 * 4. ハイライト情報生成 `generateHighlightMap`
 */

// =================================================================================
// メイン計算関数
// =================================================================================

function calculateCompletedData(initialSeed, gacha, tableRows, thresholds, initialLastRollId, initialNg) {
    const maxSeedsNeeded = Math.max(tableRows * 20, 20000);
    const SEED_LIST = generateSeedList(initialSeed, maxSeedsNeeded);
    
    const maxNodeIndex = Math.max(tableRows * 6, 6000);
    const Nodes = initializeNodes(SEED_LIST, maxNodeIndex, gacha, thresholds);
    
    calculateRerolls(Nodes, initialLastRollId, gacha);

    const singleRouteText = calculateSingleRollRoute(Nodes, tableRows, initialNg, initialLastRollId, gacha, thresholds, SEED_LIST);
    const multiRouteText = calculateMultiRollRoute(Nodes, tableRows, initialNg, initialLastRollId, gacha, thresholds, SEED_LIST);
    const highlightInfo = generateHighlightMap(Nodes, tableRows, initialNg, initialLastRollId, gacha.guaranteedCycle || 30, gacha);

    return { Nodes, singleRouteText, multiRouteText, highlightInfo, maxNodeIndex, SEED_LIST };
}

====================
FILE: logic-uncompleted-sim.js
====================
/**
 * 担当: 「未コンプ」ビュー用の10連ガチャシミュレーションおよび期待値計算ロジック
 * 依存関係: logic-common.js, utils.js
 */

// =================================================================================
// 1. 通常枠の計算パーツ
// =================================================================================

/**
 * 通常枠（レアリティ判定、スロット、被り再抽選）の計算を行う
 */
function calculateNormalRollResult(fullSeedArray, currentIndex, thresholds, lastItemId) {
    const sRarity = fullSeedArray[currentIndex];
    const sSlot = fullSeedArray[currentIndex + 1];
    
    if (sRarity === undefined || sSlot === undefined) return null;

    const rarityInfo = getRarityFromRoll(sRarity % 10000, thresholds);
    const pool = gachaMaster[window.activeGachaId]?.rarityItems[rarityInfo.id] || [];
    const poolSize = pool.length > 0 ? pool.length : 1;
    const itemId = (pool[sSlot % poolSize] !== undefined) ? pool[sSlot % poolSize] : -1;
    const itemName = getItemNameSafe(itemId);

    let finalId = itemId;
    let finalName = itemName;
    let consumed = 2;
    let isReroll = false;
    let preRerollName = null;
    let logStr = `S${currentIndex + 1}→${rarityInfo.name}, S${currentIndex + 2}→${itemName}`;

    // レア(ID:1)の被り再抽選
    if (rarityInfo.id === 1 && itemId !== -1 && itemId === lastItemId) {
        const sReRoll = fullSeedArray[currentIndex + 2];
        if (sReRoll !== undefined) {
            const rePool = pool.filter(id => id !== itemId);
            if (rePool.length > 0) {
                isReroll = true;
                preRerollName = itemName;
                finalId = rePool[sReRoll % rePool.length];
                finalName = getItemNameSafe(finalId);
                logStr += ` [Dupe], S${currentIndex + 3}→${finalName}`;
                consumed = 3;
            }
        }
    }
    return { finalId, finalName, consumed, isReroll, preRerollName, logStr };
}

// =================================================================================
// 2. 10連シミュレーション
// =================================================================================

/**
 * 10連スロット用シード(S1~S10)による目玉判定を事前に行う
 */
function getFeaturedSeedResults(fullSeedArray, gacha, ngVal, isGuaranteedActive) {
    const featuredResults = [];
    const featuredLog = [];
    let featuredSeedPtr = 0;

    for (let i = 1; i <= 10; i++) {
        const isGuaranteedRoll = isGuaranteedActive && i === ngVal && ngVal <= 10;
        if (isGuaranteedRoll) {
            featuredLog.push(`S${i} (Skipped): Guaranteed Roll (${ngVal})`);
            continue;
        }
        
        const sVal = fullSeedArray[featuredSeedPtr];
        if (sVal === undefined) break;

        const isFeatured = (sVal % 10000) < gacha.featuredItemRate;
        featuredResults.push({ index: i, isFeatured, seedIndex: featuredSeedPtr + 1 });
        featuredLog.push(`S${featuredSeedPtr + 1} (${sVal}) % 10000 = ${sVal % 10000} < ${gacha.featuredItemRate} → ${isFeatured}`);
        featuredSeedPtr++;
    }
    return { featuredResults, featuredLog, featuredSeedPtr };
}

/**
 * 10連ガチャ1回分の計算を行う
 */
function calculateTenPullDetailedLogic(fullSeedArray, gacha, thresholds, ngVal, initialLastRollId, getAddressFunc) {
    const isGuaranteedActive = !isNaN(ngVal);
    const { featuredResults, featuredLog, featuredSeedPtr } = getFeaturedSeedResults(fullSeedArray, gacha, ngVal, isGuaranteedActive);
    
    let currentSeedIndex = featuredSeedPtr;
    let lastItemId = initialLastRollId || -1;
    let featuredCountInCycle = 0;
    let featuredIdxPtr = 0;
    const results = [];
    const processLog = [];

    for (let r = 1; r <= 10; r++) {
        let label = `Roll${r}`;
        if (isGuaranteedActive && r === ngVal) {
            label += `(G${r})`;
            processLog.push(ngVal <= 10 ? `${label} (Skipped): Guaranteed Roll` : `${label}: Featured Item by guaranteed`);
            results.push({ label, name: '目玉(確定)', isGuaranteed: true, isFeatured: false, isReroll: false, preRerollName: null });
            featuredCountInCycle++; continue;
        }

        const fRes = featuredResults[featuredIdxPtr++];
        if (!fRes) break;

        if (fRes.isFeatured) {
            results.push({ label, name: '目玉', isGuaranteed: false, isFeatured: true, isReroll: false, preRerollName: null });
            processLog.push(`${label}: Featured (by S${fRes.seedIndex})`);
            lastItemId = -2; featuredCountInCycle++;
        } else {
            const roll = calculateNormalRollResult(fullSeedArray, currentSeedIndex, thresholds, lastItemId);
            if (!roll) break;
            processLog.push(`${label}: ${roll.logStr}`);
            results.push({ label, name: roll.finalName, isGuaranteed: false, isFeatured: false, isReroll: roll.isReroll, preRerollName: roll.preRerollName });
            currentSeedIndex += roll.consumed; lastItemId = roll.finalId;
        }
    }

    return {
        guaranteedStatus: isGuaranteedActive && ngVal > 0 ? (ngVal <= 10 ? `next G(${ngVal}) <= 10` : `next G(${ngVal}) >= 11`) : 'none',
        featuredLog, processLog, results, featuredCountInCycle,
        transition: { consumedCount: currentSeedIndex, nextIndex: currentSeedIndex + 1, nextAddress: getAddressFunc(currentSeedIndex + 1), nextSeed: fullSeedArray[currentSeedIndex], lastItemId, nextNgVal: ngVal }
    };
}

// =================================================================================
// 3. 複数サイクル・期待値計算
// =================================================================================

/**
 * nサイクル分の10連計算を実行
 */
function calculateTenPullsOverCycles(initialFullSeedArray, gacha, thresholds, initialNgVal, initialLastRollId, nCycles = 10) {
    const getAddress = (n) => getAddressStringGeneric(n, 3);
    const guaranteedCycle = gacha.guaranteedCycle || 30;
    let currentSeedArray = [...initialFullSeedArray];
    let currentLastRollId = initialLastRollId;
    let currentNgVal = initialNgVal;
    const cycleResults = [];

    for (let c = 1; c <= nCycles; c++) {
        if (currentSeedArray.length < 1) break;
        const res = calculateTenPullDetailedLogic(currentSeedArray.slice(0, 40), gacha, thresholds, currentNgVal, currentLastRollId, getAddress);
        cycleResults.push({ cycle: c, ...res, startNgVal: currentNgVal, startLastRollId: currentLastRollId });

        currentSeedArray = currentSeedArray.slice(res.transition.consumedCount);
        currentLastRollId = res.transition.lastItemId;
        if (!isNaN(currentNgVal)) {
            currentNgVal = res.transition.nextNgVal - 10;
            if (currentNgVal <= 0) currentNgVal = guaranteedCycle + currentNgVal;
        }
    }
    return cycleResults;
}

/**
 * 単発Nロール後の内部状態（シード位置、NG値、直前ID）を算出
 */
function simulateSingleRollsAndGetState(n, seedArray, initialNg, initialLastRoll, gacha, thresholds) {
    const guaranteedCycle = gacha.guaranteedCycle || 30;
    let currentSeedIndex = 0;
    let currentNg = !isNaN(initialNg) && initialNg > 0 ? initialNg : guaranteedCycle;
    let lastItemId = initialLastRoll || -1;

    for (let r = 1; r <= n; r++) {
        if (currentSeedIndex >= seedArray.length) break;
        const isFeatured = (seedArray[currentSeedIndex] % 10000) < gacha.featuredItemRate;
        const isGuaranteedRoll = (currentNg === 1);

        if (isGuaranteedRoll || isFeatured) {
            currentSeedIndex += 1;
            currentNg = isGuaranteedRoll ? guaranteedCycle : (currentNg - 1 || guaranteedCycle);
            lastItemId = -2;
        } else {
            const roll = calculateNormalRollResult(seedArray, currentSeedIndex, thresholds, lastItemId);
            if (!roll) break;
            currentSeedIndex += roll.consumed;
            currentNg = (currentNg - 1 <= 0) ? guaranteedCycle : currentNg - 1;
            lastItemId = roll.finalId;
        }
    }
    return { nextSeedIndex: currentSeedIndex, nextNg: currentNg, nextLastRollId: lastItemId };
}

/**
 * 期待値の計算
 */
function calculateExpectedFeaturedCounts(initialFullSeedArray, gacha, thresholds, nRollsArray, initialNgVal, initialLastRollId) {
    const results = {};
    for (const n of nRollsArray) {
        if (n < 0) continue;
        const state = simulateSingleRollsAndGetState(n, initialFullSeedArray, initialNgVal, initialLastRollId, gacha, thresholds);
        const tenPullSeed = initialFullSeedArray.slice(state.nextSeedIndex, state.nextSeedIndex + 40);
        if (tenPullSeed.length < 9) { results[n] = 0; continue; }
        
        const sim = calculateTenPullDetailedLogic(tenPullSeed, gacha, thresholds, state.nextNg, state.nextLastRollId, (addr) => `S${state.nextSeedIndex + addr}`);
        results[n] = sim.featuredCountInCycle;
    }
    return results;
}

====================
FILE: logic-uncompleted.js
====================
/**
 * 担当: 「未コンプ」ビューにおけるメインテーブル用のノード計算
 * 依存関係: logic-common.js, logic-uncompleted-sim.js
 */

/**
 * 未コンプ（分割）ビュー用のデータを計算する関数
 */
function calculateUncompletedData(initialSeed, gacha, tableRows, thresholds, initialLastRollId, params) {
    // 1. シード生成
    const maxSeedsNeeded = tableRows * 10 + 1000; 
    const SEED = generateSeedList(initialSeed, maxSeedsNeeded);
    const getAddress = (n) => getAddressStringGeneric(n, 3);
    
    // 2. 全ノード計算 (メインテーブル用)
    const Nodes = [];
    const maxNodes = tableRows * 3 + 20; 
    const highlightInfo = new Map(); 

    const ngVal = parseInt(params.get('ng'), 10);
    const initialFs = parseInt(params.get('fs'), 10) || 0; 
    const guaranteedCycle = gacha.guaranteedCycle || 30;
    
    for (let i = 1; i <= maxNodes; i++) {
        const seedStartIdx = i; 
        const s1 = SEED[seedStartIdx];     
        const s2 = SEED[seedStartIdx + 1]; 
        const s3 = SEED[seedStartIdx + 2]; 
        const s4 = SEED[seedStartIdx + 3]; 
        let prevSeedVal = SEED[seedStartIdx - 1];

        const node = {
            index: i, address: getAddress(i),
            seed1: s1, seed2: s2, seed3: s3, seed4: s4,
            prevSeed1: prevSeedVal,
            isFeatured: (s1 % 10000) < gacha.featuredItemRate,
            singleRoll: null, singleUseSeeds: null, singleNextAddr: null,
            guaranteedNextNgVal: ngVal,
            isFeaturedUsedFs: false,
        };

        node.featuredNextAddress = getAddress(i + 1); 
        node.normalNextAddress = getAddress(i + 3);   
        node.reRollNextAddress = getAddress(i + 4);   

        node.rarity = getRarityFromRoll(s2 % 10000, thresholds);
        node.rarityId = node.rarity.id;
        node.rarityName = node.rarity.name; 
        
        // レアリティ範囲表示用
        let lowerBound = 0, upperBound = 10000;
        const rarityIds = Object.keys(thresholds).map(Number).sort((a, b) => a - b);
        for(const id of rarityIds) {
            if (id < node.rarityId) lowerBound = thresholds[id];
            if (id === node.rarityId) { upperBound = thresholds[id]; break; }
        }
        node.rarityRateRangeDisplay = `${lowerBound}<=${s2 % 10000}<${upperBound}`;
        
        const pool = gacha.rarityItems[node.rarityId] || [];
        node.poolSize = pool.length;
        if (pool.length > 0) {
            node.slot = s3 % pool.length;
            node.itemId = pool[node.slot];
            node.itemName = getItemNameSafe(node.itemId);
        } else {
            node.slot = 0; node.itemId = -1; node.itemName = '---';
        }
        
        const isRare = (node.rarityId === 1);
        if (isRare && pool.length > 1) {
            const reRollPool = pool.filter(id => id !== node.itemId);
            if (reRollPool.length > 0) {
                node.reRollSlot = s4 % reRollPool.length;
                node.reRollItemId = reRollPool[node.reRollSlot];
                node.reRollItemName = getItemNameSafe(node.reRollItemId);
            } else { node.reRollItemId = -1; node.reRollItemName = '---'; }
        } else { node.reRollItemId = -1; node.reRollItemName = '---'; }

        // Dupe判定用
        let compareId3Node = -1, compareId4Node = -1;
        let compareName3Node = '---', compareName4Node = '---';
        
        if (i <= 1) { 
            compareId3Node = initialLastRollId || -1;
            compareName3Node = getItemNameSafe(initialLastRollId || -1);
        } else {
            const pNode3 = (i > 3) ? Nodes[i-4] : null; 
            if (pNode3 && pNode3.singleUseSeeds === 3) {
                 compareId3Node = pNode3.itemId; compareName3Node = pNode3.itemName;
            } else if (i <= 3) {
                compareId3Node = initialLastRollId || -1; compareName3Node = getItemNameSafe(initialLastRollId || -1);
            }
            const pNode4 = (i > 4) ? Nodes[i-5] : null;
            if (pNode4 && pNode4.singleUseSeeds === 4 && pNode4.reRollItemId !== -1) {
                 compareId4Node = pNode4.reRollItemId; compareName4Node = pNode4.reRollItemName;
            }
        }
        
        const currentId = node.itemId;
        const isDupe3 = (currentId !== -1 && currentId === compareId3Node);
        const isDupe4 = (compareId4Node !== -1 && currentId === compareId4Node); 
        node.isDupe = (node.rarityId === 1 && (isDupe3 || isDupe4)); 

        if (node.rarityId === 1) {
            const id3 = compareId3Node !== -1 ? compareName3Node : '-';
            const id4 = compareId4Node !== -1 ? compareName4Node : '';
            node.dupeCompareTargets = `${id3}${id4 ? '/' + id4 : ''}`; 
        } else { node.dupeCompareTargets = node.rarityName; }

        Nodes.push(node);
    }
    
    // 3. 単発ルート計算
    let sIdx = 1; 
    let sLastActualItemId = initialLastRollId || -1; 
    let sCurrentFs = initialFs;
    const singleRoutePath = new Map();
    const hasGuaranteed = !isNaN(ngVal);
    let currentNg = hasGuaranteed ? ngVal : -1;

    for (let roll = 1; roll <= tableRows; roll++) {
        if (sIdx > maxNodes) break;
        const node = Nodes[sIdx - 1];
        if (!node) break;
        
        const isGuaranteedRoll = hasGuaranteed && (currentNg === 1); 
        node.singleCompareItemName = getItemNameSafe(sLastActualItemId);
        node.singleCompareItemId = sLastActualItemId; 

            let usedSeeds = 0;
            let finalId = -1;
            
            if (node.isFeatured) {
                usedSeeds = 1; finalId = -2; 
                node.singleRoll = roll;
                node.singleUseSeeds = usedSeeds;
                node.singleNextAddr = node.featuredNextAddress; 
                if (sCurrentFs > 0) { sCurrentFs -= 1; node.isFeaturedUsedFs = true; }
            } else {
                const poolSize = gacha.rarityItems[1] ? gacha.rarityItems[1].length : 0;
                const currentId = Number(node.itemId);
                const lastId = Number(sLastActualItemId);
                const isMatch = (currentId !== -1 && lastId !== -1 && currentId === lastId);
                const isReroll = (node.rarityId === 1) && isMatch && poolSize > 1; 
                
                finalId = isReroll ? node.reRollItemId : node.itemId;
                usedSeeds = isReroll ? 4 : 3;
                
                node.singleIsReroll = isReroll; 
                node.singleRoll = roll;
                node.singleUseSeeds = usedSeeds;
                node.singleNextAddr = isReroll ? node.reRollNextAddress : node.normalNextAddress; 
            }
            sLastActualItemId = finalId; 
            if (hasGuaranteed) {
                currentNg = currentNg - 1;
                if (currentNg <= 0) currentNg = guaranteedCycle;
            }
        if (isGuaranteedRoll) {
            node.singleRoll = `${roll}g`;
            //node.singleUseSeeds = 0; 
            //node.singleNextAddr = node.featuredNextAddress;
            //node.singleIsReroll = false; 
            node.isGuaranteedRoll = true; // フラグ
            currentNg = guaranteedCycle; 
            sLastActualItemId = -2; 
        }
        singleRoutePath.set(sIdx, roll);
        sIdx = sIdx + (node.singleUseSeeds === 0 ? 0 : node.singleUseSeeds || 3); 
    }

    // 4. Highlight Info 生成 (単発ルート)
    sIdx = 1; 
    for (let roll = 1; roll <= tableRows; roll++) {
        if (sIdx > maxNodes) break;
        const node = Nodes[sIdx - 1];
        if (!node || node.singleRoll === null) break;
        const addressKey = node.address;
        
        const info = highlightInfo.get(addressKey) || {};
        info.single = true; info.singleRoll = roll; 

        if (node.singleRoll.toString().endsWith('g')) {
             info.s_guaranteed = true;
        } else if (node.isFeatured) {
             info.s_featured = true; info.s_reRoll = false;
        } else if (node.rarityId !== 1) { 
             info.s_featured = false; info.s_reRoll = false; 
             info.s_normalName = node.rarityName; 
        } else {
             info.s_featured = false;
             info.s_reRoll = node.singleIsReroll; 
             info.s_currentId = node.itemId;
             if (info.s_reRoll) {
                 info.s_normalName = node.itemName; 
                 info.s_reRollName = node.reRollItemName;
             }
        }
        highlightInfo.set(addressKey, info);
        sIdx += node.singleUseSeeds || 3; 
    }
    
    // 5. Simロジック委譲: 10連サイクル計算 & 期待値計算
    const tenPullCyclesData = calculateTenPullsOverCycles(SEED, gacha, thresholds, ngVal, initialLastRollId, 10);
    const nRollsArray = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    const expectedFeaturedCounts = calculateExpectedFeaturedCounts(SEED, gacha, thresholds, nRollsArray, ngVal, initialLastRollId);

    return { Nodes, highlightInfo, maxNodes, singleRoutePath, tenPullCyclesData, expectedFeaturedCounts };
}

====================
FILE: main.js
====================
/**
 * 担当: アプリケーションの起動、URLパラメータ管理、DOMイベントリスナーの制御
 */

// --- グローバル変数 ---
const DEFAULT_PARAMS = {
    gacha: '45',
    seed: '12345',
    ng: 'none',
    fs: 'none',
    lr: null,
    comp: false,
    tx: false,
    roll: 100,
    displaySeed: '0',
    displaySim: '0' 
};

let currentHighlightMode = 'all'; 
let activeGachaId;
let forceRerollMode = false;

window.activeGachaId = activeGachaId;
window.forceRerollMode = forceRerollMode;

/**
 * シミュレーション実行および表示のメインディスパッチャー
 */
function runSimulationAndDisplay(options = {}) {
    const { hideSeedInput = false, uiOverrides = {} } = options;
    const params = new URLSearchParams(window.location.search);
    
    // 最新のガチャIDを取得
    const gachaIds = Object.keys(gachaMaster).map(Number);
    const latestGachaId = Math.max(...gachaIds).toString();

    // 現在のパラメータを取得、未設定ならデフォルトを適用
    const p = {};
    ['gacha', 'seed', 'ng', 'fs', 'lr', 'comp', 'tx', 'roll', 'displaySeed', 'displaySim'].forEach(k => {
        p[k] = params.get(k);
    });

    if (!p.gacha || !gachaMaster[p.gacha]) p.gacha = latestGachaId;
    if (!p.seed) p.seed = DEFAULT_PARAMS.seed;
    if (!p.roll) p.roll = DEFAULT_PARAMS.roll;
    if (!p.ng) p.ng = DEFAULT_PARAMS.ng;
    if (!p.displaySeed) p.displaySeed = DEFAULT_PARAMS.displaySeed;
    if (!p.displaySim) p.displaySim = DEFAULT_PARAMS.displaySim;

    // UI操作による上書き設定
    if (uiOverrides.seed !== undefined) p.seed = uiOverrides.seed;
    if (uiOverrides.guaranteedRolls !== undefined) p.ng = uiOverrides.guaranteedRolls;
    if (uiOverrides.featuredStock !== undefined) p.fs = uiOverrides.featuredStock;
    if (uiOverrides.isComplete !== undefined) p.comp = uiOverrides.isComplete ? 'true' : 'false';
    if (uiOverrides.displaySeed !== undefined) p.displaySeed = uiOverrides.displaySeed;
    if (uiOverrides.displaySim !== undefined) p.displaySim = uiOverrides.displaySim;
    
    activeGachaId = p.gacha;
    window.activeGachaId = activeGachaId;
    const gacha = gachaMaster[p.gacha];
    
    // シミュレーション表示設定の反映
    const simContainer = document.getElementById('sim-ui-container');
    const toggleSimBtn = document.getElementById('toggleSimBtn');
    
    if (p.displaySim === '1') {
        simContainer.style.display = 'block';
        toggleSimBtn.textContent = 'シミュレーションを非表示';
        // UIコンテナの初期化とターゲット情報の更新
        if (typeof initializeSimulationView === 'function') {
            initializeSimulationView(gacha);
        }
    } else {
        simContainer.style.display = 'none';
        toggleSimBtn.textContent = 'シミュレーションを表示';
    }

    // 入力フォームへの反映
    document.getElementById('seedInput').value = p.seed;
    const isComplete = (p.comp === 'true');
    document.getElementById('featuredCompleteCheckbox').checked = isComplete;
    
    // ガチャ設定に応じた目玉・確定枠の表示制御
    if (gacha.featuredItemStock === 0) {
        document.getElementById('featuredCompleteCheckbox').checked = true;
        document.getElementById('featuredCompleteCheckbox').parentElement.classList.add('hidden-control');
    } else {
        document.getElementById('featuredCompleteCheckbox').parentElement.classList.remove('hidden-control');
    }
    
    const isComp = document.getElementById('featuredCompleteCheckbox').checked;
    const stockControl = document.getElementById('stockControl');
    const guaranteedControl = document.getElementById('guaranteedControl');
    const legendDisplay = document.getElementById('legendDisplay');
    const legendCommon = document.getElementById('legendCommon');

    populateFeaturedStockInput(p.gacha, p.fs);

    if (isComp) {
        stockControl.classList.add('hidden-control');
        if (gacha.uberGuaranteedFlag || gacha.legendGuaranteedFlag) {
            guaranteedControl.classList.remove('hidden-control');
            legendDisplay.classList.remove('hidden-control');
            populateGuaranteedRolls(10, p.ng);
        } else {
            guaranteedControl.classList.add('hidden-control');
            legendDisplay.classList.add('hidden-control');
        }
        legendCommon.style.display = 'inline-block';
    } else {
        stockControl.classList.remove('hidden-control');
        guaranteedControl.classList.remove('hidden-control');
        legendDisplay.classList.remove('hidden-control');
        populateGuaranteedRolls(gacha.guaranteedCycle || 30, p.ng);
        legendCommon.style.display = 'none';
    }

    // 直前アイテム表示
    const lastRollDisplay = document.getElementById('lastRollDisplay');
    if (p.lr && itemMaster[p.lr]) {
        lastRollDisplay.textContent = `LastRoll: ${itemMaster[p.lr].name}`;
    } else {
        lastRollDisplay.textContent = '';
    }

    // SEED表示トグルボタンのテキスト更新
    const toggleSeedBtn = document.getElementById('toggleSeedBtn');
    if (p.displaySeed === '1') {
        toggleSeedBtn.textContent = 'SEEDを非表示';
    } else {
        toggleSeedBtn.textContent = 'SEEDを表示';
    }

    // ブラウザのURL履歴を更新
    const newParams = {
        gacha: p.gacha, seed: p.seed, ng: p.ng, fs: p.fs, lr: p.lr,
        comp: isComp ? 'true' : 'false',
        tx: (p.tx === '1' || (!hideSeedInput && !document.getElementById('seedRow').classList.contains('hidden-control'))) ? '1' : '0',
        roll: p.roll, displaySeed: p.displaySeed, displaySim: p.displaySim
    };
    const newQuery = generateUrlQuery(newParams);
    window.history.replaceState({ path: newQuery }, '', `${window.location.pathname}${newQuery}`);

    // 各種ビュー（テーブル描画）の実行
    const seedValue = parseInt(p.seed, 10);
    const lastRollId = p.lr ? parseInt(p.lr, 10) : null;
    const rows = parseInt(p.roll, 10);
    const thresholds = {
        '0': gacha.rarityRates['0'],
        '1': gacha.rarityRates['0'] + gacha.rarityRates['1'],
        '2': gacha.rarityRates['0'] + gacha.rarityRates['1'] + gacha.rarityRates['2'],
        '3': gacha.rarityRates['0'] + gacha.rarityRates['1'] + gacha.rarityRates['2'] + gacha.rarityRates['3'],
        '4': 10000
    };

    if (isComp) {
        createAndDisplayCompletedSeedView(seedValue, gacha, rows, thresholds, lastRollId, p.displaySeed, new URLSearchParams(newQuery), p.ng);
    } else {
        createAndDisplayUncompletedSeedView(seedValue, gacha, rows, thresholds, lastRollId, p.displaySeed, new URLSearchParams(newQuery));
    }
}

/**
 * 確定枠セレクトボックスの生成
 */
function populateGuaranteedRolls(max, currentVal) {
    const input = document.getElementById('guaranteedRollsInput');
    input.innerHTML = '';
    const unsetOption = document.createElement('option');
    unsetOption.value = 'none'; unsetOption.textContent = '未設定'; input.appendChild(unsetOption);
    for (let i = 1; i <= max; i++) {
        const option = document.createElement('option');
        option.value = i; option.textContent = i; input.appendChild(option);
    }
    if (currentVal && input.querySelector(`option[value="${currentVal}"]`)) {
        input.value = currentVal;
    } else {
        input.value = 'none';
    }
}

/**
 * 目玉在庫数セレクトボックスの生成
 */
function populateFeaturedStockInput(gachaId, preferredValue) {
    const gacha = gachaMaster[gachaId];
    const input = document.getElementById('featuredStockInput');
    if (!gacha) return;
    input.innerHTML = '';
    const unsetOption = document.createElement('option');
    unsetOption.value = 'none'; unsetOption.textContent = '-'; input.appendChild(unsetOption);
    for (let i = 1; i <= gacha.featuredItemStock; i++) {
        const option = document.createElement('option');
        option.value = i; option.textContent = i; input.appendChild(option);
    }
    if (preferredValue && preferredValue !== 'none' && input.querySelector(`option[value="${preferredValue}"]`)) {
        input.value = preferredValue;
    } else {
        input.value = 'none';
    }
}

/**
 * SEED入力欄の表示/非表示トグル
 */
function toggleSeedInput() {
    const seedRow = document.getElementById('seedRow');
    if (seedRow.classList.contains('hidden-control')) {
        seedRow.classList.remove('hidden-control');
    } else {
        seedRow.classList.add('hidden-control');
    }
}

// イベントリスナーの設定
document.addEventListener('DOMContentLoaded', () => {
    // ユーティリティによる初期化
    setupGachaRarityItems();

    // 各UI要素のイベント紐付け
    document.getElementById('executeButton').addEventListener('click', () => {
        runSimulationAndDisplay({ hideSeedInput: true, uiOverrides: { seed: document.getElementById('seedInput').value } });
    });
    
    document.getElementById('guaranteedRollsInput').addEventListener('change', (e) => {
        runSimulationAndDisplay({ uiOverrides: { guaranteedRolls: e.target.value } });
    });
    
    document.getElementById('featuredStockInput').addEventListener('change', (e) => {
        runSimulationAndDisplay({ uiOverrides: { featuredStock: e.target.value } });
    });
    
    document.getElementById('featuredCompleteCheckbox').addEventListener('change', () => {
        runSimulationAndDisplay({ uiOverrides: { isComplete: document.getElementById('featuredCompleteCheckbox').checked } });
    });
    
    document.getElementById('toggleSeedBtn').addEventListener('click', () => {
        const params = new URLSearchParams(window.location.search);
        const current = params.get('displaySeed') === '1' ? '0' : '1';
        runSimulationAndDisplay({ uiOverrides: { displaySeed: current } });
    });

    document.getElementById('toggleSimBtn').addEventListener('click', () => {
        const params = new URLSearchParams(window.location.search);
        const current = params.get('displaySim') === '1' ? '0' : '1';
        runSimulationAndDisplay({ uiOverrides: { displaySim: current } });
    });

    document.getElementById('copySeedLink').addEventListener('click', (event) => {
        event.preventDefault();
        const seedToCopy = new URLSearchParams(window.location.search).get('seed');
        if (seedToCopy && navigator.clipboard) {
            navigator.clipboard.writeText(seedToCopy).then(() => {
                const originalText = event.target.textContent;
                event.target.textContent = 'Copied!';
                setTimeout(() => { event.target.textContent = originalText; }, 1500);
            });
        }
    });

    document.getElementById('result-table-container').addEventListener('click', (event) => {
        if (event.target.id === 'forceRerollToggle') {
            window.forceRerollMode = !window.forceRerollMode;
            runSimulationAndDisplay();
        }
    });

    document.getElementById('showSeedInputLink').addEventListener('click', (e) => {
        e.preventDefault();
        toggleSeedInput();
    });

    // ハイライトモードの適用
    const applyHighlightMode = () => {
         const table = document.querySelector('#result-table-container table');
         if (!table) return;
         table.classList.remove('mode-single', 'mode-multi');
         if (currentHighlightMode === 'single') table.classList.add('mode-single');
         if (currentHighlightMode === 'multi') table.classList.add('mode-multi');
    };

    document.getElementById('legendSingle').addEventListener('click', () => {
        if (document.getElementById('featuredCompleteCheckbox').checked) {
            currentHighlightMode = (currentHighlightMode === 'single') ? 'all' : 'single';
            applyHighlightMode();
        }
    });

    document.getElementById('legendMulti').addEventListener('click', () => {
        if (document.getElementById('featuredCompleteCheckbox').checked) {
            currentHighlightMode = (currentHighlightMode === 'multi') ? 'all' : 'multi';
            applyHighlightMode();
        }
    });

    // 初回実行
    runSimulationAndDisplay();
});

====================
FILE: master.js
====================
/**
 * 担当: ガチャ設定およびアイテム情報のマスターデータ定義
 * 依存関係: なし
 */

// --- マスターデータ ---
//'0': NORMAL_CHANCE, '1': RARE_CHANCE, '2': SUPER_CHANCE, '3': UBER_CHANCE, '4': LEGEND_CHANCE /合計10000【要確認】

const gachaMaster = {
    '34': { name: '(旧)ハロウィン',
            featuredItemRate: 600,
            featuredItemStock: 5,
            guaranteedCycle: 30,
            uberGuaranteedFlag: false,
            legendGuaranteedFlag: false,
            rarityRates: { '0': 2000, '1': 5000, '2': 3000, '3': 0, '4': 0 },
            pool: [0, 2, 3, 4, 5, 10, 11, 12, 14] },

    '42': { name: '1.1億DL記念',
            featuredItemRate: 500,
            featuredItemStock: 5,
            guaranteedCycle: 30,
            uberGuaranteedFlag: false,
            legendGuaranteedFlag: false,
            rarityRates: { '0': 1000, '1': 5000, '2': 3000, '3': 1000, '4': 0 },
            pool: [0, 2, 3, 4, 5, 10, 11, 12, 14, 375, 381, 689] },

    '44': { name: 'ハロウィン',
            featuredItemRate: 500,
            featuredItemStock: 8,
            guaranteedCycle: 30,
            uberGuaranteedFlag: false,
            legendGuaranteedFlag: false,
            rarityRates: { '0': 2000, '1': 4900, '2': 3000, '3': 0, '4': 100 },
            pool: [0, 2, 3, 4, 5, 10, 11, 12, 14, 18] },
            
    '45': { name: 'にゃんこレンジャー',
            featuredItemRate: 0,
            featuredItemStock: 0,
            guaranteedCycle: 10,
            uberGuaranteedFlag: true,
            legendGuaranteedFlag: false,
            rarityRates: { '0': 0, '1': 7000, '2': 2300, '3': 500, '4': 200 },
            pool: [0,2,3,4,5,11,12,14,197,184,375,726,831] },

    '46': { name: '春節',
            featuredItemRate: 0,
            featuredItemStock: 0,
            guaranteedCycle: 10,
            uberGuaranteedFlag: true,
            legendGuaranteedFlag: false,
            rarityRates: { '0': 800, '1': 5000, '2': 3000, '3': 1000, '4': 200 },
            pool: [10,0,3,11,12,2,4,5,14,730,646,202,197] }
};

const itemMaster = {
    0: { name: "スピダ", rarity: 1 },
    2: { name: "ネコボン", rarity: 2 },
    3: { name: "ニャンピュ", rarity: 1 },
    4: { name: "おかめ", rarity: 2 },
    5: { name: "スニャ", rarity: 2 },
    10: { name: "5千XP", rarity: 0 },
    11: { name: "1万XP", rarity: 1 },
    12: { name: "3万XP", rarity: 1 },
    14: { name: "10万XP", rarity: 2 },
    18: { name: "200万XP", rarity: 4 },
    197: { name: "100万XP", rarity: 4 },
    184: { name: "ミスターニンジャ", rarity: 3 },
    202: { name: "ネコ小籠包", rarity: 3 },
    375: { name: "記念ネコ", rarity: 3 },
    381: { name: "ねこ農家", rarity: 3 },
    646: { name: "爆竹ネコ", rarity: 3 },
    689: { name: "石の上にも10年ネコ", rarity: 3 },
    726: { name: "ネコメダル王", rarity: 3 },
    730: { name: "古びたタマゴ:N204", rarity: 3 },
    831: { name: "スカーフにゃんこ", rarity: 3 }
};

====================
FILE: style.css
====================
/**
 * 担当: テーブルレイアウト、ハイライト色、UI要素、ポップアップのスタイリング定義
 */
 
 body {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
    line-height: 1.2;
    padding: 5px;
    max-width: 1200px;
    margin: 0 auto;
    background-color: #f4f7f9;
    color: #333;
    font-size: 9px;
}
.container {
    background: #fff;
    padding: 10px;
    border-radius: 12px;
    box-shadow: 0 6px 15px rgba(0, 0, 0, 0.1);
}
h1 {
    color: #004085;
    font-size: 0.9rem;
    border-bottom: 1px solid #e9ecef;
    padding-bottom: 3px;
    margin-top: 0;
    text-align: center;
}
.controls {
    display: flex;
    flex-direction: column;
    gap: 5px;
    margin-bottom: 10px;
    padding: 8px;
    background-color: #f9fbfd;
    border-radius: 4px;
}
.row {
    display: flex;
    flex-wrap: wrap;
    justify-content: space-between;
    gap: 5px;
    align-items: center;
}
.control-group-left, .control-group-right {
    display: flex;
    align-items: center;
    gap: 15px;
}
.input-item {
    flex: 0 1 auto;
    display: flex;
    flex-direction: row;
    align-items: center;
    gap: 3px;
}
.input-item-display-only {
    flex: 0 1 auto;
    display: flex;
    align-items: center;
    font-size: 0.7rem;
    color: #555;
    padding: 0 5px;
}
.input-item-seed {
    display: flex;
    flex-direction: row;
    align-items: center;
    gap: 3px;
}
.seed-input-group {
    display: flex;
    align-items: center;
    gap: 5px;
    flex: 1 1 200px;
}
label {
    font-weight: 600;
    color: #555;
}
input[type="number"],
select {
    padding: 3px;
    border: 1px solid #ccc;
    border-radius: 3px;
    font-size: 0.8rem;
    width: 100%;
    box-sizing: border-box;
    transition: border-color 0.3s;
}
input[type="number"]:focus,
select:focus {
    outline: none;
    border-color: #007bff;
}
button {
    flex-shrink: 0;
    width: auto;
    padding: 5px 10px;
    background-color: #007bff;
    color: #fff;
    border: none;
    border-radius: 3px;
    cursor: pointer;
    font-size: 0.8rem;
    font-weight: bold;
    transition: background-color 0.3s ease, transform 0.2s ease;
}
button:hover {
    background-color: #0056b3;
}
.hidden-control {
    display: none !important;
}
#showSeedInputLink {
    color: #007bff;
    text-decoration: underline;
    cursor: pointer;
    padding: 0 5px;
    font-weight: bold;
}
#copySeedLink {
    color: #007bff;
    text-decoration: underline;
    cursor: pointer;
    white-space: nowrap;
}

#result-container {
    margin-top: 15px;
}
#result-table-container {
    overflow-x: auto;
    border: 1px solid #e0e0e0;
    border-radius: 8px;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
}
table {
    width: 100%;
    border-collapse: collapse;
}
th, td {
    padding: 4px;
    text-align: center;
    border: 1px solid #e0e0e0;
    word-break: break-all;
    font-size: 0.8rem;
}
th {
    background-color: #f0f4f7;
    color: #444;
    font-weight: 600;
    position: sticky;
    top: 0;
    z-index: 10;
}

/* 列幅の固定設定 */
.col-no {
    width: 35px;
}
.data-col {
    width: 85px; /* A, AG, B, BG列を同じ幅に統一 */
}
.col-seed {
    width: 105px; /* SEED列の幅を必要最小限に */
    font-family: monospace;
    font-size: 0.75rem;
    background-color: #fdfdfd;
}

/* アイテム装飾 */
.featuredItem-text {
    color: #d9534f;
    font-weight: bold;
}
.legendItem-text {
    color: #0000ff;
    font-weight: bold;
}
#result-table-container td a {
    color: inherit;
    text-decoration: none;
    cursor: pointer;
}
/* SEED表示時、アイテム名をリンク風に見せる（ポップアップ用） */
.clickable-item {
    color: #007bff !important;
    text-decoration: underline !important;
}

/* 凡例 */
.legend-box {
    padding: 2px 5px;
    border-radius: 3px;
    margin-left: 5px;
    cursor: pointer;
    border: 1px solid transparent;
}
.legend-box:hover {
    border: 1px solid #999;
}
.legend-single { background-color: #e0f7ff; }
.legend-multi { background-color: #ffffe0; }
.legend-common { background-color: #dfffb0; }

/* ハイライト */
.highlight-roll { background-color: #e0f7ff !important; }
.highlight-roll-10pull { background-color: #ffffe0 !important; }
.highlight-roll-overlap { background-color: #dfffb0 !important; }
.highlight-roll-dark { background-color: #80d8ff !important; }
.highlight-roll-10pull-dark { background-color: #ffff8d !important; }
.highlight-roll-overlap-dark { background-color: #b9f6ca !important; }

/* ポップアップ（モーダル） */
.popup-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.6);
    display: none;
    justify-content: center;
    align-items: center;
    z-index: 2000;
}
.popup-modal {
    background-color: #fff;
    padding: 20px;
    border-radius: 8px;
    box-shadow: 0 5px 20px rgba(0,0,0,0.3);
    max-width: 600px;
    width: 90%;
    max-height: 85vh;
    overflow-y: auto;
    position: relative;
    font-size: 0.85rem;
    line-height: 1.5;
}
.popup-close-btn {
    position: absolute;
    top: 10px;
    right: 15px;
    cursor: pointer;
    font-size: 1.5rem;
    font-weight: bold;
    color: #999;
}
.popup-close-btn:hover {
    color: #333;
}
.popup-details h3 {
    margin-top: 0;
    color: #004085;
    border-bottom: 2px solid #007bff;
    padding-bottom: 5px;
}
.popup-details h4 {
    margin: 15px 0 5px 0;
    background-color: #f0f4f7;
    padding: 3px 8px;
    border-left: 4px solid #6c757d;
}
.seed-comparison-error {
    color: #d9534f;
    font-weight: bold;
    background-color: #fff5f5;
    padding: 5px;
    border: 1px solid #d9534f;
    margin-top: 10px;
}

#calculation-details {
    font-family: monospace;
    font-size: 11px;
    line-height: 1.4;
    margin-top: 15px;
    padding: 10px;
    border: 1px solid #ccc;
    border-radius: 5px;
    background: #f9f9f9;
}

.scroll-buttons button {
    font-size: 0.75rem;
    background-color: #28a745;
}
.scroll-buttons button:hover {
    background-color: #218838;
}

/* シミュレーションUI */
#sim-ui-group {
    margin-bottom: 15px;
}

====================
FILE: utils.js
====================
/**
 * 担当: URLクエリ生成、乱数生成、共有の表示補助等の汎用ユーティリティ関数
 * 依存関係: master.js (itemMaster/gachaMasterの参照)
 */

// --- ユーティリティ関数 ---

/**
 * URLSearchParamsオブジェクトからクエリ文字列を生成する
 */
function generateUrlQuery(p) {
    const query = new URLSearchParams();
    for (const key in p) {
        if (p[key] !== null && p[key] !== undefined) {
            query.set(key, p[key]);
        }
    }
    return '?' + query.toString();
}

/**
 * 32bit Xorshiftによる乱数生成（次シード算出）
 */
function xorshift32(seed) {
    let x = seed;
    x ^= x << 13;
    x ^= x >>> 17;
    x ^= x << 15;
    return x >>> 0;
}

/**
 * マスターデータのpool情報をレアリティ別に分類する初期化処理
 * 修正内容: IDによるソートを削除し、定義順（マスターの並び順）を維持します。
 */
function setupGachaRarityItems() {
    for (const gachaId in gachaMaster) {
        const gacha = gachaMaster[gachaId];
        if (gacha && gacha.pool) {
            // 各レアリティのコンテナを初期化
            gacha.rarityItems = { '0': [], '1': [], '2': [], '3': [], '4': [] };
            
            // pool配列に出現する順番で各レアリティに振り分ける
            for (const itemId of gacha.pool) {
                const item = itemMaster[itemId];
                if (item && gacha.rarityItems[item.rarity.toString()] !== undefined) {
                    gacha.rarityItems[item.rarity.toString()].push(itemId);
                }
            }
            
            // 重要: ここでの .sort() を削除しました。
            // これにより、gachaMaster[id].pool の定義順がスロット順になります。
        }
    }
}

/**
 * デバッグ用：マスター情報のHTMLを生成
 */
function generateMasterInfoHtml(gacha) {
    let html = `<h2>＜マスター情報＞</h2>`;
    html += `(ガチャ) ${gacha.name}(ID:${window.activeGachaId || '?'})<br>`;
    html += `(目玉) ${gacha.featuredItemRate > 0}(レート:${gacha.featuredItemRate}, 初期残数:${gacha.featuredItemStock})<br>`;
    html += `(確定) 超激:${gacha.uberGuaranteedFlag}, 伝説:${gacha.legendGuaranteedFlag}<br>`;
    
    const r = gacha.rarityRates;
    const r0 = r['0'];
    const t1 = r0;
    const t2 = r0 + r['1'];
    const t3 = t2 + r['2'];
    const t4 = t3 + r['3'];
    
    let rateStr = `(レート) `;
    if (r0 === 0) rateStr += `0(ノーマル)-, `;
    else rateStr += `0(ノーマル)～${t1-1}, `;
    rateStr += `1(レア)～${t2-1}, `;
    rateStr += `2(激レア)～${t3-1}, `;
    rateStr += `3(超激レア)～${t4-1}, `;
    rateStr += `4(伝説レア)～9999`;
    html += rateStr + `<br>`;
    
    html += `(各レアリティ別アイテム ※スロット順)<br>`;
    const rarities = ['0.ノーマル', '1.レア', '2.激レア', '3.超激レア', '4.伝説レア'];
    for (let i = 0; i <= 4; i++) {
        const pool = gacha.rarityItems[i.toString()];
        if (pool && pool.length > 0) {
            const itemsStr = pool.map(id => `${itemMaster[id].name}(ID:${id})`).join(', ');
            html += `${rarities[i]}(${pool.length}種) ${itemsStr}<br>`;
        }
    }
    return html + '<br>';
}

/**
 * アイテム比較情報の整形（コンプ済み表示用）
 */
function getFormattedItemComparison(nodeItemName, nodeItemId, nodeRarityId, prevItemId, comparisonTargetName) {
    const rComp = (nodeRarityId === 1) ? '1=1' : `${nodeRarityId}≠1`;
    let idComp = '';
    let targetDisplay = comparisonTargetName ? comparisonTargetName : (prevItemId === -1 ? 'Null' : `${prevItemId}`);

    if (prevItemId === -1) {
         idComp = (nodeItemId === -1) ? '=Null' : '≠Null'; 
    } else {
         idComp = (nodeItemId === prevItemId) ? `=${targetDisplay}` : `≠${targetDisplay}`;
    }
    
    const text = `${nodeItemName}(${nodeItemId}(${rComp})${idComp})`;
    return { text, isDupe: (nodeRarityId === 1 && nodeItemId !== -1 && nodeItemId === prevItemId) };
}

/**
 * アイテムリンク生成ヘルパー
 */
/**
 * アイテムリンク生成ヘルパー (修正版)
 * 引数がズレていても（第1引数がSEED値でも）動作するように調整
 */
function generateItemLink(baseParams, newSeed, newItemId, ngVal, rollNumberInSequence, isCompleted, fsVal) {
    const gId = window.activeGachaId;
    const paramsForQuery = {};
    
    // 第1引数が URLSearchParams でない場合の互換性処理
    let effectiveParams = baseParams;
    let s = newSeed, id = newItemId, ng = ngVal, fs = fsVal;

    if (!(baseParams instanceof URLSearchParams)) {
        effectiveParams = new URLSearchParams(window.location.search);
        s = arguments[0]; // 第1引数をSEEDとして扱う
        id = arguments[1]; // 第2引数をアイテムIDとして扱う
        ng = arguments[2]; // 第3引数をNG値として扱う
        fs = arguments[5]; // 第6引数を在庫数として扱う
    }

    // ベースとなるパラメータをコピー
    for (const [key, value] of effectiveParams.entries()) {
        paramsForQuery[key] = value;
    }
    
    if (!paramsForQuery.gacha) paramsForQuery.gacha = gId;
    paramsForQuery.seed = s;
    if (id !== undefined) paramsForQuery.lr = id;
    if (fs !== undefined && fs !== null && !isNaN(fs)) paramsForQuery.fs = fs;
    if (ng !== undefined && ng !== null) paramsForQuery.ng = ng.toString();
    
    return generateUrlQuery(paramsForQuery);
}

====================
FILE: view-completed.js
====================
/**
 * 担当: 「コンプ済み」ビューのメインテーブル描画およびポップアップ制御
 */

let viewData = {
    calculatedData: null,
    gacha: null,
    initialLastRollId: null,
};

function showCalculationPopup(nodeIndex, isGuaranteed, linkSeeds) {
    if (nodeIndex === undefined || viewData.calculatedData === null) return;
    const node = viewData.calculatedData.Nodes[nodeIndex];
    if (!node) return;

    const popupOverlay = document.getElementById('seed-popup-overlay');
    const popupContent = document.getElementById('popup-content');
    const html = generateNodeCalculationDetailsHtml(
        node, viewData.gacha, viewData.calculatedData.thresholds,
        viewData.initialLastRollId, viewData.calculatedData.Nodes,
        linkSeeds, isGuaranteed
    );
    popupContent.innerHTML = html;
    popupOverlay.style.display = 'flex';
}

function setupPopupHandlers() {
    const popupOverlay = document.getElementById('seed-popup-overlay');
    const closeBtn = document.querySelector('.popup-close-btn');
    const copyBtn = document.getElementById('copy-popup-content-btn');
    if (!popupOverlay || !closeBtn) return;

    const hidePopup = () => { popupOverlay.style.display = 'none'; };
    if (!window.hasEscListener) {
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && popupOverlay.style.display === 'flex') hidePopup();
        });
        window.hasEscListener = true;
    }

    if (!popupOverlay.dataset.handlerAttached) {
        popupOverlay.addEventListener('click', (e) => { if (e.target === popupOverlay) hidePopup(); });
        closeBtn.addEventListener('click', hidePopup);
        if (copyBtn) {
            copyBtn.onclick = () => {
                const text = document.getElementById('popup-content').innerText;
                navigator.clipboard.writeText(text).then(() => {
                    const original = copyBtn.textContent;
                    copyBtn.textContent = 'コピー完了';
                    setTimeout(() => { copyBtn.textContent = original; }, 1500);
                });
            };
        }
        popupOverlay.dataset.handlerAttached = 'true';
    }
}

function createAndDisplayCompletedSeedView(initialSeed, gacha, tableRows, thresholds, initialLastRollId, displaySeed, params, initialNg) {
    setupPopupHandlers();
    const { Nodes, highlightInfo } = calculateCompletedData(initialSeed, gacha, tableRows, thresholds, initialLastRollId, initialNg);

    viewData.calculatedData = { Nodes, highlightInfo, thresholds };
    viewData.gacha = gacha;
    viewData.initialLastRollId = initialLastRollId;

    const getAddress = (n) => getAddressStringGeneric(n, 2);
    const currentParams = new URLSearchParams(window.location.search);
    let table = `<table style="table-layout: fixed;" class="${currentHighlightMode === 'single' ? 'mode-single' : (currentHighlightMode === 'multi' ? 'mode-multi' : '')}">`;
    table += '<thead>';
    const header = (displaySeed === '1') 
        ? `<tr><th id="forceRerollToggle" class="col-no">#</th><th class="col-seed">SEED</th><th>A</th><th>AG</th><th class="col-seed">SEED</th><th>B</th><th>BG</th></tr>`
        : `<tr><th id="forceRerollToggle" class="col-no">#</th><th>A</th><th>AG</th><th>B</th><th>BG</th></tr>`;
    table += header + '</thead><tbody>';

    for (let r = 1; r <= tableRows; r++) {
        const nodeIdxA = (r - 1) * 2 + 1;
        const nodeIdxB = (r - 1) * 2 + 2;
        const nodeA = Nodes[nodeIdxA - 1];
        const nodeB = Nodes[nodeIdxB - 1];
        if (!nodeA || !nodeB) break;

        table += `<tr><td class="col-no">${r}</td>`;

        const renderCell = (node, isGuar) => {
            const addr = node.address + (isGuar ? 'G' : '');
            const info = highlightInfo.get(addr);
            
            let cls = determineHighlightClass(info);
            const isPartnerRR = (node.reRollFlag || node.reRerollFlag);

            let linkSeeds = {
                normal: node.seed2, 
                reroll: isPartnerRR ? node.seed3 : null, 
                avoid: node.seed2,
                cycleHeadSeed: (info && info.gRaritySeed) ? info.gRaritySeed : null,
                cycleHeadIdx: (info && info.cycleHeadIdx) ? info.cycleHeadIdx : null
            };

            const getFmt = (id, skipStyle = false) => {
                if (id === undefined || id === null || id === -1) return '---';
                const name = getItemNameSafe(id);
                if (skipStyle) return name;
                
                const item = itemMaster[id];
                if (!item) return name;
                if (item.rarity === 3) return `<span style="color:#d9534f; font-weight:bold;">${name}</span>`;
                if (item.rarity === 4) return `<span style="color:#0000ff; font-weight:bold;">${name}</span>`;
                return name;
            };

            let displayHtml = '---';
            if (node.itemId !== -1) {
                if (displaySeed === '1') {
                    const buildStaticItemDisplay = (isGuaranteedColumn) => {
                        if (isGuaranteedColumn) {
                            const base = getFmt(node.itemGId, true);
                            if (isPartnerRR) {
                                const poolG = gacha.rarityItems[node.rarityGId] || [];
                                const itemG_rr_Id = poolG[node.seed2 % Math.max(1, poolG.length)];
                                return `${base}<br>${getFmt(itemG_rr_Id, true)}`;
                            }
                            return base;
                        } else {
                            const base = getFmt(node.itemId);
                            if (isPartnerRR) {
                                return `${base}<br>${getAddress(node.index + 3)})${getFmt(node.reRollItemId)}`;
                            }
                            return base;
                        }
                    };
                    const nameHtml = buildStaticItemDisplay(isGuar);
                    const json = JSON.stringify(linkSeeds).replace(/"/g, '&quot;');
                    displayHtml = `<a href="#" onclick="showCalculationPopup(${node.index - 1}, ${isGuar}, ${json}); return false;">${nameHtml}</a>`;
                } else {
                    if (isGuar) {
                        const baseName = getFmt(node.itemGId, true);
                        if (isPartnerRR) {
                            const poolG = gacha.rarityItems[node.rarityGId] || [];
                            const itemG_rr_Id = poolG[node.seed2 % Math.max(1, poolG.length)];
                            const link1 = `<a href="${generateItemLink(currentParams, node.seed2, node.itemGId, initialNg, r, true)}">${baseName}</a>`;
                            const link2 = `<a href="${generateItemLink(currentParams, node.seed3, itemG_rr_Id, initialNg, r, true)}">${getFmt(itemG_rr_Id, true)}</a>`;
                            displayHtml = `${link1}<br>${link2}`;
                        } else {
                            displayHtml = `<a href="${generateItemLink(currentParams, node.seed2, node.itemGId, initialNg, r, true)}">${baseName}</a>`;
                        }
                    } else {
                        const baseName = getFmt(node.itemId);
                        if (isPartnerRR) {
                            const link1 = `<a href="${generateItemLink(currentParams, node.seed2, node.itemId, initialNg, r, true)}">${baseName}</a>`;
                            const link2 = `<a href="${generateItemLink(currentParams, node.seed3, node.reRollItemId, initialNg, r, true)}">${getAddress(node.index + 3)})${getFmt(node.reRollItemId)}</a>`;
                            displayHtml = `${link1}<br>${link2}`;
                        } else {
                            displayHtml = `<a href="${generateItemLink(currentParams, node.seed2, node.itemId, initialNg, r, true)}">${baseName}</a>`;
                        }
                    }
                }
            }
            return { html: `<td class="${cls || ''}">${displayHtml}</td>` };
        };

        const cA = renderCell(nodeA, false); const cAG = renderCell(nodeA, true);
        const cB = renderCell(nodeB, false); const cBG = renderCell(nodeB, true);

        if (displaySeed === '1') {
            table += `<td class="col-seed">${nodeA.seed1} [${nodeA.index}]</td>${cA.html}${cAG.html}<td class="col-seed">${nodeB.seed1} [${nodeB.index}]</td>${cB.html}${cBG.html}`;
        } else {
            table += cA.html + cAG.html + cB.html + cBG.html;
        }
        table += '</tr>';
    }
    table += '</tbody></table>';
    document.getElementById('result-table-container').innerHTML = table;
}

====================
FILE: view-simulation.js
====================
//Delete

====================
FILE: view-uncompleted-details.js
====================
/**
 * 担当: 「未コンプ」ビューの下部に表示される計算過程および10連詳細のHTML描画
 * 依存関係: utils.js (generateItemLinkの利用)
 */

/**
 * 詳細テーブル（計算過程）と10連詳細のHTMLを生成してDOMに挿入
 */
function renderUncompletedDetails(Nodes, highlightInfo, maxNodes, tenPullCyclesData, gacha, initialLastRollId, params) {
    const ngVal = parseInt(params.get('ng'), 10);
    const initialFs = parseInt(params.get('fs'), 10) || 0;
    const guaranteedCycle = gacha.guaranteedCycle || 30;
    let ngTrackerDetail = !isNaN(ngVal) && ngVal > 0 ? ngVal : guaranteedCycle;

    // --- 1. 計算詳細 (単発ガチャ詳細) のHTML組み立て ---
    let html = generateMasterInfoHtml(gacha);
    
    let lastRollText = 'Null';
    if (initialLastRollId && itemMaster[initialLastRollId]) {
        lastRollText = `${itemMaster[initialLastRollId].name}(${initialLastRollId}(${itemMaster[initialLastRollId].rarity}))`;
    }

    html += '<h2>＜ノード計算詳細 (No.1～)＞</h2>';
    html += `LastRoll：${lastRollText}<br><br>単発ガチャ詳細<br>`;
    html += '<table style="table-layout: fixed; width: auto; font-size: 9px; border-collapse: collapse;"><thead>';
    html += '<tr style="background-color: #f2f2f2;">';
    html += '<th style="border: 1px solid #ccc; padding: 5px;">No.<br>Address</th><th style="border: 1px solid #ccc; padding: 5px;">Seed<br>(Sn)</th><th style="border: 1px solid #ccc; padding: 5px;">Featured<br>(Sn)</th><th style="border: 1px solid #ccc; padding: 5px;">Rarity<br>(Sn+1)</th><th style="border: 1px solid #ccc; padding: 5px;">Item<br>(Sn+2)</th><th style="border: 1px solid #ccc; padding: 5px;">Reroll<br>(Sn+3)</th><th style="border: 1px solid #ccc; padding: 5px;">ReRollFlag<br>Crnt vs Prev</th><th style="border: 1px solid #ccc; padding: 5px;">Roll<br>(next)</th><th style="border: 1px solid #ccc; padding: 5px;">NextGuar<br>aftRoll</th>'; 
    html += '</tr></thead><tbody>'; 

    for (let i = 1; i <= maxNodes; i++) {
        const node = Nodes[i-1];
        if (!node) continue;
        
        // NGカウンター更新
        let ngContentDetail = '-';
        if (node.singleRoll !== null) {
            let nextNg = ngTrackerDetail - 1;
            if (ngTrackerDetail === 1) { 
                 const nextStartNg = guaranteedCycle - 1; 
                 ngContentDetail = `目玉(確定)<br>${guaranteedCycle}→${nextStartNg}`;
                 ngTrackerDetail = nextStartNg;
            } else if (ngTrackerDetail > 1) {
                ngContentDetail = nextNg.toString();
                ngTrackerDetail = nextNg;
            }
        }
        
        // Highlight logic
        const itemInfo = highlightInfo.get(node.address);
        const baseCls = determineHighlightClass(itemInfo);
        let featuredClsAttr = '', itemClsForNormal = '', itemClsForReroll = '';

        if (itemInfo) {
            if (itemInfo.single && itemInfo.s_featured) featuredClsAttr = ` class="${baseCls}"`; 
            if ((itemInfo.single && !itemInfo.s_reRoll && !itemInfo.s_featured) || (itemInfo.ten && !itemInfo.t_reRoll)) itemClsForNormal = baseCls; 
            if ((itemInfo.single && itemInfo.s_reRoll) || (itemInfo.ten && itemInfo.t_reRoll)) itemClsForReroll = baseCls; 
        }

        // 修正箇所: 変数定義を追加
        const itemClsAttr = itemClsForNormal ? ` class="${itemClsForNormal}"` : '';
        const rerollClsAttr = itemClsForReroll ? ` class="${itemClsForReroll}"` : '';

        // Columns Content
        let singleDisplay = node.singleRoll !== null ? node.singleRoll.toString() : '';
        if (node.singleRoll !== null && node.singleUseSeeds !== null) {
             singleDisplay += `<br>${node.index}+${node.singleUseSeeds}<br>${node.index + node.singleUseSeeds}(${node.singleNextAddr})`;
        }

        // Featured Content
        let featuredContent = node.isFeatured ? 'True' : 'False';
        if (node.isFeatured) {
             const fHref = generateItemLink(node.seed1, -2, node.guaranteedNextNgVal || ngVal, node.index, false, initialFs);
             featuredContent = `<a href="${fHref}" style="text-decoration: none; color: inherit;">True</a>`;
        }
        featuredContent += `<br>S${node.index}%10000<br>${node.seed1 % 10000}${node.isFeatured ? '<' : '>='}${gacha.featuredItemRate}`;

        // Rarity Content
        let rarityContent = `${node.rarityId}(${node.rarity.name})<br>S${node.index + 1}%10000<br><span style="font-size: 80%;">${node.rarityRateRangeDisplay}</span>`;

        // Item & Reroll Content
        let itemContent = '-';
        if (node.itemId !== -1) {
             const nextNg = node.isGuaranteedRoll ? (guaranteedCycle - 1) : ngTrackerDetail;
             const iHref = generateItemLink(node.seed3, node.itemId, nextNg, node.index + 1, false, initialFs);
             let style = node.isFeatured && itemInfo && itemInfo.single ? "color: red; font-weight: bold;" : "";
             if (node.isGuaranteedRoll) {
                 const gHref = generateItemLink(node.prevSeed1, node.singleCompareItemId, guaranteedCycle, node.index, false, initialFs);
                 itemContent = `<a href="${gHref}" class="featuredItem-text">目玉(確定)</a> / <a href="${iHref}">${node.itemName}</a>`;
             } else {
                 itemContent = `<a href="${iHref}" style="${style}">${node.itemName}</a>`;
             }
             itemContent += `<br>S${node.index+2}%${node.poolSize}<br>${node.slot}→ID:${node.itemId}`;
        }

        let rerollContent = '-';
        if (node.reRollItemId !== -1) {
             const nextNg = node.isGuaranteedRoll ? (guaranteedCycle - 1) : ngTrackerDetail;
             const rHref = generateItemLink(node.seed4, node.reRollItemId, nextNg, node.index + 1, false, initialFs);
             rerollContent = `<a href="${rHref}">${node.reRollItemName}</a><br>S${node.index+3}%${node.poolSize>1?node.poolSize-1:0}<br>${node.reRollSlot}→ID:${node.reRollItemId}`;
        }

        // ReRoll Flag (Simplified)
        let reRollFlagContent = node.reRollFlag || '-'; 
        if (!node.reRollFlag && node.singleRoll) {
             reRollFlagContent = node.singleIsReroll ? 'True' : 'False';
             if (node.rarityId===1 && !node.isFeatured) reRollFlagContent += `<br>レア→Yes<br>${node.itemId}vs${node.singleCompareItemId}`;
             else if (node.isFeatured) reRollFlagContent += '<br>目玉→No';
             else reRollFlagContent += '<br>Other→No';
        }

        html += `<tr>
            <td style="border: 1px solid #ccc; padding: 5px; text-align: center;">${node.index}<br>${node.address}</td>
            <td style="border: 1px solid #ccc; padding: 5px; text-align: center; font-family: monospace;">S${node.index}<br>${node.seed1}</td>
            <td style="border: 1px solid #ccc; padding: 5px; text-align: center;"${featuredClsAttr}>${featuredContent}</td>
            <td style="border: 1px solid #ccc; padding: 5px; text-align: center;">${rarityContent}</td>
            <td style="border: 1px solid #ccc; padding: 5px; text-align: center;"${itemClsAttr}>${itemContent}</td>
            <td style="border: 1px solid #ccc; padding: 5px; text-align: center;"${rerollClsAttr}>${rerollContent}</td>
            <td style="border: 1px solid #ccc; padding: 5px; text-align: center;">${reRollFlagContent}</td>
            <td style="border: 1px solid #ccc; padding: 5px; text-align: center;">${singleDisplay}</td>
            <td style="border: 1px solid #ccc; padding: 5px; text-align: center;">${ngContentDetail}</td>
        </tr>`;
    }
    html += '</tbody></table>';

    // --- 2. 10連詳細セクション ---
    if (tenPullCyclesData && tenPullCyclesData.length > 0) {
        html += '<h2 style="margin-top:20px;">＜10連詳細 (現在地からのシミュレーション / 10サイクル)＞</h2>';
        let cumulativeFs = initialFs;
        
        tenPullCyclesData.forEach((cycle, idx) => {
            const count = cycle.featuredCountInCycle || 0;
            cumulativeFs -= count;
            
            html += `<div style="margin-top: 15px; border: 1px solid #000; padding: 10px; background-color: #fcfcfc;">`;
            html += `<h3>【Cycle ${idx + 1}】 (目玉: ${count})</h3>`;
            html += `<p>NG開始: ${cycle.startNgVal}, LastRoll: ${getItemNameSafe(cycle.startLastRollId)}</p>`;
            html += `<p>判定: ${cycle.guaranteedStatus}</p>`;
            
            html += '<h4>[Log]</h4><ul>';
            cycle.processLog.forEach(l => html += `<li style="font-size: 0.8rem;">${l}</li>`);
            html += '</ul>';

            html += '<h4>[Result]</h4><table style="border-collapse: collapse;">';
            cycle.results.forEach(res => {
                const style = res.isGuaranteed || res.isFeatured ? 'color: #d9534f; font-weight: bold;' : '';
                html += `<tr><td style="border: 1px solid #eee;">${res.label}</td><td style="border: 1px solid #eee; ${style}">${res.name}</td></tr>`;
            });
            html += '</table>';

            const linkUrl = generateItemLink(cycle.transition.nextSeed, cycle.transition.lastItemId, cycle.transition.nextNgVal, cycle.transition.nextIndex, false, cumulativeFs);
            html += `<p>Next: ${cycle.transition.nextIndex}(${cycle.transition.nextAddress}) → <a href="${linkUrl}" style="font-weight: bold; color: blue;">遷移する</a></p>`;
            html += '</div>';
        });
    }

    // DOM挿入
    const detailsDiv = document.getElementById('calculation-details'); 
    detailsDiv.innerHTML = html;
}

====================
FILE: view-uncompleted-main.js
====================
/**
 * 担当: 「未コンプ」ビューの描画フロー制御（オーケストレーター）
 * 依存関係: logic-uncompleted.js, view-uncompleted-table.js, view-uncompleted-details.js, view-uncompleted-ui.js
 */

/**
 * 未コンプビューの初期化および描画のメインエントリポイント
 */
function createAndDisplayUncompletedSeedView(initialSeed, gacha, tableRows, thresholds, initialLastRollId, displaySeed, params) {
    // 1. データ計算の実行 (logic-uncompleted.js)
    const { 
        Nodes, highlightInfo, maxNodes, 
        tenPullCyclesData, expectedFeaturedCounts 
    } = calculateUncompletedData(initialSeed, gacha, tableRows, thresholds, initialLastRollId, params);

    // URLパラメータから現在の設定値を計算
    const ngVal = parseInt(params.get('ng'), 10);
    const initialFs = parseInt(params.get('fs'), 10) || 0;
    const guaranteedCycle = gacha.guaranteedCycle || 30;
    let initialNg = !isNaN(ngVal) && ngVal > 0 ? ngVal : guaranteedCycle;

    // 2. 計算過程の詳細表示をレンダリング (view-uncompleted-details.js)
    renderUncompletedDetails(Nodes, highlightInfo, maxNodes, tenPullCyclesData, gacha, initialLastRollId, params);
    
    // 3. メインテーブルのレンダリング (view-uncompleted-table.js)
    renderUncompletedMainTable(Nodes, highlightInfo, tenPullCyclesData, expectedFeaturedCounts, tableRows, displaySeed, initialNg, initialFs, guaranteedCycle);

    // 4. UI操作用ロジック（トグルボタン等）の初期化 (view-uncompleted-ui.js)
    if (typeof setupDetailsToggleLogic === 'function') {
        setupDetailsToggleLogic();
    }
}

====================
FILE: view-uncompleted-table.js
====================
/**
 * 担当: 「未コンプ」ビューのメインテーブルおよび期待値情報のHTML描画
 * 依存関係: utils.js (generateItemLinkの利用)
 */

/**
 * 未コンプビューのメインテーブル（期待値表示含む）を生成してDOMに挿入する関数
 * @param {Array} Nodes - 計算済みの全ノードデータ
 * @param {Map} highlightInfo - ハイライト情報（単発ルート、10連ルートの判定用）
 * @param {Array} tenPullCyclesData - 10連シミュレーションの結果データ
 * @param {Object} expectedFeaturedCounts - 期待値データ
 * @param {number} tableRows - 表示する行数
 * @param {string} displaySeed - '1'なら詳細表示、それ以外は通常表示
 * @param {number} initialNg - 初期のNext Guaranteed値
 * @param {number} initialFs - 初期のFeatured Stock値
 * @param {number} guaranteedCycle - 確定周期（通常30）
 */
function renderUncompletedMainTable(Nodes, highlightInfo, tenPullCyclesData, expectedFeaturedCounts, tableRows, displaySeed, initialNg, initialFs, guaranteedCycle) {
    
    // --- ヘルパー関数: アイテムCSS決定 ---
    function determineItemCss(itemId) {
        if (!itemMaster[itemId]) return '';
        if (itemMaster[itemId].rarity === 4) return 'legendItem-text';
        if (itemMaster[itemId].rarity >= 3) return 'featuredItem-text';
        return '';
    }

    // --- 期待値表示エリア ---
    let expectedValueHtml = '<div>';
    if (expectedFeaturedCounts) {
        expectedValueHtml += '<h3>＜単発Nroll後の10連での目玉獲得数予測＞</h3>'; 
        const expectedKeys = Object.keys(expectedFeaturedCounts).sort((a, b) => parseInt(a) - parseInt(b));
        
        const expectedValueText = expectedKeys.map(n => {
            const m = expectedFeaturedCounts[n];
            const rollNum = parseInt(n) + 1; 
            return `${rollNum}roll:<span style="font-weight: bold;">${Math.floor(m)}個</span>`;
        }).join(', ');
        
        expectedValueHtml += `<p style="font-size: 1.1em;">${expectedValueText}</p>`;
    } else {
        expectedValueHtml += '<p>期待値データが見つかりませんでした。</p>';
    }
    expectedValueHtml += '</div><br>';

    // --- テーブルヘッダー生成 ---
    let table = expectedValueHtml;
    table += '<table style="table-layout: fixed;"><thead>';
    
    let header1 = `<tr><th id="forceRerollToggle" class="col-no" style="cursor: pointer;">${window.forceRerollMode ? '☑' : '□'}</th>`;
    header1 += '<th>A</th><th>B</th><th>C</th><th>G</th>';
    header1 += '</tr>';
    table += header1;
    table += '</thead><tbody>';

    // --- メインループ変数の初期化 ---
    let currentNgVal = !isNaN(initialNg) ? initialNg : -1;
    let currentFsVal = initialFs;

    // --- メインループ (各行の生成) ---
    for (let r = 0; r < tableRows; r++) {
        table += `<tr><td class="col-no">${r + 1}</td>`;
        const nodeIndices = [r * 3 + 1, r * 3 + 2, r * 3 + 3]; // 1行あたりA, B, Cの3ノード
        
        // --- A, B, C 列の処理 ---
        nodeIndices.forEach((idx, colIndex) => {
            const node = Nodes[idx - 1];
            if (!node) {
                table += displaySeed === '1' ? '<td colspan="5"></td>' : '<td></td>';
                return;
            }

            const info = highlightInfo.get(node.address);
            let cls = determineHighlightClass(info);
            
            const isSingleRouteNode = info && info.single; // 単発ガチャのルートに存在するノードか
            const isGuaranteedNode = isSingleRouteNode && node.isGuaranteedRoll; // 単発ルートで確定ロールか

            let content = '';
            let linkFs = currentFsVal;
            
            // ReRollFlagの取得
            const nodeReRollFlag = node.reRollFlag; // logic側で計算済みと仮定

            // ----------------------------------------------------------------
            // Case 1: Single Route Logic (単発ガチャルート上のノード)
            // ----------------------------------------------------------------
            if (isSingleRouteNode) {
                 if (isGuaranteedNode) {
                     // 1-A. Guaranteed Roll Processing (確定ノード)
                     // Next NG resets to guaranteedCycle - 1 (例: 29)
                     const nextNg = guaranteedCycle - 1; 

                     // 目玉(確定)リンク (前の状態への遷移、NG=30)
                     const guaranteedLinkSeed = node.prevSeed1; 
                     const guaranteedLinkNg = guaranteedCycle; 
                     const guaranteedLinkFs = initialFs; // FSは減らない(仕様による)
                     const guaranteedHref = generateItemLink(guaranteedLinkSeed, node.singleCompareItemId, guaranteedLinkNg, node.index, false, guaranteedLinkFs);
                     const guaranteedLinkStyle = `text-decoration: none; color: inherit; font-weight: bold;`;
                     const guaranteedLink = `<a href="${guaranteedHref}" class="featuredItem-text" style="${guaranteedLinkStyle}">目玉(確定)</a>`; 

                     // アイテム名リンク (確定ロール後の状態への遷移、NG=29)
                     const itemDisplayName = node.itemName;
                     const itemLinkSeed = node.seed3; // S(n+2)
                     const itemLinkNg = guaranteedCycle - 1; 
                     const itemLinkFs = initialFs;
                     const itemHref = generateItemLink(itemLinkSeed, node.itemId, itemLinkNg, r+1, false, itemLinkFs);
                     const itemLinkStyle = `text-decoration: none; color: inherit; font-weight: normal;"`;
                     const itemNameLink = `<a href="${itemHref}" style="${itemLinkStyle}">${itemDisplayName}</a>`;

                     content = `${guaranteedLink} / ${itemNameLink}`;
                     
                     // 状態更新
                     currentNgVal = guaranteedCycle - 1; // 次のNG値をリセット
                     currentFsVal = linkFs; 

                 } else {
                     // 1-B. Normal Single Route Node (非確定ノード)
                     // 次のノードの開始NG値
                     let nextNg = (currentNgVal !== -1) ? currentNgVal - 1 : 'none';
                     if (nextNg !== 'none' && nextNg <= 0) nextNg = guaranteedCycle;
                     
                     if (node.isFeatured) {
                         // 目玉アイテムの場合
                         linkFs = currentFsVal - 1;
                         const currentSeedVal = node.seed1; 
                         const hrefFeatured = generateItemLink(currentSeedVal, -2, nextNg, r+1, false, linkFs);
                         content = `${node.featuredNextAddress})<a href="${hrefFeatured}"><span class="featuredItem-text">目玉</span></a>`;
                         currentFsVal -= 1; // FSカウンターを減らす
                     } else {
                        // 通常アイテム
                        const isRerollHighlight = info ? info.s_reRoll : false;
                        
                        if (isRerollHighlight) {
                             // 再抽選が行われたケース
                             const preRerollName = node.itemName; 
                             const postRerollId = node.reRollItemId;
                             const postRerollName = node.reRollItemName;
                             
                             // Pre-Reroll Link: S(n+2)
                             const preSeed = node.seed3; 
                             const preHref = generateItemLink(preSeed, node.itemId, nextNg, r+1, false, linkFs);
                             let preCss = determineItemCss(node.itemId);

                             // Post-Reroll Link: S(n+3)
                             const postSeed = node.seed4; 
                             const postHref = generateItemLink(postSeed, postRerollId, nextNg, r+1, false, linkFs);
                             let postCss = determineItemCss(postRerollId);

                             content = `<a href="${preHref}" class="${preCss}">${preRerollName}</a><br>${node.reRollNextAddress})<a href="${postHref}" class="${postCss}">${postRerollName}</a>`;

                        } else {
                             // 通常排出のケース
                             // Item Link: S(n+2)
                             const nextSeed = node.seed3; 
                             const finalId = node.itemId; 
                             const href = generateItemLink(nextSeed, finalId, nextNg, r+1, false, linkFs);
                             let css = determineItemCss(finalId);
                             content = `<a href="${href}" class="${css}">${node.itemName}</a>`;

                             // 再抽選候補リンク (ReRollFlagがTrueの場合、または強制再抽選モードの場合)
                             if (node.reRollItemId !== -1) { 
                                 if (node.singleIsReroll || window.forceRerollMode) { // node.singleIsReroll を参照
                                     // ReRoll Link: S(n+3)
                                     const rrHref = generateItemLink(node.seed4, node.reRollItemId, nextNg, r+1, false, linkFs); 
                                     let rrName = node.reRollItemName;
                                     let rrCss = determineItemCss(node.reRollItemId);
                                     content += `<br>${node.reRollNextAddress})<a href="${rrHref}" class="${rrCss}">${rrName}</a>`;
                                 }
                             }
                        }
                     }
                     // 状態更新
                     if (currentNgVal !== -1) {
                         currentNgVal -= 1; // 通常時は1減らす
                         if (currentNgVal <= 0) currentNgVal = guaranteedCycle;
                     }
                 }
            } else {
                // ----------------------------------------------------------------
                // Case 2: Off-Route Logic (ルート外の共通ロジック)
                // ----------------------------------------------------------------
                // リンクNG値は「次のロールの開始NG値」
                let linkNgVal = (initialNg !== -1) ? initialNg - (r + 1) : 'none';
                if (linkNgVal !== 'none' && linkNgVal <= 0) {
                    // 0以下になった場合、次のロールの開始NG値は guaranteedCycle - 1
                    // (ここでの計算は簡易的なため、厳密なNG追跡が必要ならLogic側で計算してNodeに持たせるのが理想)
                    linkNgVal = guaranteedCycle - 1;
                }
                const linkFsVal = initialFs; 
                
                if (node.isFeatured) {
                    // 目玉アイテムの場合
                    const currentSeed = node.seed1; 
                    const hrefFeatured = generateItemLink(currentSeed, -2, linkNgVal, r+1, false, linkFsVal);
                    content = `${node.featuredNextAddress})<a href="${hrefFeatured}"><span class="featuredItem-text">目玉</span></a>`;
                    
                } else {
                    const finalId = node.itemId;
                    const preRerollName = node.itemName; 
                    
                    // 1. Pre-Reroll / Normal Link: S(n+2)
                    const nextSeedNormal = node.seed3; 
                    const hrefNormal = generateItemLink(nextSeedNormal, finalId, linkNgVal, r+1, false, linkFsVal);
                    let cssNormal = determineItemCss(finalId);

                    content = `<a href="${hrefNormal}" class="${cssNormal}">${preRerollName}</a>`;
                    
                    // 再抽選リンク (重複再抽選フラグがTrueの場合、または強制再抽選モードの場合)
                    if (node.reRollItemId !== -1 && node.isDupe) {
                        if (window.forceRerollMode || (info && info.ten && info.t_reRoll)) { // 10連ルートの再抽選判定などを考慮
                            // 2. Post-Reroll Link: S(n+3)
                            const nextSeedReroll = node.seed4; 
                            const rrId = node.reRollItemId;
                            const rrName = node.reRollItemName;
                            const rrHref = generateItemLink(nextSeedReroll, rrId, linkNgVal, r+1, false, linkFsVal);
                            let rrCss = determineItemCss(rrId);
                            
                            content += `<br>${node.reRollNextAddress})<a href="${rrHref}" class="${rrCss}">${rrName}</a>`;
                        }
                    }
                }
            }

            // --- セルHTML生成 ---
            if (displaySeed === '1' && node) {
                content += `<br><span class="seed-value" style="font-size: 0.7em; color: #888;">${node.seed1}</span>`;
            }
            table += `<td${cls ? ' class="'+cls+'"' : ''}>${content}</td>`;
        });

        // --- G Column Logic (10連ガチャシミュレーション結果) ---
        let gContent = '-';
        let gStyle = '';
        
        const cycleIndex = Math.floor(r / 10);
        const rollIndex = r % 10;
        
        const tenPullDetailData = tenPullCyclesData ? tenPullCyclesData[cycleIndex] : null; 
        
        if (rollIndex < 9) { gStyle = 'background-color: #ffffe0;'; } else if (rollIndex === 9) { gStyle = 'background-color: #ffff8d;'; }

        if (tenPullDetailData && rollIndex < 10) {
            const res = tenPullDetailData.results[rollIndex];
            if (res) {
                let cellName = res.name;
                if (res.isReroll && res.preRerollName) {
                    cellName = `（${res.preRerollName}↓）<br>${cellName}`;
                }
                if (res.isGuaranteed) {
                    cellName = `<span class="featuredItem-text">${cellName}</span>`;
                } else if (res.isFeatured) {
                    cellName = `<span class="featuredItem-text">${cellName}</span>`;
                }

                if (rollIndex === 9) {
                    const addressStr = tenPullDetailData.transition.nextAddress;
                    let nextNg = tenPullDetailData.transition.nextNgVal;
                    
                    if (isNaN(nextNg) || nextNg <= 0) {
                        nextNg = guaranteedCycle - 1; 
                    }
                    
                    let usedFs = tenPullDetailData.featuredCountInCycle || 0;
                    let nextFs = initialFs - usedFs; // ※累積計算は簡易的（このサイクル分のみ減算）

                    const href10 = generateItemLink(
                        tenPullDetailData.transition.nextSeed,
                        tenPullDetailData.transition.lastItemId,
                        nextNg,
                        tenPullDetailData.transition.nextIndex, 
                        false, 
                        nextFs
                    );
                    gContent = `${addressStr})<a href="${href10}">${cellName}</a>`;
                } else {
                    gContent = cellName;
                }
            }
        }
        if (displaySeed === '1' && tenPullDetailData && tenPullDetailData.transition) {
            // 10連シミュレーションの結果がある場合、SEED情報を追記
             gContent += `<br><span class="seed-value" style="font-size: 0.7em; color: #888;">${tenPullDetailData.transition.nextSeed}</span>`;
        }
        table += `<td style="${gStyle}">${gContent}</td>`;
        table += '</tr>';
    }
    table += '</tbody></table>';

    // DOMへの挿入
    document.getElementById('result-table-container').innerHTML = table;
}

====================
FILE: view-uncompleted-ui.js
====================
/**
 * 担当: 「未コンプ」ビューにおける計算過程（詳細）の表示切り替えUI制御
 * 依存関係: なし（独立したUI操作）
 */

/**
 * 計算過程（デバッグビュー）の表示・非表示を切り替えるUI制御を設定する
 * HTML要素の存在をチェックし、安全にイベントリスナーを登録します。
 */
function setupDetailsToggleLogic() {
    const detailsDiv = document.getElementById('calculation-details');
    const detailsControls = document.getElementById('details-controls');
    const toggleBtn = document.getElementById('toggleDetailsBtn');

    // 必要なHTML要素が見つからない場合は、エラーを防止するため処理を中断します
    if (!detailsDiv || !detailsControls || !toggleBtn) {
        return;
    }

    // 以前の実行で追加された可能性のある動的要素（スクロールボタン等）をクリーニング
    const scrollButtons = detailsControls.querySelector('.scroll-buttons');
    if (scrollButtons) {
        scrollButtons.remove();
    }
    
    // 操作用コントロールを表示状態にする
    detailsControls.style.display = 'flex';
    toggleBtn.style.display = 'inline-block';

    /**
     * ボタンクリック時のトグル処理
     * 表示状態に応じてテキストと表示スタイルを切り替えます。
     */
    toggleBtn.onclick = () => {
        const isHidden = detailsDiv.style.display === 'none';
        
        if (isHidden) {
            detailsDiv.style.display = 'block';
            toggleBtn.textContent = '計算過程を非表示';
        } else {
            detailsDiv.style.display = 'none';
            toggleBtn.textContent = '計算過程を表示';
        }
    };
}

====================
FILE: view-uncompleted.js
====================
//Delete

====================
FILE: view-simulation-ui.js
====================
/**
 * 担当: シミュレーションUIの基本要素の生成
 */

function createStyledElement(tag, styles = {}, properties = {}) {
    const element = document.createElement(tag);
    Object.assign(element.style, styles);

    // `dataset` has only a getter and cannot be assigned directly.
    // Handle it separately.
    if (properties.dataset) {
        Object.assign(element.dataset, properties.dataset);
        delete properties.dataset; // Remove it to avoid conflict
    }

    Object.assign(element, properties);
    return element;
}

function createControlRow() {
    const row = createStyledElement('div', {
        display: 'flex',
        alignItems: 'center',
        flexWrap: 'wrap',
        gap: '15px',
        marginBottom: '12px'
    });
    row.innerHTML = `
        <div style="display: flex; align-items: center; gap: 5px;">
            <label style="font-size: 0.8rem; font-weight: bold; color: #555;">チケット:</label>
            <input type="number" id="simTicketInput" value="30" min="1" max="1000" 
                   style="width: 60px; padding: 5px; border: 1px solid #ccc; border-radius: 4px;">
        </div>
        <div id="selectedTargetStatus" style="font-size: 0.75rem; color: #0056b3; font-weight: bold; 
             background: #fff; padding: 5px 10px; border-radius: 4px; border: 1px solid #bdd7ff;">
            階層: 1
        </div>
        <button id="runSimBtn" class="sim-btn sim-btn-run">シミュレーション開始</button>
        <button id="copySimResultBtn" class="sim-btn sim-btn-copy">結果をコピー</button>
    `;
    return row;
}

function createLayersGroup(gacha) {
    const container = createStyledElement('div', {}, { id: 'targetLayersContainer' });
    const addBtn = createStyledElement('button', {
        marginTop: '10px',
        fontSize: '0.75rem',
        padding: '5px 10px',
        cursor: 'pointer',
        backgroundColor: '#fff',
        border: '1px solid #007bff',
        color: '#007bff',
        borderRadius: '4px'
    }, {
        id: 'addPriorityLayerBtn',
        textContent: '＋ 次順位の階層を追加'
    });
    addBtn.onclick = () => createLayerUI(gacha, container.children.length + 1);
    return [container, addBtn];
}

function createResultDisplay() {
    return createStyledElement('div', {
        marginTop: '15px',
        padding: '15px',
        border: '2px dashed #28a745',
        backgroundColor: '#fafffa',
        whiteSpace: 'pre-wrap',
        fontFamily: 'monospace',
        fontSize: '0.85rem',
        display: 'none',
        borderRadius: '8px'
    }, { id: 'sim-result-text' });
}

function createSimUIGroup(gacha) {
    const group = createStyledElement('div', {
        padding: '15px',
        background: '#eef6ff',
        borderRadius: '8px',
        border: '1px solid #bdd7ff',
        marginTop: '10px'
    }, { id: 'sim-ui-group' });

    const controlRow = createControlRow();
    const [layersContainer, addLayerBtn] = createLayersGroup(gacha);
    
    group.append(controlRow, layersContainer, addLayerBtn);
    return group;
}

====================
FILE: view-simulation-layer.js
====================
/**
 * 担当: シミュレーションUIの階層管理
 */

function createLayerUI(gacha, priority) {
    const layersContainer = document.getElementById('targetLayersContainer');
    if (!layersContainer) return;

    const wrapper = createStyledElement('div', {
        marginTop: '12px',
        padding: '10px',
        background: '#fff',
        border: '1px solid #ccc',
        borderRadius: '6px'
    }, { className: 'priority-layer-wrapper' });

    wrapper.innerHTML = `<div style="font-size: 0.8rem; font-weight: bold; margin-bottom: 8px; color: #004085;">
        【第 ${priority} 優先ターゲット】
    </div>`;

    const area = createStyledElement('div', {
        display: 'flex',
        flexWrap: 'wrap',
        gap: '10px',
        maxHeight: '120px',
        overflowY: 'auto',
        padding: '5px'
    }, {
        className: 'layer-selection-area',
        dataset: { priority }
    });

    populateLayerWithOptions(area, gacha);
    wrapper.appendChild(area);
    layersContainer.appendChild(wrapper);

    const status = document.getElementById('selectedTargetStatus');
    if (status) status.textContent = `階層: ${layersContainer.children.length}`;
}

function populateLayerWithOptions(area, gacha) {
    area.innerHTML = '';
    const targetPool = [];
    
    Object.keys(gacha.rarityItems)
          .sort((a, b) => parseInt(b) - parseInt(a))
          .forEach(rid => {
              if (gacha.rarityItems[rid]) targetPool.push(...gacha.rarityItems[rid]);
          });

    Array.from(new Set(targetPool)).forEach(id => {
        const item = itemMaster[id];
        if (!item) return;
        area.appendChild(createItemCheckbox(item));
    });
}

function createItemCheckbox(item) {
    const label = createStyledElement('label', {
        fontSize: '0.75rem',
        display: 'flex',
        alignItems: 'center',
        cursor: 'pointer',
        background: '#f8f9fa',
        padding: '2px 6px',
        borderRadius: '3px',
        border: '1px solid #eee'
    });

    let color = '#333';
    if (item.rarity === 2) color = '#c0a000'; // 激レア
    else if (item.rarity === 3) color = '#d9534f'; // 超激レア
    else if (item.rarity === 4) color = '#0000ff'; // 伝説レア

    label.innerHTML = `
        <input type="checkbox" class="layer-target-checkbox" value="${item.id}" style="margin-right: 5px;">
        <span style="color: ${color}; font-weight: ${item.rarity >= 3 ? 'bold' : 'normal'};">${item.name}</span>
    `;
    return label;
}

function updateSimGachaItems(gacha) {
    const layers = document.querySelectorAll('.layer-selection-area');
    layers.forEach(area => populateLayerWithOptions(area, gacha));
}

====================
FILE: view-simulation-result.js
====================
/**
 * 担当: シミュレーション結果の表示
 */

function displaySimulationResult(result) {
    const display = document.getElementById('sim-result-text');
    display.style.display = 'block';
    display.innerHTML = "";

    if (!result) { 
        display.textContent = "指定されたチケット枚数内でターゲットを獲得できるルートが見つかりませんでした。";
        window.lastSimText = "";
        return;
    }
    
    const header = createResultHeader(result);
    display.appendChild(header);

    const { plainText, pathRows } = renderResultRows(result.path);
    pathRows.forEach(row => display.appendChild(row));
    
    window.lastSimText = `【最適ルートシミュレーション結果】(${header.dataset.status})\n\n` + plainText;
}

function createResultHeader(result) {
    const statusText = result.layerCounts.map((c, i) => `P${i + 1}:${c}`).join(', ');
    const fullStatus = `${statusText} / 超激:${result.ubers} / 伝説:${result.legends}`;

    const header = createStyledElement('div', {
        fontWeight: 'bold',
        marginBottom: '12px',
        borderBottom: '1px solid #28a745',
        paddingBottom: '5px'
    });
    header.textContent = `【最適ルート】(獲得数 -> ${fullStatus})`;
    header.dataset.status = fullStatus;
    return header;
}

function renderResultRows(path) {
    let plainText = "";
    const pathRows = [];
    let i = 0;

    while (i < path.length) {
        let row, plain, consumed;
        if (path[i].type === 'single') {
            ({ row, plain, consumed } = renderConsecutiveSingles(path, i));
        } else {
            ({ row, plain, consumed } = renderTenPull(path, i));
        }
        pathRows.push(row);
        plainText += plain + "\n";
        i += consumed;
    }
    return { plainText, pathRows };
}

function renderConsecutiveSingles(path, startIndex) {
    let j = startIndex;
    const itemsHtml = [], itemsPlain = [];
    while (j < path.length && path[j].type === 'single') {
        itemsHtml.push(getColoredItemHtml(path[j].item));
        itemsPlain.push(path[j].item);
        j++;
    }
    const count = j - startIndex;
    const addr = path[startIndex].addr;
    const header = `<span style="color: #007bff; font-weight: bold;">[単発]</span> ${count}ロール (${addr}～):<br>`;
    const html = "　=> " + itemsHtml.join('、');
    const plain = `[単発] ${count}ロール (${addr}～) => ` + itemsPlain.join('、');
    
    return { row: createResultRow(header + html), plain, consumed: count };
}

function renderTenPull(path, index) {
    const pull = path[index];
    const header = `<span style="color: #c0a000; font-weight: bold;">[10連]</span> (${pull.addr}～):<br>`;
    const html = "　=> " + pull.items.map(getColoredItemHtml).join('、');
    const plain = `[10連] (${pull.addr}～) => ` + pull.items.join('、');

    return { row: createResultRow(header + html), plain, consumed: 1 };
}

function createResultRow(innerHTML) {
    const rowContainer = createStyledElement('div', {
        display: 'flex',
        gap: '8px',
        marginBottom: '6px',
        alignItems: 'flex-start'
    });

    const checkbox = createStyledElement('input', {
        marginTop: '3px',
        cursor: 'pointer'
    }, { type: 'checkbox' });

    const span = createStyledElement('span', { lineHeight: '1.4' }, { innerHTML });

    checkbox.onchange = () => {
        span.style.color = checkbox.checked ? '#aaa' : '#333';
        span.style.textDecoration = checkbox.checked ? 'line-through' : 'none';
    };
    
    rowContainer.append(checkbox, span);
    return rowContainer;
}

function getColoredItemHtml(name) {
    const item = Object.values(itemMaster).find(it => it.name === name);
    if (!item) return name;

    if (item.rarity === 3) return `<span style="color: #d9534f; font-weight: bold;">${name}</span>`;
    if (item.rarity === 4) return `<span style="color: #0000ff; font-weight: bold;">${name}</span>`;
    return name;
}

====================
FILE: view-simulation-main.js
====================
/**
 * 担当: シミュレーションの全体統括
 */

function initializeSimulationView(gacha) {
    const simContainer = document.getElementById('sim-ui-container');
    if (!simContainer) return;

    simContainer.innerHTML = '';
    simContainer.dataset.initialized = 'true';

    const simGroup = createSimUIGroup(gacha);
    const resultDisplay = createResultDisplay();

    simContainer.append(simGroup, resultDisplay);

    document.getElementById('runSimBtn').onclick = runSimulation;
    document.getElementById('copySimResultBtn').onclick = copySimResult;

    createLayerUI(gacha, 1);
}

function getSimulationParams() {
    const tickets = parseInt(document.getElementById('simTicketInput').value);
    if (isNaN(tickets) || tickets <= 0) {
        alert("チケット枚数を正しく入力してください。");
        return null;
    }

    const layers = document.querySelectorAll('.layer-selection-area');
    const targetLayers = Array.from(layers).map(area => {
        const checked = area.querySelectorAll('.layer-target-checkbox:checked');
        return Array.from(new Set(Array.from(checked).map(cb => parseInt(cb.value))));
    });

    return { tickets, targetLayers };
}

function runSimulation() {
    if (!viewData.calculatedData) {
        alert("表示データがありません。まず「更新」ボタンを押してください。");
        return;
    }
    
    const params = getSimulationParams();
    if (!params) return;

    const { Nodes, thresholds } = viewData.calculatedData;
    const { gacha, initialLastRollId } = viewData;
    const initialNg = new URLSearchParams(window.location.search).get('ng') || 'none';

    const result = runGachaSearch(
        Nodes, initialLastRollId, params.tickets, gacha, 
        thresholds, initialNg, params.targetLayers
    );
    
    displaySimulationResult(result);
}

function copySimResult() {
    if (!window.lastSimText || !navigator.clipboard) {
        alert("コピーする結果がありません。先にシミュレーションを実行してください。");
        return;
    }
    navigator.clipboard.writeText(window.lastSimText).then(() => {
        const btn = document.getElementById('copySimResultBtn');
        const originalText = btn.textContent;
        btn.textContent = 'コピー完了！';
        btn.style.backgroundColor = '#28a745';
        setTimeout(() => {
            btn.textContent = originalText;
            btn.style.backgroundColor = '#6c757d';
        }, 1500);
    });
}

