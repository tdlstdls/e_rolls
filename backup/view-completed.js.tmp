/**
 * 担当: 「コンプ済み」ビューのメインテーブルおよび計算詳細のHTML描画
 * 特徴: SEED列の動的挿入、ポップアップ表示、シミュレーションUIの制御
 */

function createAndDisplayCompletedSeedView(initialSeed, gacha, tableRows, thresholds, initialLastRollId, displaySeed, params, initialNg) {
    const { Nodes, highlightInfo, maxNodeIndex, SEED_LIST } = calculateCompletedData(
        initialSeed, gacha, tableRows, thresholds, initialLastRollId, initialNg
    );

    // --- ポップアップ（モーダル）の初期設定 ---
    const popupOverlay = document.getElementById('seed-popup-overlay');
    const popupContent = document.getElementById('popup-content');
    const closeBtn = document.querySelector('.popup-close-btn');
    const copyBtn = document.getElementById('copy-popup-content-btn');

    const closePopup = () => { popupOverlay.style.display = 'none'; };
    closeBtn.onclick = closePopup;
    window.onclick = (event) => { if (event.target === popupOverlay) closePopup(); };

    // ポップアップ内容のコピー機能
    copyBtn.onclick = () => {
        const text = popupContent.innerText;
        navigator.clipboard.writeText(text).then(() => {
            const originalText = copyBtn.textContent;
            copyBtn.textContent = 'コピー完了！';
            setTimeout(() => { copyBtn.textContent = originalText; }, 1500);
        });
    };

    // --- メイン表示テーブルの構築 ---
    const isSeedVisible = (displaySeed === '1');
    let table = `<table style="table-layout: fixed;" class="${currentHighlightMode === 'single' ? 'mode-single' : (currentHighlightMode === 'multi' ? 'mode-multi' : '')}">`;
    
    // ヘッダー生成
    table += '<thead><tr>';
    table += `<th id="forceRerollToggle" class="col-no">${window.forceRerollMode ? '☑' : '□'}</th>`;
    if (isSeedVisible) table += '<th class="col-seed">SEED</th>';
    table += '<th class="data-col">A</th>';
    table += '<th class="data-col">AG</th>';
    if (isSeedVisible) table += '<th class="col-seed">SEED</th>';
    table += '<th class="data-col">B</th>';
    table += '<th class="data-col">BG</th>';
    table += '</tr></thead><tbody>';

    // 行データ生成
    for (let r = 1; r <= tableRows; r++) {
        const nodeIdxA = (r - 1) * 2 + 1;
        const nodeIdxB = (r - 1) * 2 + 2;
        const nodeA = Nodes[nodeIdxA - 1];
        const nodeB = Nodes[nodeIdxB - 1];
        if (!nodeA || !nodeB) break;

        table += `<tr><td class="col-no">${r}</td>`;

        // 左側SEED
        if (isSeedVisible) {
            table += `<td class="col-seed">${SEED_LIST[(r-1)*2]}<br>(Index:${(r-1)*2})</td>`;
        }

        // A列・AG列
        table += renderCell(nodeA, '', r, false);
        table += renderCell(nodeA, 'G', r, true);

        // 右側SEED
        if (isSeedVisible) {
            table += `<td class="col-seed">${SEED_LIST[(r-1)*2 + 1]}<br>(Index:${(r-1)*2 + 1})</td>`;
        }

        // B列・BG列
        table += renderCell(nodeB, '', r, false);
        table += renderCell(nodeB, 'G', r, true);

        table += '</tr>';
    }
    table += '</tbody></table>';
    document.getElementById('result-table-container').innerHTML = table;

    // セル描画用ヘルパー関数
    function renderCell(node, suffix, rowNum, isGuaranteed) {
        const address = node.address + suffix;
        const info = highlightInfo.get(address);
        const itemId = isGuaranteed ? node.itemGId : node.itemId;
        const itemName = isGuaranteed ? node.itemGName : node.itemName;
        let cellContent = '---';

        if (itemId !== -1) {
            // 再抽選情報の取得（機械的一致も考慮）
            const mechanicalMatch = Nodes[node.index - 2] && node.itemName === Nodes[node.index - 2].itemName;
            const showReRoll = !isGuaranteed && (node.reRollFlag || node.reRerollFlag || mechanicalMatch || (window.forceRerollMode && node.rarityId === 1 && node.poolSize > 1));
            
            const seedToUse = showReRoll ? node.seed3 : (isGuaranteed ? node.seed1 : node.seed2);
            const hrefNorm = generateItemLink(isGuaranteed ? node.seed1 : node.seed2, itemId, initialNg, rowNum, true);

            if (isSeedVisible) {
                // SEED表示ON：ポップアップ起動用
                if (showReRoll) {
                    let rrName = node.reRollItemName;
                    if (rrName === '---' && mechanicalMatch) {
                        const rrPool = (gacha.rarityItems[1] || []).filter(id => id !== node.itemId);
                        rrName = getItemNameSafe(rrPool[node.seed3 % Math.max(1, rrPool.length)]);
                    }
                    const rrAddr = getAddressStringGeneric(node.index + 3, 2);
                    cellContent = `<span class="clickable-item" data-node-idx="${node.index-1}" data-is-guar="${isGuaranteed}">${node.itemName}</span><br>(${rrAddr})<span class="clickable-item" data-node-idx="${node.index-1}" data-is-guar="${isGuaranteed}">${rrName}</span>`;
                } else {
                    cellContent = `<span class="clickable-item" data-node-idx="${node.index-1}" data-is-guar="${isGuaranteed}">${itemName}</span>`;
                }
            } else {
                // SEED表示OFF：通常リンク
                if (showReRoll) {
                    let rrId = node.reRollItemId;
                    let rrName = node.reRollItemName;
                    if (rrId === -1 && mechanicalMatch) {
                        const rrPool = (gacha.rarityItems[1] || []).filter(id => id !== node.itemId);
                        rrId = rrPool[node.seed3 % Math.max(1, rrPool.length)];
                        rrName = getItemNameSafe(rrId);
                    }
                    const rrNextAddr = getAddressStringGeneric(node.index + 3, 2);
                    const hrefRe = generateItemLink(node.seed3, rrId, initialNg, rowNum, true);
                    cellContent = `<a href="${hrefNorm}">${node.itemName}</a><br>(${rrNextAddr})<a href="${hrefRe}">${rrName}</a>`;
                } else {
                    cellContent = `<a href="${hrefNorm}">${itemName}</a>`;
                }
            }
        }
        
        const cls = determineHighlightClass(info);
        return `<td${cls ? ' class="' + cls + '"' : ''}>${cellContent}</td>`;
    }

    // アイテム名クリック時のポップアップイベント委譲
    document.getElementById('result-table-container').onclick = (e) => {
        if (e.target.classList.contains('clickable-item')) {
            const nodeIdx = parseInt(e.target.dataset.nodeIdx);
            const isGuar = e.target.dataset.isGuar === 'true';
            const node = Nodes[nodeIdx];
            const currentSeedParam = params.get('seed');
            
            const html = generateNodeCalculationDetailsHtml(node, gacha, thresholds, initialLastRollId, Nodes, currentSeedParam, isGuar);
            popupContent.innerHTML = html;
            popupOverlay.style.display = 'flex';
        }
    };

    // --- シミュレーションUIの生成と表示 ---
    setupSimulationUI(Nodes, initialLastRollId, gacha, thresholds, initialNg);

    // 従来の「計算過程を表示」エリアも更新
    const detailsDiv = document.getElementById('calculation-details');
    let detailsHtml = generateMasterInfoHtml(gacha);
    detailsHtml += '<h3>単発ルート詳細</h3>' + singleRouteText.join('<hr>');
    detailsHtml += '<h3>10連ルート詳細</h3>' + multiRouteText.join('<hr>');
    detailsDiv.innerHTML = detailsHtml;
}

/**
 * シミュレーションUIのセットアップ
 */
function setupSimulationUI(Nodes, initialLastRollId, gacha, thresholds, initialNg) {
    const container = document.getElementById('sim-ui-container');
    container.innerHTML = ''; // クリア
    
    const simGroup = document.createElement('div');
    simGroup.id = 'sim-ui-group';
    simGroup.style.padding = '10px';
    simGroup.style.background = '#eef6ff';
    simGroup.style.borderRadius = '6px';
    simGroup.style.border = '1px solid #bdd7ff';

    simGroup.innerHTML = `
        <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
            <div>
                <label style="font-size: 0.7rem;">チケット:</label>
                <input type="number" id="simTicketInput" value="30" style="width: 50px;">
            </div>
            <button id="runSimBtn" style="background-color: #28a745;">シミュレーション開始</button>
        </div>
        <div id="targetLayersContainer"></div>
        <button id="addPriorityLayerBtn" style="font-size: 0.7rem;">＋ 次順位を追加</button>
        <div id="sim-result-text" style="display:none; margin-top:10px; background:#fff; padding:10px; border:1px dashed #28a745;"></div>
    `;
    container.appendChild(simGroup);

    // シミュレーション実行ロジック
    document.getElementById('runSimBtn').onclick = () => {
        const tickets = parseInt(document.getElementById('simTicketInput').value);
        const layers = []; // ターゲット取得処理（簡略化）
        const result = runGachaBeamSearchCorrected(Nodes, initialLastRollId, tickets, gacha, thresholds, initialNg, layers);
        
        const resDiv = document.getElementById('sim-result-text');
        resDiv.style.display = 'block';
        resDiv.textContent = result ? "最適ルートを算出しました。詳細は計算過程を確認してください。" : "ルートが見つかりませんでした。";
    };
}

/**
 * 内部計算用の補助関数（既存のものを維持・微調整）
 */
function runGachaBeamSearchCorrected(Nodes, lastId, tickets, gacha, thresholds, ng, targets) {
    // 既存のビームサーチロジックをここに移植または維持
    return { score: 0, path: [] }; // ダミー
}